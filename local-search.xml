<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>电厂化学水处理</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E7%94%B5%E5%8E%82%E5%8C%96%E5%AD%A6%E6%B0%B4%E5%A4%84%E7%90%86/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E7%94%B5%E5%8E%82%E5%8C%96%E5%AD%A6%E6%B0%B4%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="水的基本概念">水的基本概念</h2><h3 id="水中杂质">水中杂质</h3><ol type="1"><li><p>悬浮物：悬浮物一般粒径在100nm以上是构成水中浊度的主要因素。</p></li><li><p>胶体：由许多分子或离子组成的集合体，其颗粒直径一般在1nm~100nm之间。</p></li><li><p>溶解物：天然水中溶解物大都以离子或溶解气体的形式存在。</p><ul><li><p>溶解离子：Ca<sup>2+</sup>、Mg<sup>2+</sup> 、Na<sup>+</sup>、K<sup>+</sup>、HCO<sup>3－</sup>、CI<sup>－</sup>、SO<sub>4</sub><sup>2－</sup>等。</p></li><li><p>溶解气体：O<sub>2</sub>、CO<sub>2</sub> 等。</p></li></ul></li></ol><h3 id="水的分类">水的分类</h3><h4 id="按用途分类">按用途分类</h4><ol type="1"><li><p>锅炉给水：直接进入锅炉被蒸发或加热的水。</p></li><li><p>炉水：锅炉内加热或蒸发系统中流动着的水称为炉水。</p></li><li><p>排污水：由于炉水经相当长时间循环运行，水中的微量杂质被浓缩，为保证炉水的质量，必须排污，这就是排污水。</p></li><li><p>补给水：原水经过各种水处理工艺处理后补充锅炉汽水损失的水。</p></li><li><p>生产回水或凝结水：蒸汽的热能被利用后，所回收的冷凝水。</p></li><li><p>原水：水源水，通常是地表水和地下水。</p></li><li><p>冷却水：用作冷却介质的水。</p></li></ol><h4 id="按含盐量分类">按含盐量分类</h4><table><thead><tr class="header"><th style="text-align: center;">类别</th><th style="text-align: center;">低含盐量水</th><th style="text-align: center;">中等含盐量水</th><th style="text-align: center;">较高含盐量水</th><th style="text-align: center;">高含盐量水</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">含盐量(mg/L)</td><td style="text-align: center;">&lt;200</td><td style="text-align: center;">200~500</td><td style="text-align: center;">500~1000</td><td style="text-align: center;">&gt;1000</td></tr></tbody></table><h4 id="按硬度分类">按硬度分类</h4><table><thead><tr class="header"><th style="text-align: center;">类别</th><th style="text-align: center;">极软水</th><th style="text-align: center;">软水</th><th style="text-align: center;">中等硬度水</th><th style="text-align: center;">硬水</th><th style="text-align: center;">极硬水</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">硬度(mmol/L)</td><td style="text-align: center;">&lt;1</td><td style="text-align: center;">1.0~3.0</td><td style="text-align: center;">3.0~6.0</td><td style="text-align: center;">6.0~9.0</td><td style="text-align: center;">&gt;9.0</td></tr></tbody></table><h3 id="水的指标">水的指标</h3><p>锅炉用水水质指标的表达方式通常有两种：</p><p>一种是表示水中所含有的离子或分子，如钠离子、氯离子、磷酸根离子、溶解氧等，一般称为水质指标。</p><p>另一种则并不代表某种单纯的物质，而是表示某些化合物的组合或表征某种特性，如硬度、碱度、溶解固形物、电导率等。这种指标是由于技术上的需要而拟定的，故称为技术指标。</p><h4 id="水质技术指标">水质技术指标</h4><h5 id="浊度">浊度</h5><p>悬浮物是指经过滤后分离出来的不溶于水的固体混合物，可以通过重量法测定。由于测定方法很麻烦，在实际中常采用测浊度的方法来衡量悬浮物和胶体的含量。浊度的单位通常用“福马肼”（FTU、NTU、JTU）表示。</p><h5 id="硬度">硬度</h5><p>水中所有高价金属离子的总和统称为硬度。常用的硬度的定义式为：YD（<spanclass="math inline">\(\frac{1}{2}\)</span>Ca<sup>2+</sup> + <spanclass="math inline">\(\frac{1}{2}\)</span>Mg<sup>2+</sup>）。硬度通常以碳酸钙或氧化钙或德国度表示。</p><ul><li><p>量浓度（mol/L）, C (<spanclass="math inline">\(\frac{1}{2}\)</span>CaCO3) = C (<spanclass="math inline">\(\frac{1}{2}\)</span>CaO) = C (<spanclass="math inline">\(\frac{1}{2}\)</span>Ca<sup>2+</sup>)mol/L</p></li><li><p>ppm（mg/L）, 1mg/L 的CaCO<sub>3</sub>称为1ppm硬度。由于<spanclass="math inline">\(\frac{1}{2}\)</span>CaCO<sub>3</sub>的摩尔质量为50g/L，1mmol/L的（<spanclass="math inline">\(\frac{1}{2}\)</span>CaCO<sub>3</sub>）硬度就相当于50mg/L即50ppm硬度。</p></li></ul><h5 id="酸碱度">酸碱度</h5><p>碱度表示水中能接受氢离子的一类物质的量，在水中碱度主要是OH<sup>－</sup>、<spanclass="math inline">\(\frac{1}{2}\)</span>CO<sub>3</sub><sup>2－</sup>、HCO<sub>3</sub><sup>－</sup>。天然水中的碱度主要是HCO<sub>3</sub><sup>－</sup>。</p><p>酸度表示水中能接受氢氧根离子的一类物质的量，在水中酸度主要有各种酸类及强酸弱碱盐，天然水中的酸度主要是H<sub>2</sub>CO<sub>3</sub>。阳床出水的酸度主要是强酸HCI、H<sub>2</sub>SO<sub>4</sub>及弱酸H<sub>2</sub>CO<sub>3</sub>。</p><h5 id="化学耗氧量">化学耗氧量</h5><p>化学耗氧量是表示水中有机物及还原性物质含量的一项指标。COD的测定利用有机物可氧化这一特性，在一定的条件下，用一定的强氧化剂与水中各种有机物及亚硝酸盐、亚铁盐、硫化物等作用，然后将所消耗的氧化剂的量计算折合成氧的质量浓度，称为化学耗氧量，单位以mg/L来表示。</p><p>一般来说COD越高，水中有机物污染越严重。不同测定方法测得的结果会有所不同。因此表示有机物含量时应注明测定方法。一般情况下，有机物含量较低时采用高锰酸钾法，而有机物含量高时采用重铬酸钾法。同一水样，用重铬酸法测定比用高锰酸钾测定结果要高一些。</p><h4 id="指标间的关系">指标间的关系</h4><h5 id="碱度与硬度">碱度与硬度</h5><ol type="1"><li><p>硬度大于碱度：这种水称为非碱性水，钙、镁离子将首先与HCO<sub>3</sub><sup>－</sup>形成碳酸盐硬度（YDT），剩余硬度离子即钙镁离子与SO<sub>4</sub><sup>2－</sup>、CI<sup>－</sup>等其它阴离子形成非碳酸盐硬度（YDF）。</p></li><li><p>硬度等于碱度：在这种水中，钙、镁离子全部与HCO<sub>3</sub><sup>－</sup>形成碳酸盐硬度。既没有非碳酸盐硬度也没有剩余碱度。</p></li><li><p>硬度小于碱度：在这种碱性水中，硬度将全部形成碳酸盐硬度，剩余的碱度则与Na<sup>+</sup>、K<sup>+</sup>形成钠碱度称为负硬度，此时无非碳酸盐硬度。</p></li></ol><h5 id="碱度与碱度离子">碱度与碱度离子</h5><p>碱度：碱度（JD）是表示水中能接受氢离子的一类物质的量。根据酸碱滴定法测定水中的碱度，这时所用的标准溶液是HCI或H<sub>2</sub>SO<sub>4</sub>溶液，酸与各种碱度离子的三个反应方程式是：</p><p><span class="math inline">\(OH^{-}+H^{+}=H_{2}O\)</span></p><p><span class="math inline">\(CO_3^{2-}+H^{+}= HCO_{3}^{-}\)</span></p><p><span class="math inline">\(HCO_{3}^{-}+ H^{+}=H_{2}O+CO_{2}\)</span></p><p>根据所加指示剂不同，碱度又可分为甲基橙碱度(JD甲)和酚酞碱度(JD酚)。加酚酞指示剂时只能完成上述两个反应；加甲基橙指示剂时三个反应全部完成。(JD甲)被为全碱度。在实际的滴定分析中往往是先加酚酞指示剂，滴至终点pH约为8.2，再加甲基橙指示剂继续滴至终点pH值为4.2。此时的总碱度应为(JD全)=(JD)酚+(JD)甲。</p><h5 id="碱度与ph值">碱度与PH值</h5><p>pH值是表征溶液酸碱性的指标，pH值越大，OH<sup>－</sup>浓度越高。而碱度中，除了OH<sup>－</sup>含量外，还包含了CO<sub>3</sub><sup>2－</sup>和HCO<sub>3</sub><sup>－</sup>含量。所以，它们之间既有区别又有联系。其联系是：在一般情况下，pH值会随着碱度的提高而增大，但这还取决于OH<sup>－</sup>碱度占总碱度的比例；区别在于pH值大小只取决于OH<sup>－</sup>与H<sup>+</sup>的相对含量，而碱度大小则反映了组成碱度的各离子的总含量。因此，对于pH值合格的锅炉用水，有时碱度不一定合格；反之，碱度合格的水，pH值也不一定合格。</p><h2 id="水处理工艺">水处理工艺</h2><h3 id="预处理">预处理</h3><h4 id="一体化净水器">一体化净水器</h4><p>主要是依据浅层沉淀理论，设置了斜管加速沉降。下部沉降快速形成的大颗粒絮状体，在两层斜管之间，由于流速方向发生改变，将会增加小颗粒絮体间的接触机会，在流经上层斜管时，进一步提高水质，沉淀池中污源，一部分回流到絮凝反应池，剩余部分入污泥区，污泥定期排放。斜管清水区得出水经波形多孔集水板集水，均匀分配给分配水箱，分配水箱出水进入滤池进行过滤，去除泄漏的微量悬浮物，出水经冲洗水箱进入清水池，该滤池采用反射布水、多空板集水，滤料为石英砂，反冲洗为达到额定水头损失后，自动虹吸反冲。</p><h4 id="双介质过滤器">双介质过滤器</h4><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/mechanical_filter.jpg" /></p><h3 id="除盐">除盐</h3><h4 id="阳离子交换器">阳离子交换器</h4><p>进入一级除盐系统的水是经预处理，水中只含有少量的溶解性杂质。溶解性杂质包括阳离子、阴离子、少量胶体硅等。其中水中的阳离子主要由Ca2+、Mg2+、K+、Na+和极少量的Al3+、Fe3+离子组成，阴离子主要由HCO3－、SO42-、Cl－和少量的NO3-、HSiO3-离子组成。</p><p>当水通过强酸性H型阳交换器时，水中所有的阳离子都被强酸性H型树脂吸收，活性基团上的H+被置换到水中，与水中的阴离子组合生成酸。其反应式：</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/exchange_reaction.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>阳离子交换器的出水是酸性水。但当交换器运行失效时，其出水中就会有其它阳离子的泄漏，而在诸多的阳离子中，首先漏出的阳离子是Na+，故习惯上称之为漏钠。当出水中的Na+超过一个给定的极限值时，阳离子交换器被判失效，需停运再生后才能投入运行。</p><p>为什么阳交换器失效时，首先发生漏钠，而不是漏Ca2+或Mg2+离子？这是因为水中各种阳离子与树脂中H+发生交换反应时，因树脂对各种阳离子的吸收有选择性，故被树脂吸收的离子在交换器内有分层现象，根据树脂对被吸收离子的选择性顺序，最上层是最易被吸收的Ca2+，次层以Mg2+为主，下层就是Na+。强酸性阳树脂的选择性顺序为：Fe3+&gt;A13+&gt;Ca2+&gt;Mg2+&gt;K+&gt;NH4+&gt;Na+</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/cation_exchange_bed.jpg" /></p><p>进水装置的作用：是均匀分布进水于交换器的过水断面上。另一个作用是均匀收集反洗排水。</p><p>压脂层的作用：过滤掉水中的悬浮物及机械杂质；使进水通过压脂层均匀作用于树脂层表面；防止树脂在逆流再生中乱层。</p><p>中间排液装置的作用：中间排液装置对逆流再生离子交换器运行效果有较大影响，其作用是均匀排出再生液，防止树脂乱层、流失外，还应有足够的强度，安装时应保证在交换器内呈水平状态。</p><p>排水装置的作用：是均匀收集处理好的水；另一个作用是均匀分配反洗进水。</p><p>当交换器不断进水，随离子交换的不断进行，由于水中的Ca2+比Mg2+、Na2+与树脂的亲合力更大，更易被树脂吸收，所以水中的Ca2+­离子可和已吸收了Mg2+的树脂进行交换反应，使Ca型树脂层向下扩展，而被置换下来的Mg2+一起与Na+型树脂发生交换，使Mg2+型树脂层下移而Na+的交换区域也逐渐下移。</p><p>树脂的再生</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/regeneration_flow.jpg" /></p><p>无顶压逆流再生的操作步骤：</p><p>1）小反洗。只对压脂层进行反洗，冲洗掉积聚在压脂层上的污染物。用水为该级交换器的进口水，流速树脂不乱层为宜，一直反洗至出水清澈为为止。</p><p>2）放水。待树脂颗粒下沉后，放掉中间排液装置以上的水。</p><p>3）进再生液。将再生液放入交换器内，严格控制其流速和浓度</p><p>4）逆流再生。进完再生液，关闭再生液计量箱出口阀，按再生液的流速和流量继续用稀释再生液的除盐水进行冲洗，直至出水指标合格为止。关闭进水阀。</p><p>5）小正洗。水从上部进入，控制适当的流速，洗去再生后压脂层中残留的再生废液和杂质。小正洗用水为运行时的进口水。</p><p>6）正洗。用水自上而下进行正洗，直到出水水质合格，即可投运运行。</p><p>▲除碳器</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/decarburizer.jpg" /></p><p>除碳原理</p><p>水通过阳离子交换器，水中的HCO<sup>3-</sup>与从树脂上交换下来的H<sup>+</sup>结合，形成H<sub>2</sub>CO<sub>3</sub>极不稳定，随即分解生成的CO<sub>2</sub>：</p><p>H2CO3 → H2O+CO2</p><p>水中的CO2，可以看作是溶解在水中的气体，它的溶解度与气体分压的关系符合亨利定律，即在一定的温度下气体在液体中的溶解度与该气体在液面上的分压成正比。只要降低水面上CO2的分压力，溶于水中的游离CO2就能解吸出来。</p><p>降低液面CO2气体分压的常用方法有鼓风和抽真空两种。</p><p>▲阴离子交换器</p><p>阴离子交换实质上是阴树脂中的OH与酸性水(经过阳离子交换及除碳)中的负离子进行交换。所以在强碱性阴离子交换器内发生的反应为：</p><p>▲混合离子交换器</p><p>由于阳、阴树脂混合均匀，所以阳、阴离子交换反应几乎是同时进行的，置换出的H+和OH-立即生成水，都不会积累，消除了反离子作用，交换反应进行得十分彻底，出水水质很好。交换反应如下：</p><figure><imgsrc="https://nimg.ws.126.net/?url=http%3A%2F%2Fspider.ws.126.net%2F99f328c658e5e613f471581e0c27c6c8.png&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>交换器内有无数对阴阳树脂，运行过程中阳树脂吸附水中的阳离子放出H，阴树脂吸附阴离子放出OH，同时H和OH反应成H2O。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/mixed_bed.jpg" /></p><p>混合床是圆柱型密闭容器。其内部有进水装置、排水装置、中部有再生时排再生废液的中间排水装置等。为了便于阳、阴树脂分层，混合床中阳树脂与阴树脂的湿真密度差应大于0.15～0.20g／cm3。国内混合床采用的阳、阴树脂的体积比为1：2。</p><p>经过一级复床处理后的水质，一般电导率小于0.2μS／cm，pH接近中性，含硅量(以SiO2计)在20μg／L以下。</p><h2 id="汽水监督">汽水监督</h2><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/steam_process.jpg" /></p><p>凝汽式发电厂水汽循环系统主要流程动虽呈循环状，但这是主流，并非全部，在实际运行中总不免有些损失。造成汽水损失的主要原因有如下几个方面：</p><p>（1）锅炉部分</p><p>锅炉的排污放水，锅炉安全门和过热器放汽门的向外排汽，用蒸汽推动附属机械（如汽动给水泵），蒸汽吹灰和燃烧液体燃料（如油等）时采用蒸汽雾化法等，都要造成汽水损失。</p><p>（2）汽轮机机组</p><p>汽轮机的轴封处要连续向外排汽，在抽气器和除氧器排气口处会随空气排出一些蒸汽，造成损失。</p><p>（3）各种水箱及采样器。有溢流、长流等损失。</p><p>（4）管道系统。各管道系统法兰盘连接处不严密和阀门漏泄等原因，也会造成汽水损失。</p><p>为了维持发电厂热力系统的水汽循环运行正常,凝汽式发电厂在正常运行情况下，补给水量不超过锅炉额定蒸发量的2％~4％。</p><h3 id="水汽质量指标">水、汽质量指标</h3><ol type="1"><li>蒸汽</li></ol><p>（1）为了防止蒸汽通流部分，特别是汽轮机内积盐，必须对锅炉蒸汽汽质进行监督。饱和蒸汽和过热蒸汽应同时监督的原因是：</p><p>①便于检查蒸汽汽质劣化的原因。例如，饱和蒸汽汽质较好，而过热蒸汽汽质不良，表明蒸汽在减温器内被污染。</p><p>② 可以判断饱和蒸汽中的盐类在过热器内的沉积量。</p><p>（2）由于钠盐和硅酸往往是蒸汽携带的主要杂质，所以对钠和硅含量的监测是监督蒸汽品质的主要指标。</p><p>（3）电导率的测定，操作简便、灵敏度高，因此高压以上的锅炉为了及时掌握蒸汽中的含盐量，常将蒸汽经冷凝后通过氢离子交换柱，连续测定其电导率的大小，从而反映出蒸汽含盐量的状况。采用氢离子交换后的电导率而不采用总电导率，是为了避免蒸汽中氨的干扰（对凝结水电导率测定也是如此）。</p><p>2、给水</p><p>为了防止锅炉及给水系统的腐蚀、结垢，并且在锅炉正常排污的情况下，能保证锅水水质量合格，必须对给水水质进行监督。标准中各项指标的监测意义如下：</p><p>（1）硬度。为防止锅炉及给水系统的结垢，避免锅水中产生过多的水渣，须严格控制给水硬度。</p><p>（2）油。由于给水中若含有油质，将有可能造成炉管内和过热器内生成导热系数极少的附着物，危及锅炉安全运行；同时油质还易使锅水形成泡沫，劣化蒸汽品质，因此，须对给水中油质进行监督。</p><p>（3）溶解氧。为了防止系统发生氧腐蚀，监督除氧器的除氧效果而进行监测。</p><p>（4）联氨。给水中加联氨时，应监督给水中的过剩的联氨，以确保除去残余的溶解氧，并消除因给水泵不严密等异常情况时偶然漏入的氧量。</p><p>（5）pH值。为了防止给水系统腐蚀，给水pH值应控制在规定范围内。若给水pH值在9.2以上，虽对防止钢材的腐蚀有利，但因为提高给水pH值通常是用加氨的方法，所以有时给水pH值过高意味着水汽系统中氨含量较高，有可能会引起铜部件的氨蚀。所以给水最佳pH值应以保证热力系统铁、铜腐蚀产物最少为原则。</p><p>（6）铁和铜。为了防止炉中产生铁垢和铜垢，必严格监督给水中的铁和铜含量。另外，给水中铁和铜含量，还可作为评价热力系统金属腐蚀情况的依据之一。</p><p>（7）钠、硅、电导率。为了在锅炉排污率不超过规定值的情况下，保证锅水中的钠、硅、电导率不超过允许值，应监督和控制给水中的钠、硅 、电导率。</p><p>3、凝结水</p><p>凝结水质量标准中各项指标的监测意义如下：</p><p>（1）硬度。由于凝汽器泄漏时会造成凝结水中硬度含量升高，并导致给水硬度不合格，所以应对凝结水硬度进行监督。</p><p>（2）溶解氧。在凝汽器和凝结水泵不严密处漏入空气，是凝结水增高的原因。凝结水含量较大时，易引起凝结水系统腐蚀，还会使随凝结水进入给水的腐蚀产物增多，影响给水水质，所以应监督凝结水中的溶解氧。</p><p>（3）电导率。为了能及时发现凝汽器的泄漏，测定凝结水的电导率是最方便的方法。通常当发现电导率比正常测定测大得多时，就表明凝汽器发生了泄漏。</p><p>（4）含钠量。由于钠度计比电导率仪更为灵敏，因此监凝结水含钠量可迅速及时地发现凝汽器微小的泄漏。</p><p>4、炉水</p><p>为了防止锅内结垢、腐蚀，保证蒸汽品质良好，必须对锅水水质进行监督。锅水质量标准中各项指标监测意义如下：</p><p>（1）pH值。锅水的pH值应不低于9.0，主要原因是：</p><p>① pH值低时，水对锅炉钢材的腐蚀性增强；</p><p>但是，锅水中的pH值也不能太高，以免锅水中游离氢氧化钠引起碱性腐蚀。</p><p>②锅水中磷酸根和钙离子的反应只有在pH值足够高的条件下，才能生成容易排除的水渣，从而较好地达到防垢的目的。</p><p>③为了抑制锅水中硅酸盐的水解，减少硅酸在蒸汽中的溶解携带量。</p><p>但是，锅水中的pH值也不能太高，以免锅水中游离氢氧化钠引起碱性腐蚀。</p><p>（2）总含盐量、二氧化硅、电导率。限制锅水中这些指标的含量，是为了保证蒸汽汽质合格。锅水中这些指标的最大允许含量不仅与锅炉汽水品质的参数、汽包内部装置的结构有关，而且还与运行工况有关。测定炉水含硅量，还可测算锅炉的排污率，并了解炉水中含硅量对蒸汽的影响。</p><p>（3）磷酸根。锅炉水中应维持有一定量的磷酸根，以防止受热而结生钙垢。磷酸根太少不利防垢，而过多则会产生易溶盐“隐藏”现象，故应将磷酸根控制在合适的范围内。</p><p>（4）氯离子。炉水的氯离子超标时，可能会破坏水冷壁管的保护膜并引起腐蚀（在炉管热负荷高的情况下，更易发生这种现象）。此外，如炉水CI－含量较高，会使蒸汽携带CI－进入汽轮机内，有可能引起汽轮机内高级合金钢的应力腐蚀损坏。</p><p>■运行中水汽控制标准及检测周期</p><figure><imgsrc="https://nimg.ws.126.net/?url=http%3A%2F%2Fspider.ws.126.net%2F0dbe63d4ad5c6f8dae1ebd9d5dedcd08.jpeg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>■停、备用机组启动时的水、汽质量标准</p><figure><imgsrc="https://nimg.ws.126.net/?url=http%3A%2F%2Fspider.ws.126.net%2Ffa2ba516fcd6d0d6c8d7044ea03799bc.jpeg&amp;thumbnail=660x2147483647&amp;quality=80&amp;type=jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="加药处理">加药处理</h3><p>★给水加氨处理</p><p>♠目的：给水加氨为的是提高给水PH值，消除残余二氧化碳对给水系统的腐蚀。加联氨为的是消除给水中残余溶解氧，防止系统氧腐蚀。</p><p>♠原理：给水加氨冲缓给水中游离二氧化碳的存在而造成的酸性腐蚀，反应方程式如下：</p><p>NH3+CO2+H2O→NH4HCO3</p><p>碳酸氢铵产生后提高了给水的PH值。</p><p>★给水加联氨处理</p><p>♠目的：给水中加联氨 加强热力除氧效果。</p><p>♠原理：反应方程式如下：N2H4+O2→N2+2H2O</p><p>反应生成的产物N2和H2O，对热力设备的运行无任何害处。</p><p>★炉内磷酸盐处理</p><p>♠目的：</p><p>1、除掉炉水中的Ca2+，防止锅炉受热面上产生钙垢。</p><p>2、消除炉水中的游离NaOH，防止锅炉受热面产生碱性腐蚀。</p><p>♠原理：</p><p>协调PH—磷酸盐处理就是要使炉水的磷酸根和PH值维持在一个特定范围内，从而起到防垢、防腐的目的。</p><p>反应方程式如下：</p><p>10Ca2++6PO43-+2OH-+Na3PO4→3Ca2(PO4)2+Ca(OH)2↓</p><p>生成的碱性磷酸钙是一种松散的水渣，易随锅炉排污除去。</p><p>锅炉的排污处理</p><p>连续排污</p><p>目的：连续地从汽包中排放锅炉水，是防止炉水中的含盐量和含硅量过高，并能排出汽包内细微的或悬浮的水渣。</p><p>排污时的规定：在保证蒸汽品质的前提下排污率维持在0.5%-1.0%之间。</p><p>连续调整：</p><p>锅炉刚启动，炉水比较混浊时，应当尽可能将连排开大。</p><p>炉水的硅酸根等项目超标时，应适当增大连排开度。</p><p>定期排污</p><p>目的：定期地从锅炉底部排放部分炉水，以除去沉积在锅炉底部联箱中的水渣。</p><p>定期排污的规定：</p><p>锅炉运行人员应当根据化学人员的通知进行定期排污，在正常情况下，每天进行一次，每次逐个全开30秒。</p><p>异常情况下，增加定排次数，在在新装锅炉的试运期或检修后锅炉的启动也应增加定排次数。</p><p>定期排污还可用来迅速降低炉水含盐量以弥补连续排污的不足。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工业技术</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AspenPlus物性方法</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/AspenPlus%E7%89%A9%E6%80%A7%E6%96%B9%E6%B3%95/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/AspenPlus%E7%89%A9%E6%80%A7%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在化工流程模拟过程中，所执行的最主要的热力学计算是相平衡。而其中又以汽液相平衡最为主要。我们在AspenPlus当中也可以看到非常多的物性方法供我们进行选择，其中主要有两大类：状态方程法和活度系数法。本期推送，我们就来揭开这两类方法的区别。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/NRTL.png" /></p><p>一个平衡系统的汽液相中对于每个组分最基本的关系，是组分在气相中的逸度等于在液相当中的逸度。组分的逸度既可以用逸度系数表示，也可以用活度系数来表示。对于气相而言，由于气相的活度系数关系式尚未建立，因此逸度常用逸度系数来表示。而对于液相而言，逸度既可以用逸度系数来表示，也可以用活度系数来表示。也正是因为液相中逸度的表达方式有两种，所以也就出现两种方法：状态方程法和活度系数法。<span class="math display">\[f_{i}^{v}=f_{i}^{l}\]</span>当汽液相逸度均使用逸度系数来进行表示时，如下图，那么根据气液相逸度相等（等式1和2左侧相等），便可得到第三个等式。</p><p><span class="math display">\[\begin{aligned}f_i^v=\varphi_i^vy_iP\\f_i^l=\varphi_i^lx_iP\\\varphi_i^vy_i=\varphi_i^lx_i\end{aligned}\]</span>公式中逸度系数的计算如下所示，可以发现逸度系数的计算与温度、压力和组成相关，需要依赖状态方程和混合规则，因此被称为状态方程法。<span class="math display">\[\ln \varphi_i^{\alpha}=-\frac{1}{RT}\int_{\infty}^{V\alpha}[(\frac{\partial P}{\partial n_i})_{T,v,n}-\frac{RT}{V}]\rm dV-\ln Z_m^a\]</span> AspenPlus当中常用的状态方程法有Peng-Robinson、R-K-Soave等等，具体如下表所示：</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/thermodynamics_methods.webp" /></p><p>对于活度系数法，气相逸度采用逸度系数表示，而液相逸度则采用活度系数来表示，如下图。同样根据气液相逸度相等（等式1和2左侧相等），便可得到第三个等式。其中左边包含了逸度系数，前面提到，需要依赖状态方程和混合规则计算。而右边包含了活度系数，活度系数的计算，是通过活度系数模型来得到的。<span class="math display">\[\begin{aligned}f_i^v=\varphi_i^vy_iP\\f_i^l=x_ir_i^lf_i^{*,l}\\\varphi_i^vy_iP=x_ir_i^lf_i^{*,l}\end{aligned}\]</span>活度系数模型分为两类，一类是经典模型，以vanLaar、Margules方程为代表，对于较简单的系统能获得较理想的结果。第二类是20世纪60年代以后从局部组成概念发展起来的活度系数模型，典型代表有Wilson和NRTL方程等等。能从较少的特征参数关联或推算混合物的相平衡，特别是对于非理想性系统的气液相平衡有较为满意的结果。所以说，相比而言，第二类模型更加优秀。</p><p>根据前面的介绍我们也知道，活度系数法其实是包含了液相活度系数的计算和气相逸度系数的计算。所以物性方法的缩写也就是这两个计算方法的缩写，比如NRTL-RK所代表的物性方法其实就是液相活度系数用NRTL方程计算，气相逸度系数用RK方程计算。所以活度系数方程和逸度系数方程进行组合可以有很多种物性方法。以下是Aspen当中有的活度系数模型。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/thermodynamics_methods2.webp" /></p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/thermodynamics_methods3.webp" /></p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/thermodynamics_methods4.webp" /></p><p>状态方程法和活度系数法各有优缺点，因此适用于不同的体系和温度压力范围。下表是孙兰义老师在书中对这两种方法进行的比较，之前在亨利组分推送当中也提到了一些（点击即可跳转<ahref="https://mp.weixin.qq.com/s%3F__biz%3DMzU5OTQxMjI5MA%3D%3D%26mid%3D2247488625%26idx%3D1%26sn%3D0a6b4eb3d63fb920fc8b71bd5a359b4d%26chksm%3Dfeb40f5cc9c3864a69e1d6c8d4bff9b88738fa081c64e0679dd2c50c1b8fe6cd02caf5518d04%26scene%3D21%23wechat_redirect">什么时候要选择Henry组分，为什么要选Henry组分？</a>）。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/thermodynamics_methods_comparison.webp" /></p><p>两种物性方法的最关键区别，就是液相当中逸度计算方法的选择。看完本篇推送，以后在进行物性方法的选择时，至少应该能知道选择的物性方法是状态方程法还是活度系数法了吧!</p><p>原文链接：https://zhuanlan.zhihu.com/p/524133786</p><p>扩展内容：</p><p>压缩因子和逸度系数都是对实际气体偏离理想气体程度的修正，前者修正的是EOS 中的摩尔体积，后者修正的是压力。</p><p>理想气体的假设忽略了分子的体积和分子之间的作用力；理想溶液假定溶质完全均匀分散于溶剂中，且忽略分子之间的作用力。活度系数从浓度的角度反映了实际溶液偏离理想溶液的程度。</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IAPWS对于常见问题的解答</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/IAPWS%E5%AF%B9%E4%BA%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/IAPWS%E5%AF%B9%E4%BA%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94/</url>
    
    <content type="html"><![CDATA[<h2 id="水分子的结构">水分子的结构</h2><p>水分子由两个氢原子和一个氧原子组成。原子之间的的夹角大约是104.5°。氢、氧原子之间的中心距大约是0.0957nm。分子结构如下图：</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/molecule.gif" /></p><p>因为氧原子比氢原子氧化性更强，简单说来就是氧原子更能吸引电子，所以水分子中共价键共用的电子更靠近氧原子，致使氧原子显负电性。同理，由于共价电子偏离了氢原子，氢原子就显正电性。如果分子空间结构是不对称的，上述共用电子的偏离就会使得分子整体显极性，极性程度用电偶极矩定量表示。水分子的电偶极矩大约是1.85德拜 。</p><p>水分子的极性直接促成了氢键，即水分子中氧原子的吸引，相邻水分子中的氧原子、氢原子和当前氧原子空间上排成一个直线型的稳定结构。氢键不属于范德华力，且作用程度强于范德华力。氢键结构如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/dimer.png"alt="dimer" /><figcaption aria-hidden="true">dimer</figcaption></figure><p>氢键也是水分子的能量存储场所，这可以解释了水的一些独特的性质，包括巨大的气化潜热和结冰后反常的膨胀现象。</p><h2 id="结冰后体积膨胀">结冰后体积膨胀</h2><p>大多数液体都是”热胀冷缩“。”冷缩“是因为温度降低后，分子运动变慢，水分子克服分子间引力的能力减弱，分子们就挨得越来越近，直至凝固成冰。而固体紧密的晶体结构会进一步使得体积收缩。</p><p>当水被冷却时，它的体积如预期一样会收缩。当温度降至4℃时，体积反而开始逐渐轻微膨胀，达到冰点时膨胀才停止，整个过程中大约膨胀了9%。这是很反常的现象。</p><p>这种”与众不同“源于水分子的特殊结构，也就是上节提到的氢键。温度降低，分子能量逐渐降低，其晃动氢键的能力也随之减弱，氢键作用愈加凸显，水分子间形成氢键网络的倾向性逐步增强。冰完全由氢键构建，这些氢键迫使冰形成了相对"开放"的晶体结构，如下图所示：</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/ice1.gif" /></p><p>下图第一张展现了液态水的典型结构，第二张展现了冰的典型结构；注意观察冰中水分子间的“开放”空间。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/ice_molecule.png" /></p><p>这种开放的结构导致冰的密度比水小，这就是为什么冰会浮在水面上。</p><p>再来解释下水的最大密度的由来。温度接近冰点时，水中局部分子形成了冰状结构，使得水中出现"开放"空间，这使得水密度倾向于降低。冷却时分子也会更加靠近，这使得水密度倾向于增大。大约4摄氏度时，两种对立趋势达到平衡，此时就出现了最大密度。</p><h2 id="压力与沸点的关系">压力与沸点的关系</h2><p>在任何温度下，液体都会产生蒸汽压，可将蒸气压想象成液相分子逃逸到气相中的程度。温度越高，分子运动越快，克服分子引力的能力越强，换言之会有更多的分子逃逸到气相中，因此蒸汽压随温度的升高而升高。当蒸气压达到或超过环境压力时，液体就会沸腾。</p><p>在标准大气压下，水的沸点大约是100℃，也可认为100℃时水的蒸汽压大约是1个标准大气压。更高的环境压力下（比如高压锅中），要求沸腾时的蒸汽压更高，因此沸点也要更高，因此受压的水的沸点更高。同样，当环境压力较低时（如高海拔地区），在较低的温度下水蒸气压就可达到环境压力。例如，在美国科罗拉多州丹佛地区，那里的海拔高度约为1600米，大气压力约为标准大气压的83%，水的沸点约为95摄氏度。</p><p>下表列举了水的饱和蒸汽压与温度的关系，这是通过IAPWS方法获得的，供工程和科学研究之用。</p><table><thead><tr class="header"><th>Temperature (degrees Celsius)</th><th>Vapor Pressure (MPa)</th></tr></thead><tbody><tr class="odd"><td>0.01</td><td>0.000 612</td></tr><tr class="even"><td>25</td><td>0.003 17</td></tr><tr class="odd"><td>50</td><td>0.012 35</td></tr><tr class="even"><td>75</td><td>0.0386</td></tr><tr class="odd"><td>100</td><td>0.1014</td></tr><tr class="even"><td>150</td><td>0.4762</td></tr><tr class="odd"><td>200</td><td>1.555</td></tr><tr class="even"><td>250</td><td>3.976</td></tr><tr class="odd"><td>300</td><td>8.588</td></tr><tr class="even"><td>350</td><td>16.529</td></tr><tr class="odd"><td>373.946</td><td>22.064</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>基础理论</tag>
      
      <tag>工业技术</tag>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热力学公式的推导</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E7%83%AD%E5%8A%9B%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E7%83%AD%E5%8A%9B%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<p>实际工程计算中经常会见到热力学的影子，然而热力学并不是一门很好掌握的学科。也许大家都早已熟稔一些基本的热力学概念，但是这远远不够的。热力学是一门应用科学，公式是其精华和核心，也是一道绕不开的坎。本文从最基本的热力学公式出发，展示一些重要应用公式的推导过程。</p><h2 id="推导原则">推导原则</h2><p>热力学公式有很多，推导过程难易不一，推导原则如下：</p><ol type="1"><li>公理不推导</li><li>数学公式不推导</li><li>无实际应用的公式不推导</li></ol><h2 id="相关概念和定义">相关概念和定义</h2><p>要想看懂下面的公式推导，有几个基本概念需要提前掌握。</p><h3 id="热力学概念">热力学概念</h3><p>简单可压缩热力系</p><blockquote><p>与外界只有热量交换和<strong>体积功</strong>转换的可压缩热力系统。热力学常以<strong>闭口的</strong>简单可压缩热力系为基础展开研究，典型模型气缸活塞模型。</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/20230211Thermodynamics%20piston.jpeg"alt="Thermodynamics Piston" /><figcaption aria-hidden="true">Thermodynamics Piston</figcaption></figure><p>平衡状态</p><blockquote><p>如果一个热力学系统的所有不平衡势都已消除（力平衡、热平衡、相平衡、化学平衡），那么这个系统就处于平衡状态，此时就可以用状态参数去描述它。</p></blockquote><p>准静态过程</p><blockquote><p>准静态过程由一系列无限接近于平衡状态的热力过程所组成，也称为准平衡过程。</p></blockquote><p>可逆过程</p><blockquote><p>热力系统经过一个热力过程后，如过程沿原路径逆向返回后<strong>系统本身和外界同时恢复到原初的状态</strong>，那么这个过程就是可逆过程。</p><p>可逆过程首先必须是准静态过程，其次过程中不能发生任何耗散效应。</p></blockquote><p>理想气体</p><blockquote><p>理想气体忽略了气体分子的体积和相互之间的作用力，其状态参数满足理想气体状态方程。</p></blockquote><p>理想气体状态方程</p><blockquote><p>对于 n(mol) 气体，则有<span class="math inline">\(pV=n\rmRT\)</span>，<spanclass="math inline">\(R\)</span>被称为通用气体常数。</p><p>对于单位质量（1kg）的理想气体，则有<spanclass="math inline">\(p\dfrac{V}{m}=\dfrac{n}{m}RT\Rightarrowp\upsilon=\rm R_{\rm g}T\)</span>。<span class="math inline">\(R_{\rmg}\)</span>被称为气体状态常数，定义为<spanclass="math inline">\(\dfrac{R}{M}\)</span>。另外<spanclass="math inline">\(\upsilon\)</span>是气体的比体积，定义为单位质量气体所占据的体积。</p></blockquote><h3 id="数学定义">数学定义</h3><p><span class="math inline">\(\rm d(xy)=(x+\rm dx)(y\rm +dy)-xy=x\rmdy+y\rm dx+\rm dx\rm dy+xy-xy=x\rm dy+y\rm dx+\rm dx\rm dy\)</span></p><p>由于上式中的<span class="math inline">\(\rm dx\rmdy\)</span>是高阶无穷小，因此上式可以演化成<spanclass="math inline">\(\rm d(xy)=x\rm dy+y\rm dx\)</span></p><hr /><p><span class="math inline">\(a\ln b=\ln{b^a}\)</span></p><p><span class="math inline">\(\ln a-\ln b=\ln\dfrac{a}{b}\)</span></p><p><span class="math inline">\(\ln a+\ln b=\ln{ab}\)</span></p><h2 id="公式推导">公式推导</h2><h3 id="热力学第一定律">热力学第一定律</h3><p>热力学第一定律是普适的，适用于任何热力系统及热力过程，并且攘括了宏观和微观两种形式的能量，其能量如下：<span class="math display">\[Q=\Delta E+W=\Delta U+\Delta E_{\rm k}+\Delta E_{\rm p}+W\]</span></p><p>闭口系相对开口系要简单，我们先从闭口系开始研究，忽略宏观能量（宏观功能和势能）的变化，闭口系能量方程如下：</p><p><span class="math display">\[Q=\Delta U+W\]</span></p><p>以单位质量的工质为研究对象可将广延参数转变为强度参数，研究起来更方便。因此，对于1kg工质来讲，闭口系能量方程可表达为如下两种形式： <spanclass="math display">\[\begin{aligned}q &amp;= \Delta u+w\\\delta q&amp;=\rm du+\delta w\end{aligned}\]</span></p><h3 id="气体热力学参数">气体热力学参数</h3><p>以下公式推导过程未引用理想气体状态方程，适用于任何气体。</p><p>等容过程的体积功为零；等压过程压力恒定，因此对压力的微分为零，体积功可表达为<spanclass="math inline">\(p\rmd\upsilon\)</span>，这同样适用于下面要讲到的可逆过程。 <spanclass="math display">\[\left.\begin{aligned}\delta q = \rm du+\delta w\\\upsilon=const\end{aligned}\right\}\Rightarrowc_v\rm dT=\rm du+0\Rightarrowc_v=\frac{\rm du}{\rm dT}\]</span></p><p><span class="math display">\[\left.\begin{aligned}h=u+p\upsilon\\c_p\rm dT=\rm du+p\rm d\upsilon\\p=const\end{aligned}\right\}\Rightarrow\rm dh=\rm du+\rm p\rm d\upsilon\Rightarrow\rm dh=c_p\rm dT\Rightarrowc_p=\frac{\rm dh}{\rm dT}\]</span></p><h3 id="理想气体热力学参数">理想气体热力学参数</h3><p><span class="math display">\[\left.\begin{aligned}p\upsilon=R_gT\\p=const\end{aligned}\right\}\Rightarrowp\rm d\upsilon=R_{\rm g}\rm dT\RightarrowR_{\rm g}=\frac{p\rm d\upsilon}{\rm dT}\]</span></p><p><span class="math display">\[\left.\begin{aligned}\delta q = \rm du+\delta w\\R_g=\frac{p\rm d\upsilon}{\rm dT}\\p=const\end{aligned}\right\}\Rightarrowc_p\rm dT=\rm du+p\rm d\upsilon\Rightarrowc_p=\frac{\rm du}{\rm dT}+\frac{p\rm d\upsilon}{\rm dT}\Rightarrowc_p=\frac{\rm du}{\rm dT}+R_{\rm g}\]</span></p><p><span class="math display">\[\left.\begin{aligned}c_v=\frac{\rm du}{\rm dT}\\c_p=\frac{\rm du}{\rm dT}+R_{\rm g}\end{aligned}\right\}\Rightarrowc_p=c_v+R_{\rm g}\]</span></p>$$ .<span class="math display">\[\begin{aligned}\mathrm ds=\frac{\delta q}{T} \\\delta q=c_v \mathrm dT + p\mathrm d\upsilon \\p\upsilon=RT\end{aligned}\]</span>} ds==c_v+R s=<em>{T_1}^{T_2}c_v,dT+ </em>{_1}^{_2}<span class="math display">\[\begin{aligned}\Delta s=0 \\\Delta s=c_p\ln\frac {T_2}{T_1}-\text R \ln \frac{p_2}{p_1}\\\frac {\text R} {c_p}=1-\frac 1 \gamma \\\end{aligned}\]</span><p>} =R{c_p} =1- =(1- )= =()^{1- } $$</p><p><span class="math display">\[\left.\begin{aligned}\frac{T_2}{T_1}=\frac{p_2}{p_1}^{1-\frac 1 \gamma} \\p\upsilon=RT\Rightarrow\frac{p_2\upsilon_2}{T2}=\frac{p_1\upsilon_1}{T1}\Rightarrow\frac{p_2\upsilon_2}{p_1\upsilon_1} = \frac{T_2}{T_1}\end{aligned}\right\}\Rightarrow\frac{p_2\upsilon_2}{p_1\upsilon_1}=(\frac{p_2}{p_1})^{1-\frac 1 \gamma}\Rightarrow\frac{\upsilon_2}{\upsilon_1}=\frac{(\dfrac{p_2}{p_1})^{1-\frac 1\gamma}}{(\dfrac{p_2}{p_1})^{1}}=(\dfrac{p_2}{p_1})^{-\frac 1\gamma}\Rightarrow\frac{p_2}{p_1}=(\frac{\upsilon_1}{\upsilon_2})^\gamma\]</span></p><p>绝热可逆过程 <span class="math display">\[\left.\begin{aligned}\delta q = \rm du+ \delta w \\\delta q = 0 \\\rm du=c_v\rm dT \\\delta w=p\rm d\upsilon \\\end{aligned}\right\}\left.\begin{aligned}\Rightarrow c_v\rm dT + p\rm d\upsilon=0 \\p\upsilon=\rm RT\end{aligned}\right\}\Rightarrow c_v\rm d(\frac{p\upsilon}{R}) + p\rm d\upsilon=0 \Rightarrow\\\]</span></p><h2 id="公式汇总">公式汇总</h2><table><thead><tr class="header"><th style="text-align: center;">序号</th><th>公式</th><th style="text-align: center;">理想气体</th><th style="text-align: center;">闭口系</th><th style="text-align: center;">可逆过程</th><th style="text-align: center;">绝热过程</th><th style="text-align: center;">等熵过程</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td><span class="math inline">\(c_{\rm v}=\dfrac{\rm du}{\rmdT}\)</span></td><td style="text-align: center;">×</td><td style="text-align: center;">n/a</td><td style="text-align: center;">n/a</td><td style="text-align: center;">n/a</td><td style="text-align: center;">n/a</td></tr><tr class="even"><td style="text-align: center;">2</td><td><span class="math inline">\(c_{\rm p}=\dfrac{\rm dh}{\rmdT}\)</span></td><td style="text-align: center;">×</td><td style="text-align: center;">n/a</td><td style="text-align: center;">n/a</td><td style="text-align: center;">n/a</td><td style="text-align: center;">n/a</td></tr><tr class="odd"><td style="text-align: center;">3</td><td><span class="math inline">\(c_p-c_v=R_{\rm g}\)</span></td><td style="text-align: center;">√</td><td style="text-align: center;">n/a</td><td style="text-align: center;">n/a</td><td style="text-align: center;">n/a</td><td style="text-align: center;">n/a</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进口蝶阀与进口导叶调节</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E8%BF%9B%E5%8F%A3%E8%9D%B6%E9%98%80%E4%B8%8E%E8%BF%9B%E5%8F%A3%E5%AF%BC%E5%8F%B6%E8%B0%83%E8%8A%82/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E8%BF%9B%E5%8F%A3%E8%9D%B6%E9%98%80%E4%B8%8E%E8%BF%9B%E5%8F%A3%E5%AF%BC%E5%8F%B6%E8%B0%83%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<p>风机及压缩机的调节主要调节流量，调节方式包括进口风门调节、出口风门调节、进口导叶调节、液偶调速、变频调速等。本文将谈一谈进口蝶阀（IBV）调节和进口导叶（IGV）调节的原理及特点。</p><h2 id="进口蝶阀">进口蝶阀</h2><p>事实上，进口蝶阀在过去一直是离心式压缩机的标配。它以节流的方式调节进入压缩机首级叶轮的气量，这将增加压缩机进口的管道阻力。为了保证出口压力不降，就需要叶轮提供更高的压头，当然能耗就增加了。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/20230205inlet%20butterfly%20valve.jpg"alt="inlet butterfly valve" /><figcaption aria-hidden="true">inlet butterfly valve</figcaption></figure><p>其实，出口蝶阀调节比进口蝶阀调节更耗能，原因是出口蝶阀调节改变了高压侧管路的特性曲线。因此，在实际应用中这种调节方式是不常见的。</p><h2 id="进口导叶">进口导叶</h2><p>离心式压缩机的基本工作原理是通过叶轮的旋转推动使气体动能增加，接着在弯道和扩压器中部分动能转化为静压能，气体压力也就升高了。当一级叶轮不能满足出口压力要求时，可在串联多个叶轮实现实现多级压缩。</p><p>进口导叶由多个三角叶片构成，气体通过后将发生旋转，被称之为”预旋“。叶轮的任务其实也就是让气体旋转起来，进口导叶带来的”预旋“一定程度上分担了首级叶轮的负担，也就起到了降耗的作用，这是蝶阀无法办到的。另外，凭借结构优势，进口导叶调节风量的精度更高。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/20230205inlet%20guide%20vanes.jpg"alt="inlet guide vanes" /><figcaption aria-hidden="true">inlet guide vanes</figcaption></figure><blockquote><ol type="1"><li><ahref="https://www.teai.com.tw/tech.aspx?ID=0370d6ad-5ebd-4ada-8f96-52465ed24265"> 進口導葉和進口蝶閥有什麼區別</a></li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>工业技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊聊平均数</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E8%81%8A%E8%81%8A%E5%B9%B3%E5%9D%87%E6%95%B0/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E8%81%8A%E8%81%8A%E5%B9%B3%E5%9D%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>大家在小学阶段已接触算术平均数，后来念到初中，高中，大学我们碰到了更多的平均数，那么常用的平均数有哪些，又是怎么定义的，使用上有什么讲究呢？我想，有必要整理总结下，正所谓温故而知新。</p><h2 id="算术平均">算术平均</h2><p>在统计学意义上，算术平均分简单算术平均和加权算术平均两种，它们常用于数值型数据。</p><h3 id="简单算术平均">简单算术平均</h3><p>简单算术平均最常用，这里不再累述，其定义如下：</p><blockquote><p>n个数据相加再除以n</p></blockquote><p><span class="math display">\[\overline{x}=\frac{\sum_{i=1}^{n}x_i}{n}=\frac{x_1+x_2+\cdots+x_i}{n}\]</span></p><h3 id="加权算术平均">加权算术平均</h3><p>加权算术平均考虑了个体对于整体贡献程度/重要程度（权重）的不同。如果大家的权重都一样（众生平等），加权算术平均数就等于简单算术平均数，即简单算术平均是加权算术平均的特例。加权算术平均定义如下：</p><blockquote><p>数值与其权重乘积之和再除以所有权重的之和</p></blockquote><p><span class="math display">\[\overline{x}=\frac{\sum_{i=1}^{n}x_iw_i}{\sum_{i=1}^{n}w_i}=\frac{x_1w_1+x_2w_2+\cdots+x_nw_n}{w_1+w_2+\cdots+w_n}\]</span></p><p>举个常见的例子，某选秀节目歌手得分由现场评委打分、现场观众打分和网络观众打分三个部分综合得到。由于观众很难判断歌手的专业水平，一般仅凭个人好恶打分。如果采用算数平均的方式，外形出众但演唱平平的歌手就很得便宜，可以预见观众分会将整体得分大幅拉高，这样对于唱的好的歌手就不公平。合理的做法是赋予不同评分体系以不同的权重，将加权算术平均数作为最终得分。</p><table><thead><tr class="header"><th style="text-align: center;">打分对象</th><th style="text-align: center;">分数</th><th style="text-align: center;">权重（0~1）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">现场评委</td><td style="text-align: center;">90</td><td style="text-align: center;">0.6</td></tr><tr class="even"><td style="text-align: center;">现场观众</td><td style="text-align: center;">85</td><td style="text-align: center;">0.3</td></tr><tr class="odd"><td style="text-align: center;">网络观众</td><td style="text-align: center;">87</td><td style="text-align: center;">0.1</td></tr></tbody></table><p>时间加权算术平均数计算过程如下： <span class="math display">\[C_{twa}=\frac{C_1W_1+C_2W_2+\cdots+C_nWn}{W_1+W_2+\cdots+W_n}=\frac{90\times0.6+85\times0.3+87\times0.1}{0.6+0.3+0.1}=88.2\]</span> ## 几何平均</p><p>几何平均一般用于品质类数据，反映了整体的平均变化率。<strong>数据不独立，存在前后依赖关系。</strong></p><p>几何平均也分加权和不加权两种。之所以叫几何平均，是因为可以通过几何作图的方法求得两个数的几何平均数（平方根）。几何平均定义如下：</p><blockquote><p>n个数据相乘再开n次方</p></blockquote><p><span class="math display">\[\overline{x}=\sqrt[n]{x_1 x_2 \cdots x_n}\]</span></p><p>为了方便理解，举个例子。工厂设有毛坯，初加工，精加工和装配4个连续作业车间，其产品合格率分别是97%，93%，99%，98.5%，求产品平均合格率。烂菜是不给上桌的，只有合格品才会被送到下一工段继续加工，因此按如下方法计算：<span class="math display">\[\overline{x}=\sqrt[n]{x_1 x_2 \cdotsx_n}=\sqrt[4]{0.97\times0.93\times0.99\times0.985}=0.968\]</span></p><h2 id="对数平均">对数平均</h2><p>对数平均在传热学中应用深刻，笔者接触过的有圆管一维稳态导热计算和换热器对数平均温差计算。</p><blockquote><p>两数的差除以两数自然对数的差</p></blockquote><p><span class="math display">\[\overline{x}=\frac{a-b}{\ln{a}-\ln{b}}\]</span></p><h3 id="圆管一维稳态导热">圆管一维稳态导热</h3><p>我们来研究圆管一维稳态导热的问题，最典型的应用是隔热层厚度的计算。一段长L的保温管壳特征尺寸如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/tubular_conductive_heat_transfer.png"alt="tubular_conductive_heat_transfer" /><figcaptionaria-hidden="true">tubular_conductive_heat_transfer</figcaption></figure><p>根据傅里叶定律，热导率方程推导过程如下： <spanclass="math display">\[Q=-KA\frac{dt}{dr}=-K(2πrL)\frac{dt}{dr} \\\]</span></p><p><span class="math display">\[\Downarrow \\\]</span></p><p><span class="math display">\[Q\frac{1}{r}dr=-K2πLdt \\\]</span></p><p><span class="math display">\[\Downarrow \\\]</span></p><p><span class="math display">\[Q\int_{r_1}^{r_2}\frac{1}{r}dr=-K2πL\int_{t_1}^{t_2}dt \\\]</span></p><p><span class="math display">\[\Downarrow \\\]</span></p><p><span class="math display">\[Q(\ln{r_2}-\ln{r_1})=-K2πL(t_2-t_1) \\\]</span></p><p><span class="math display">\[\Downarrow \\\]</span></p><p><span class="math display">\[Q=-K2πL\frac{t_2-t_1}{\ln{r_2}-\ln{r_1}}=-K(2π\cdot\frac{r_2-r_1}{\ln{r_2}-\ln{r_1}}\cdot L)(\frac{t_2-t_1}{r_2-r_1})\]</span></p><p>从上式可知，圆管一维稳态导热计算中圆管换热面积根据对数平均半径获得。</p><h3 id="对数平均温差">对数平均温差</h3><p>换热器中冷热流体的温差呈指数型变化规律<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[Log Mean Temperature Difference](https://www.omnicalculator.com/physics/lmtd)">[1]</span></a></sup>，因此对数平均温差（LMTD）相对于算术平均温差更精确。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/LMTD.png"alt="LMTD" /><figcaption aria-hidden="true">LMTD</figcaption></figure><p>上图 LMTD 计算结果如下： <span class="math display">\[LMTD=\frac{\Delta T_a-\Delta T_b}{\ln{\Delta T_a}-\ln{\DeltaT_b}}=\frac{40-4}{\ln{40}-\ln{4}}=15.6\]</span></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span><a href="https://www.omnicalculator.com/physics/lmtd">LogMean Temperature Difference</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="http://tw.classf0001.uschoolnet.com/css000000237536/cm4k-1489068565-6972-9931.pdf">在热带遇见平均数</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变化量的表示</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E5%8F%98%E5%8C%96%E9%87%8F%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E5%8F%98%E5%8C%96%E9%87%8F%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p>Δ 表示宏观和通常意义上的变化，即 <span class="math inline">\(\Delta t= t_2-t_1\)</span>。</p><p>δ 是 Δ的小写形式，表示细微的变化，它不区分全微分和偏微分。在热力学中，用于表示过程量的微小变化。</p><hr /><p>d 是全微分的符号。在热力学中，用于表示状态量的微小变化。</p><p>∂是偏微分的符号，即对多元函数中某个变量的偏微分。打个比方：大气压是地点和时间的函数，当需要得到山顶（地点固定）当前时刻气压变化规律时，就要计算大气压对时间的偏微分。</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汽轮机超速保护</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E6%B1%BD%E8%BD%AE%E6%9C%BA%E8%B6%85%E9%80%9F%E4%BF%9D%E6%8A%A4/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E6%B1%BD%E8%BD%AE%E6%9C%BA%E8%B6%85%E9%80%9F%E4%BF%9D%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="超速保护">超速保护</h3><p>汽轮机超速保护分机械超速和电子超速两种。机械超速通过飞锤机构实现，安装在汽机的前轴承箱中。电子超速有三重，依次为OPC超速抑制保护，DEH超速跳车保护，ETS超速跳车保护，详细对比如下表。</p><table><thead><tr class="header"><th>保护类型</th><th>动作转速</th><th>是否跳车</th><th>动作方法</th><th>动作机理</th></tr></thead><tbody><tr class="odd"><td>OPC</td><td>103%</td><td>否</td><td>关闭高中压调门和抽汽逆止门</td><td>OPC电磁阀动作，泄去OPC母管油压</td></tr><tr class="even"><td>DEH</td><td>110%</td><td>是</td><td>关闭所有汽门（主汽门、调门、逆止门）</td><td>AST电磁阀动作，泄去安全油的油压</td></tr><tr class="odd"><td>ETS</td><td>110%</td><td>是</td><td>关闭所有汽门（主汽门、调门、逆止门）</td><td>AST电磁阀动作，泄去安全油的油压</td></tr><tr class="even"><td>机械超速</td><td>111%～112%</td><td>是</td><td>关闭所有汽门（主汽门、调门、逆止门）</td><td>拉动危机遮断装置连杆，泄去安全油油压</td></tr></tbody></table><h3 id="测速探头">测速探头</h3><p>常用测速传感器按测量机理分磁阻式和电涡流式两种。磁阻式传感器是无源型，不需要供电，结构简单，但是测量精度、抗干扰能力和输出信号标准度都比电涡流式差。对于小型机组，转速传感器大都采用磁阻式，3支进DEH，3支进TSI，1支用于就地转速显示。电涡流传感器在小型机组中常用于健相，轴位移，轴振，轴胀和缸胀等参数的测量。</p><h3 id="常见缩写词">常见缩写词</h3><ul><li>DEH DIGITAL ELECTRO HYDRAULIC</li><li>TSI TURBINE SUPERVISORY INSTRUMENTATION</li><li>ETS EMERGENCY TRIP SYSTEM</li><li>OPC OVERSPEED PROTECTION CONTROL</li><li>AST AUTO STOP TRIP</li><li>ASP AUTO STOP PRESSURE</li><li>GV GOVERNING VALVE</li><li>SV STOP VALVE</li><li>TV THROTTLE VALVE</li><li>IV INTERCEPTOR VALVE</li><li>RSV REHEAT STOP VALVE</li><li>ATC AUTOMATION TURBINE CONTROL</li><li>CPC CURRENT TO PRESSURE CONVERTER</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>工业技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node无法执行使用import关键字的源文件</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/JavaScript/Node%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8C%E4%BD%BF%E7%94%A8import%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/JavaScript/Node%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8C%E4%BD%BF%E7%94%A8import%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>有时为了测试代码，我们会用VSCode在Node环境下调试js文件。当代码中使用了<strong>import</strong>关键字，运行会报如下错误。</p><blockquote><p>(node:10048) Warning: To load an ES module, set "type": "module" inthe package.json or use the .mjs extension.</p><p>(Use <code>node --trace-warnings ...</code> to show where the warningwas created)</p><p>c:.js:1</p><p>import math from "./js/math"</p></blockquote><p>上述大概意思是：为了能够加载ES6模块，应在<strong>package.json</strong>配置文件中增加<strong>type</strong>字段，并将值设为<strong>module</strong>或将后缀名改为<strong>mjs</strong>。</p><span id="more"></span><h2 id="解决方法">解决方法</h2><p>经测试，第2种方法需将所有相关文件后缀名都改为<strong>mjs</strong>，包括直接、间接依赖的包文件。如此处理工作量太大，更麻烦的是改变了包内文件结构，可能带来潜在问题。故推荐在<strong>package.json</strong>文件中增加并修改<strong>type</strong>字段。该文件不存在则用<code>npm init -y</code>命令生成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;repo&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;main.js&quot;</span>,<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;keywords&quot;</span>: [],<br>  <span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span>,<br>  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;module&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原因分析">原因分析</h2><p>对于模块化的实现，CommonJS使用<code>module.exports</code>导出及<code>require()</code>加载；而ES6分别使用<code>export</code>和<code>import</code>关键字导出和导入。当源码中出现<code>export</code>或<code>import</code>关键字，Node就认为使用了ES6模块；接着再去检查后缀名是否为<strong>mjs</strong>或者<strong>type</strong>字段的值是否为<strong>module</strong>；否则就报错。</p><h3 id="文件后缀">文件后缀</h3><p>针对不同的后缀名，Node处理原则如下：</p><ul><li><strong>.mjs</strong>文件总是以ES6模块加载</li><li><strong>.cjs</strong>文件总是以CommonJS模块加载</li><li><strong>.js</strong>文件的加载取决于<strong>package.json</strong>里面<strong>type</strong>字段值</li></ul><h3 id="type字段">type字段</h3><p>该字段决定了.js文件和无后缀名文件的加载方式。值为<strong>commonjs</strong>时，以commonjs模式加载；值为<strong>module</strong>时，以ES6模式加载；字段不存在时，默认以commonjs模式加载。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS入门</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/JavaScript/js%E5%85%A5%E9%97%A8/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/JavaScript/js%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>JavaScript是一种类C的脚本语言，目前在Web前端、后端都有非常广泛的应用。js其实与Java并无关联，当年为了沾上Java的热度就起名叫JavaScript。</p><p>对于大多数程序而言，程序=数据+算法，因此学习一门新的编程语言应从这两个方面学起，后续在逐渐深入该语言的特有的内容。</p><h2 id="数据">数据</h2><h3 id="基本数据类型">基本数据类型</h3><ol type="1"><li><p>number</p><p>整型、浮点型、非数字<code>NaN</code>、无穷大<code>Infinity</code>4种数值类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// Infinity</span><br>num = <span class="hljs-string">&quot;hello&quot;</span> - <span class="hljs-number">1</span>; <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>浮点型占用整型2倍的内存空间，因此JavaScript会不失时机地将浮点型数值转换为整型数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">2.0</span> <span class="hljs-comment">// 自动转换为2</span><br></code></pre></td></tr></table></figure><blockquote><p>任何语言任何时候都不要与浮点型数值作比较</p></blockquote></li><li><p>string</p><p>用字符串模板代替字符串拼接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I am <span class="hljs-subst">$&#123;age&#125;</span> years old`</span>);<br></code></pre></td></tr></table></figure></li><li><p>常见类型与bool类型转换关系表</p><table><thead><tr class="header"><th style="text-align: center;">数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">string</td><td>任何非空字符串</td><td>“”（空字符串)</td></tr><tr class="even"><td style="text-align: center;">number</td><td>任何非零数值(包括无穷大)</td><td>0和NaN</td></tr><tr class="odd"><td style="text-align: center;">object</td><td>任何对象</td><td>null</td></tr><tr class="even"><td style="text-align: center;">undefined</td><td>n/a</td><td>undefined</td></tr></tbody></table></li><li><p>undefined</p><p>所有仅被声明而未被赋值的变量，JavaScript会分配一个默认值<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> slogan<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slogan); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li><li><p>null</p><p>如果一个变量将来用于存储对象，通常将其初始化为<code>null</code>。</p></li><li><p>object</p></li><li><p>array</p><ul><li>JavaScript属于弱类型编程语言，因此array不会对数据类型进行检查，即同一数组中可以不同类型的数据；</li><li>出于性能考虑，不建议数组头部进行操作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>];<br>fruits.<span class="hljs-title function_">push</span>(<span class="hljs-number">2020</span>); <span class="hljs-comment">// apple, banana. 2020</span><br>fruits.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 2020</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="常量与变量">常量与变量</h3><p>变量命名必须以字母、下划线(_)或美元符号($)打头；类名使用大驼峰命名法；常量使用大写+下划线命名法；其余使用小驼峰命名法。</p><p>不建议改变变量数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> slogan = <span class="hljs-string">&quot;hello javascript&quot;</span>;<br>slogan = <span class="hljs-string">&quot;hello world&quot;</span>; <span class="hljs-comment">// 允许</span><br>slogan = <span class="hljs-number">2020</span>; <span class="hljs-comment">// 允许但不推荐</span><br></code></pre></td></tr></table></figure><p>除非为兼容旧版本，否则一律使用<code>let</code>关键字声明变量。<code>let</code>不支持变量提升，即变量在被使用之前必须先被声明；其次<code>let</code>不允许重复声明变量；以上特点可避免<del>var</del>关键字可能带来的混乱。</p><p>常量必须初始化，即声明时就赋初值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> slogan;<br>slogan = <span class="hljs-string">&quot;hello javascript&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.1415926</span>;<br></code></pre></td></tr></table></figure><h3 id="动态特性">动态特性</h3><p>JavaScript属于动态型编程语言，允许同一变量在运行周期里存储不同类型的数据，<strong>注意：这不是类型推断。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-string">&quot;hello js&quot;</span>;<br><span class="hljs-keyword">typeof</span> x <span class="hljs-comment">// =&gt; &#x27;string&#x27;</span><br>slogan = <span class="hljs-number">2021</span>;<br><span class="hljs-keyword">typeof</span> x <span class="hljs-comment">// =&gt; &#x27;number&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="算法">算法</h2><h3 id="语句">语句</h3><p>单行语句以分号结尾；花括号包起来的几行语句即多行语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运算符">运算符</h3><ol type="1"><li>递增与递减</li></ol><p>前置与后置递增、递减运算结果都相同，区别在于赋值运算次序不同。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> price1 = <span class="hljs-number">100</span>, price2 = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">let</span> newPrice1 = price1++;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newPrice1); <span class="hljs-comment">// 100</span><br><span class="hljs-keyword">let</span> newPrice2 = ++price2;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newPrice2); <span class="hljs-comment">// 101</span><br></code></pre></td></tr></table></figure></p><ol start="2" type="1"><li>比较</li></ol><ul><li><p>数字与字符串比较时，JavaScript会先将字符串隐式转换为数字后再进行比较。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;20&quot;</span> &gt; <span class="hljs-number">10</span>; <span class="hljs-comment">// Number(&quot;20&quot;) &gt; 10 → 20 &gt; 10  → true</span><br><span class="hljs-string">&quot;apple&quot;</span> &gt; <span class="hljs-number">10</span>; <span class="hljs-comment">// Number(&quot;apple&quot;) &gt; 10 → NaN &gt; 10 → false</span><br></code></pre></td></tr></table></figure></li><li><p>抽象相等<code>==</code></p><p>比较对象类型一致时，随即比较值是否相等；不一致时，尝试隐式类型转换后再比较值是否相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">10</span> == <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-comment">// 10 == Number(&quot;10&quot;) → 10 == 10 → true</span><br></code></pre></td></tr></table></figure></li><li><p>严格相等<code>===</code></p><p>严格以上的相等（类型与值都相等），本质是<strong>严格相等不会尝试类型转换</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">10</span> === <span class="hljs-string">&quot;10&quot;</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>在不清楚具体应用场合的前提下，尽量使用严格相等<code>===</code>或者严格不相等<code>!==</code>。</p></blockquote><h3 id="控制结构">控制结构</h3><ol type="1"><li>多条件判断过程</li></ol><p>对于多条件判断语句（逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>），当根据条件1就可以得到整体判断结果，后续条件将不再执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> dog = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> || dog.<span class="hljs-property">age</span> &gt; <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;old dog&quot;</span>);<br>&#125; <span class="hljs-comment">// 正常输出：old dog，不会报错</span><br><span class="hljs-keyword">if</span> (dog.<span class="hljs-property">age</span> &gt; <span class="hljs-number">5</span> || <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> ) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;old dog&quot;</span>);<br>&#125; <span class="hljs-comment">// 报错：Cannot read property &#x27;age&#x27; of null</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>分支语句break关键字</li></ol><p>如果缺少<code>break</code>关键字，条件成立部分语句及后续无<code>break</code>关键字语句都将会被执行；此时<code>case</code>关键字起到的是<code>goto</code>的作用，这与<code>if...else if...</code>语句功能不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> flag = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">switch</span> (flag) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br>    &#125;<br>    <span class="hljs-attr">default</span>: &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125; <span class="hljs-comment">// 输出2、3</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>遍历</li></ol><p><code>for...in</code>语句用于遍历数组的元素或者对象的属性。不同于C#语言，JavaScript语言中可对集合进行读写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> stuff = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;wanger&quot;</span>, <span class="hljs-attr">age</span>:<span class="hljs-number">30</span>, <span class="hljs-attr">married</span>:<span class="hljs-literal">false</span>&#125;; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">in</span> stuff) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;x&#125;</span>:<span class="hljs-subst">$&#123;stuff[x]&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其它">其它</h2><h3 id="注释">注释</h3><p>虽然JavaScript支持行注释和块注释，但是编辑器都是以行注释的型式生成注释。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// function add(x, y)&#123;</span><br><span class="hljs-comment">//     return x + y;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure></p><h2 id="es6">ES6</h2><h3 id="填坑">填坑</h3><ol type="1"><li>大胆抛弃<code>var</code>关键字，请用<code>let</code>和<code>const</code>代替</li><li><code>import</code>模块时不建议省略后缀名，主要怕引起诸如<code>math.js</code>和<code>math\index.js</code>的歧义。</li></ol><h3 id="简化">简化</h3><ol type="1"><li><p>简化对象方法声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> coder = &#123;<br>    <span class="hljs-comment">// sayHello: function()&#123;</span><br>    <span class="hljs-comment">//     console.log(&quot;hello js&quot;);</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// 简化写法</span><br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello js&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用箭头函数简化方法定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">numbers.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>)&#123;<span class="hljs-keyword">return</span> a - b&#125;);<br><span class="hljs-comment">// 简化写法</span><br>numbers.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a - b);<br><br><span class="hljs-comment">// 注意：用箭头函数定义实例方法时，this一般不指向实例</span><br><span class="hljs-keyword">const</span> tommy = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;tommy&#x27;</span>,<br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`this is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;,<br><br>    <span class="hljs-attr">sayBye</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`this is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;<br><br>&#125;<br><br>tommy.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// this is tommy</span><br>tommy.<span class="hljs-title function_">sayBye</span>(); <span class="hljs-comment">// this is undefined </span><br></code></pre></td></tr></table></figure></li></ol><h3 id="新意思">新意思</h3><ol type="1"><li><p>高阶函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> diameters = [<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br>diameters = diameters.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d &gt; <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(diameters); <span class="hljs-comment">// [ 1, 2, 3 ]</span><br>areas = diameters.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-number">0.785</span> * d ** <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(areas); <span class="hljs-comment">// [ 0.785, 3.14, 7.065 ]</span><br><span class="hljs-keyword">var</span> totalAreas = areas.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">x,y</span>) =&gt;</span> x + y);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(totalAreas); <span class="hljs-comment">// 10.99 = 0.785+ 3.14 + 7.065</span><br></code></pre></td></tr></table></figure></li><li><p>解构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SteamPro</span>(<span class="hljs-params">press, temp</span>) &#123;<br>    <span class="hljs-keyword">var</span> density, entropy, enthalpy, viscosity;<br>    <span class="hljs-comment">// balabala</span><br>    <span class="hljs-keyword">return</span> &#123; density, entropy, enthalpy, viscosity &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> &#123; density, entropy, enthalpy, viscosity &#125; = <span class="hljs-title class_">SteamPro</span>(press, temp);<br></code></pre></td></tr></table></figure></li><li><p>展开运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 支持数组和对象</span><br><span class="hljs-keyword">const</span> numbers1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> numbers2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">const</span> all = [...numbers1, ...numbers2];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(all); <span class="hljs-comment">// [ 1, 2, 3, 4, 5, 6 ]</span><br></code></pre></td></tr></table></figure></li><li><p>类的声明和继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br><br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hi, i am <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, course</span>)&#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">course</span> = course;<br>    &#125;<br><br>    <span class="hljs-title function_">slogan</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> isn&#x27;t a <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.course&#125;</span> teacher, but a farmer!`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> wanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;wanger&quot;</span>, <span class="hljs-string">&quot;math&quot;</span>);<br>wanger.<span class="hljs-title function_">slogan</span>();<br><br></code></pre></td></tr></table></figure></li><li><p>模块化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; add, square &#125;;<br><br><span class="hljs-comment">// 调用模块</span><br><span class="hljs-keyword">import</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math); <span class="hljs-comment">// &#123; add: [Function: add], square: [Function: square] &#125;</span><br>math.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中的异步用法</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/JavaScript/js%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%94%A8%E6%B3%95/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/JavaScript/js%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="阻塞与非阻塞">阻塞与非阻塞</h2><p>“阻塞”一词的字面意思是被迫停滞，无法前进，很容易联想到日常生活中的堵车。大家都碰到过程序“假死”，光标一直转圈圈，键鼠也不听使唤。这种现象背后的原因是UI线程被阻塞，此刻后台大多在进行下载文件、查询数据库等I/O密集的操作。</p><figure><imgsrc="https://i.pinimg.com/originals/e0/9c/bc/e09cbc00e6992f3c31c78200b3a05df1.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>阻塞与非阻塞的区别在于应用层在等待请求结果期间的状态。</strong>阻塞模式下应用层发出请求后一直死等结果，直到结果全部返回，这期间啥也不干。举个例子：网格长在小区群里发了条消息，要求各家各户上报假期出行情况，随后她就去买菜做饭了，这是非阻塞。如果她一直傻乎乎地捧着手机，等待所有家庭的答复，外面有人敲门也不管，这是阻塞。</p><p>代码默认就是按阻塞模式执行的，因为语句总是一句接一句往下走。只不过大多数语句执行的很快，看不出阻塞来。只有在执行耗时语句时，才体会到阻塞的存在。MFC程序为防止主线程被阻塞，进而导致程序“假死”，通常会新建工作线程来执行耗时操作。JS本身是单线程的，其它线程只能由宿主（浏览器、NodeJS等）创建，这些线程不属于JS。</p><h2 id="同步与异步">同步与异步</h2><p>同步、异步与阻塞、非阻塞是相互独立的。<strong>同步与异步的区别在于是否主动确定结果的状态。</strong>当同步请求发出后，应用层会主动向内核层发起问询。倘若结果还没出来，同时处于阻塞模式下，应用层就只会不断发起问询；若当前处于非阻塞模式，应用层暂时去干别的，过会儿再来问询。异步请求不会主动问询，结果出来后由“周到的”内核层通知给应用层，这种模式当然也分阻塞和非阻塞。举个例子：发工资那天，不停地刷新银行APP，查看工资是否到账等同于同步操作；安心等待工资到账的短信息等同于异步操作。</p><h2 id="异步非阻塞">异步非阻塞</h2><p>综上所述，一个高效、理想的模型应该是异步非阻塞模型。应用层发完请求后就去干别的事情，避免了无效的的等待；结果出来后由内核层去通知应用层，避免了盲目的问询。异步非阻塞模型离不开多线程，但上文提到JS 是单线程的，因此只能由宿主创建诸如下载、渲染等线程。JS主线程只负责盯着自己的任务队列，不停地将队列中的任务拿去执行。耗时线程操作执行完毕后发出消息，宿主收到消息后将对应的回调函数放到主线程的任务队列中，这样就实现了异步。</p><h2 id="promise的由来">Promise的由来</h2><p>上节说到，通过回调函数可以实现异步，但该方案存在<strong>回调地狱</strong>的麻烦。比如有这样的需求：下载ZIP包，破解 ZIP包，解压ZIP包，发送解压后的文件，一环扣一环。最初代码如下，看了叫人头皮发麻，比套娃还能套。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">downloadZIP</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<br>  <span class="hljs-title class_">CrackZIP</span>(file, <span class="hljs-function">(<span class="hljs-params">file, password</span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">UnZIP</span>(file, password, <span class="hljs-function">(<span class="hljs-params">neFile</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">SendFile</span>(neFile);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>于是乎<code>Promise</code>诞生了，使用<code>Promise</code>将上述代码改成链式调用，顺眼了很多。有一点要注意：在可能的异常发生和调用<code>Reslove</code>、<code>Reject</code>函数之前，<code>Promise</code>会一直处于<code>Pending</code>状态，因此<code>then</code>、<code>catch</code>方法也不会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">downloadZIP</span>()<br>.<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> <span class="hljs-title class_">CrackZIP</span>(file))<br>.<span class="hljs-title function_">then</span>( <span class="hljs-function">(<span class="hljs-params">file, password </span>) =&gt;</span> <span class="hljs-title class_">UnZIP</span>(file, password) )<br>.<span class="hljs-title function_">then</span>( <span class="hljs-function"><span class="hljs-params">newFile</span> =&gt;</span> <span class="hljs-title class_">SendFile</span>(newFile));<br></code></pre></td></tr></table></figure><h2 id="async-与-await">async 与 await</h2><p><code>async</code>与 <code>await</code> 是 ES6中引入的语法糖，目的是简化<code>Promise</code>的使用。引用阮一峰老师说法：</p><blockquote><p>async 函数完全可以看作多个异步操作包装成的一个 Promise 对象，而 await命令就是内部 then 方法的语法糖。</p></blockquote><p>示例用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> fetch <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;node-fetch&quot;</span>;<br><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.github.com/users/github&quot;</span>);<br><span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json);<br></code></pre></td></tr></table></figure><p>任何方法用<code>async</code>修饰后方法都返回<code>Promise</code>对象，这与该方法是否用<code>await</code>调用无关。它两经常一起出现，但却是相互独立的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原始代码</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>()); <span class="hljs-comment">// 打印Promise &#123; 1 &#125;</span><br></code></pre></td></tr></table></figure><p><code>await</code>相当于执行了<code>Promise</code>对象的<code>then</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">foo</span>());  <span class="hljs-comment">// 打印1</span><br></code></pre></td></tr></table></figure><p>甚至可以将混用 Promise、async、await，验证代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 混用示例1</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> p1);   <span class="hljs-comment">// 打印1</span><br><br><span class="hljs-comment">// 混用示例2</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value));    <span class="hljs-comment">// 打印1</span><br></code></pre></td></tr></table></figure><h3 id="注意事项">注意事项</h3><ol type="1"><li><p>await语句之间是阻塞的。本节开头的示例代码中，在<code>fetch</code>方法返回后才会就继续执行<code>json()</code>方法。这也符合逻辑，数据还没拿回来怎么加工？如果想让多个<code>Promise</code>并行运行，应使用<code>Promise.all</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.github.com/users/github&quot;</span>);<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.google.com/users/github&quot;</span>);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2]);<br></code></pre></td></tr></table></figure></li><li><p><code>foreach</code>、<code>map</code>中使用<code>await</code>会立即返回，<code>await</code>只适用于传统<code>for</code>循环或者直接使用<code>for await</code>语句。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XAML入门</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/FrontEnd/XAML%E5%85%A5%E9%97%A8/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/FrontEnd/XAML%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>本文的素材来源于刘铁猛老师的《深入浅出WPF》一书及网上收集的资料。</p><p>XMAL(E<strong>x</strong>tensible <strong>A</strong>pplication<strong>M</strong>arkup <strong>L</strong>anguage)全称可扩展程序标记语言，是微软开发的一种基于 XML、声明式的界面描述语言。XAML 与C#、VB.NET 同属 .NET平台语言，也会被编译成 IL 代码。</p><p>以上所述XAML是一种声明式语言，即只要通过标签的方式声明某个元素，编译器就会为该标签创建一个与之对应的CLR对象。比如以下XAML 语句创建了一个按钮并指定了按钮内容和 click 事件处理函数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;button1_Click&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应C#代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> button1 = <span class="hljs-keyword">new</span> Button();<br>button1.Text = <span class="hljs-string">&quot;button1&quot;</span>;<br>button1.Click += <span class="hljs-keyword">new</span> EventHandler(<span class="hljs-keyword">this</span>.button1_Click);<br></code></pre></td></tr></table></figure><h2 id="命名空间">命名空间</h2><p>为了避免命名冲突，XAML 沿用了 XML中命名空间的概念。命名空间只能在根元素中声明，语法为<code>xmlns:空间名称="xxx"</code>，默认命名空间的名称可以省略。双引号中的字符串有两种形式：</p><ol type="1"><li><p>某程序集中的命名空间</p><p>xmlns:空间名称="clr-namesapce:程序集中的空间名;assembly=程序集文件名"。比如要引用mscorlib类库中的System命名空间，写法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">xmlns:sys = &quot;clr-namespace:System;assembly=mscorlib&quot;<br></code></pre></td></tr></table></figure></li><li><p>URL</p><p>每个 WPF 程序都依赖一些必备的命名空间，逐个引入既麻烦又臃肿。XAML使用 URL 地址代表一堆同类型命名空间，形式简洁明了，常见分类如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;<br>xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;<br>xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; <br>xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; <br></code></pre></td></tr></table></figure></li></ol><p>x命名空间与解析 XAML 语言相关，其下属的几个特性很常用：</p><ul><li><p>x:Name</p><p>指定标签名称，方便后续引用。</p></li><li><p>x:Class</p><p>此特性只能用于根元素，告诉编译器将当前 XAML的编译结果与后台代码的指定类合并，前提是该类必须声明为同名的<code>partial</code>类。新建窗口、页面及控件时，VS会自动生成前台XMAL 代码和相应的后台代码，但后台代码不是必须的。</p></li><li><p>x:key</p><p>WPF中的资源是以“key-value”字典形式存储的，通过key检索具体资源。</p></li><li><p>x:static</p><p>在 XAML中访问类的静态成员，常用于软件的多语言显示。习惯做法是将字符串保存到资源类的静态属性中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span> <span class="hljs-attr">Text</span>=<span class="hljs-string">&quot;&#123;x:Static Local:I8n.ENG_AGE&#125;&quot;</span></span><br></code></pre></td></tr></table></figure></li></ul><h2 id="元素">元素</h2><p>元素通常由一个开始标签和一个结束标签组成。标签体包含了其它元素的元素称为非空元素，不包含其它元素的元素称为空元素。建议统一采用非空元素的形式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--非空标签--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span> <br>   <span class="hljs-comment">&lt;!--空标签--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="元素特性">元素特性</h3><p>为了区分对象的属性（Property），这里将 Attribute翻译成<strong>特性</strong>，特性的功能是为元素附加额外的信息。特性赋值有两种方式：</p><ul><li>使用字符串简单赋值</li><li>使用特性元素复杂赋值</li></ul><p>元素的特性部分对应对象的属性及各种事件，但不是一一对应。特性的简单赋值通过<code>Attribute=“Value”</code>语法，示例如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span> <span class="hljs-attr">Text</span>=<span class="hljs-string">&quot;用户名&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="特性元素">特性元素</h3><p>特征元素即某元素为另一个元素的某个特征，即以元素的方式展示另一个元素的特征，这有区别于上述在标签中内嵌特性。如果特征的值可以用字符串表达，就不要使用特征元素的表达方式。以下示例代码用特征元素的方式定义了窗口的资源。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sys:String</span> <span class="hljs-attr">x:Key</span>=<span class="hljs-string">&quot;motto&quot;</span>&gt;</span>BBQ BOYS<span class="hljs-tag">&lt;/<span class="hljs-name">sys:String</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window.Resources</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="标记扩展">标记扩展</h3><p>标记扩展主要扩展了特征的取值范围，简单赋值不再单单是个字符串，也可以是静态资源、对象等等。扩展语法是：<code>Attribute=“&#123;value&#125;”</code>，用大括号将值括起来。<strong>标记扩展支持嵌套使用</strong>。</p><p>标记扩展是一系列派生类，其基类为抽象类MarkupExtension。所有扩展可分为两大类：XAML 标记扩展和 WPF标记扩展（绑定），先罗列下 XAML 的标记扩展，下一章节介绍绑定相关。</p><ul><li><p>x:Null</p><p>显示地设置特性值为 NULL，常用于放弃相关特性的继承。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Style</span> <span class="hljs-attr">TargetType</span>=<span class="hljs-string">&quot;Button&quot;</span>&gt;</span><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Setter</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Setter.Property</span>&gt;</span>Button.Background<span class="hljs-tag">&lt;/<span class="hljs-name">Setter.Property</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Setter.Value</span>&gt;</span>SeaGreen<span class="hljs-tag">&lt;/<span class="hljs-name">Setter.Value</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Setter</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">Style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window.Resources</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Style</span>=<span class="hljs-string">&quot;&#123;x:Null&#125;&quot;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>x:Static 静态属性扩展</p><p>在 XAML 中访问静态成员</p></li><li><p>x:Type 对象类型扩展</p><p>在 XAML 中标记数据类型</p></li><li><p>x:Array 静态数组扩展</p><p>在 XAML 中创建静态数组</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">x:Array</span> <span class="hljs-attr">x:Key</span>=<span class="hljs-string">&quot;boys&quot;</span> <span class="hljs-attr">Type</span>=<span class="hljs-string">&quot;&#123;x:Type sys:String&#125;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sys:String</span>&gt;</span>猴子<span class="hljs-tag">&lt;/<span class="hljs-name">sys:String</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sys:String</span>&gt;</span>肉肉<span class="hljs-tag">&lt;/<span class="hljs-name">sys:String</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sys:String</span>&gt;</span>二哈<span class="hljs-tag">&lt;/<span class="hljs-name">sys:String</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">x:Array</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window.Resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ListBox</span> <span class="hljs-attr">ItemsSource</span>=<span class="hljs-string">&quot;&#123;StaticResource boys&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ListBox</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="绑定">绑定</h2><ul><li><p>Binding</p><p>数据绑定扩展，将自身的某个特性与任意数据绑定，MVVM中频繁用到此标记扩展。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">  ```<br><br>- TemplateBinding<br><br>  为了方便复用，可以将控件的样式设置集中到一个控件模板里，然后通过模板绑定的方式应用到具体控件。<br><br>  ```xml<br>  <span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ControlTemplate</span> <span class="hljs-attr">x:Key</span>=<span class="hljs-string">&quot;RedButton&quot;</span> <span class="hljs-attr">TargetType</span>=<span class="hljs-string">&quot;Button&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">ContentControl</span> <span class="hljs-attr">Content</span>=<span class="hljs-string">&quot;Click&quot;</span> <span class="hljs-attr">Foreground</span>=<span class="hljs-string">&quot;Red&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ContentControl</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">ControlTemplate</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Template</span>=<span class="hljs-string">&quot;&#123;StaticResource RedButton&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="资源">资源</h2><p>通常所谓的资源（二进制资源）指程序代码用到的一些附件内容，比如图标、版权字符串等。为了防止遗失或被破坏，可将资源编译进程序的主体，与程序主体浑然一体。WPF另外引入了对象资源的概念，每个元素都可携带能被共享的对象资源，比如样式、控件模板、动画组件及画刷等。对象资源在元素的Resources 特性元素中定义，以“键—值”对的形式存储。</p><p>在检索资源时，先查找当前元素的 Resources特性，如果没有找到再沿着逻辑树去父元素查找，最终直到Application.Resources元素。如果搜索完所有路径都没发现，就会抛出异常。</p><p>根据使用资源的方式不同，分静态绑定资源和动态绑定资源。绑定资源通过前面提到的标记扩展语法实现。</p><h3 id="静态绑定">静态绑定</h3><p>当程序初始化时一次性地使用某资源，后续不再关注该资源可能的变化时，使用静态绑定扩展标记。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sys:String</span> <span class="hljs-attr">x:Key</span>=<span class="hljs-string">&quot;motto&quot;</span>&gt;</span>Good Good Study,Day Day Up<span class="hljs-tag">&lt;/<span class="hljs-name">sys:String</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window.Resources</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span> <span class="hljs-attr">Text</span>=<span class="hljs-string">&quot;&#123;StaticResource motto&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="动态绑定">动态绑定</h3><p>资源在程序运行后可能发生变化，且被绑定的特性需同步响应变化时，使用动态绑定扩展标记。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sys:String</span> <span class="hljs-attr">x:Key</span>=<span class="hljs-string">&quot;motto&quot;</span>&gt;</span>Good Good Study,Day Day Up<span class="hljs-tag">&lt;/<span class="hljs-name">sys:String</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window.Resources</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span> <span class="hljs-attr">Text</span>=<span class="hljs-string">&quot;&#123;DynamicResource motto&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br><br>// 后台改变资源<br>private void Button_Click(object sender, RoutedEventArgs e)<br>&#123;<br>    Resources[&quot;motto&quot;] = &quot;so boring&quot;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="资源文件">资源文件</h3><p>为了实现工程化及便于复用，可将资源定义在一个单独的资源字典文件中。该文件类似于前端常见的CSS 样式文件，后缀名为 .xaml。大家熟悉的 MaterialDesign界面库就是以资源文件的方式提供的，其引入方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span> <span class="hljs-attr">Source</span>=<span class="hljs-string">&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Style</span>=<span class="hljs-string">&quot;&#123;DynamicResource MaterialDesignFlatMidBgButton&#125;&quot;</span>&gt;</span>Start<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue学习笔记</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/FrontEnd/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/FrontEnd/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><h3 id="简介">简介</h3><p><a href="https://cn.vuejs.org">官网</a>对vue的定义如下：</p><blockquote><p>Vue (读音 /vjuː/，类似于 view)是一套用于<strong>构建用户界面</strong>的<strong>渐进式框架</strong>。</p></blockquote><p>关键词：</p><ul><li><p>构建用户界面</p><p>vue扮演了MVVM编程范式中的ViewModel角色</p></li><li><p>渐进式</p><p>按需逐步引入vue提供的功能，不必夯不啷当全部引入。</p></li></ul><span id="more"></span><h3 id="特点">特点</h3><ol type="1"><li><p>组件化</p><p>组件化是个很老的概念，vue组件定义在一个单独的<strong>.vue</strong>文件中。</p></li><li><p>声明式</p><p>只需明确需求而不必具体实现，比如遍历一个数组，<code>v-for</code>指令用起来就很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;li v-for=&quot;student in students&quot;&gt;<br>  student.name<br>&lt;/li&gt;<br></code></pre></td></tr></table></figure><p>对于大多数编程语言，代码可能如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;std::string&gt; students = &#123; <span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;丽丽&quot;</span>, <span class="hljs-string">&quot;大黄&quot;</span> &#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; students.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br>std::cout &lt;&lt; students[i] &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>虚拟DOM</p><p>真实DOM结构复杂，频繁操作性能消耗大，直观感受是网页卡。于是vue发明了虚拟DOM，变化后生成新的虚拟DOM，再用<strong>diff</strong>算法对比新旧虚拟DOM，最后将变化的部分一次性放到真实DOM上。</p></li></ol><h3 id="术语">术语</h3><ol type="1"><li><p>property</p><p>对象属性，比如以下代码中的name属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wanger&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>attribute</p><p>html元素属性，比如以下代码中的src属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;www.google.com&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>函数（function）</p><p>实现特定功能的代码段</p></li><li><p>方法（method）</p><p>对象或类中的的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>    <span class="hljs-attr">eat</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;...&#125;,<br>    <span class="hljs-comment">// ES6中方法简写</span><br>    <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置对象</p><p>用于传递参数的对象，一般都是匿名对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello vue&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>数据对象</p><p>用于存储数据的对象，比如以下代码中的data对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerry&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;5&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>表达式</p><p>变量和操作符的结合，一般至少返回一个值，比如：<code>1+1</code></p></li><li><p>语句</p><p>一种操作或命令，会对周围产生影响，比如：<code>year = 2021</code></p></li><li><p>元素</p><p>HTMl元素通常由一对开始标签和结束标签组成，中间部分称为标签体。标签体为空的标签称为空标签，除script标签除外，空标签可以简写成自闭标签的型式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li></li></ol><h2 id="基础">基础</h2><h3 id="入门示例">入门示例</h3><p>新建html文档，使用script标签远程引入vue.js，这里要知道：</p><blockquote><p>一旦成功引入，将创建一个全局Vue函数，实际也是对象构造方法。</p></blockquote><p>以下是一段hello world示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello word&quot;</span>,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="挂载">挂载</h4><p>配置对象的el属性指定了vue实例将挂载的节点（一般为容器元素），也可通过原型方法<code>$mount</code>挂载，并且更加灵活。一旦某节点被挂载了vue实例，当前节点及其子节点将由vue接管。当数据对象发生变化时，相关节点将被重新渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// el: &quot;#app&quot;,</span></span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  vm.$mount(<span class="hljs-string">&quot;#app&quot;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>本例使用了id选择器定位目标节点，也可以使用类选择器，或者直接调用<code>Document.getElementById()</code>函数获取。</p><h4 id="数据">数据</h4><p>data属性值也是一个对象，称之为数据对象，里面定义了模板中会用到的数据。数据对象的所有属性会自动附加到vue实例上。为了避免全局作用域污染，组件中使用函数返回数据对象。</p><h3 id="版本区别">版本区别</h3><p>形式上的区别：生产版去除了注释、警告信息并采用gzip压缩，因此体积更小；开发版文件名为<strong>vue.js</strong>，生产版文件名为<strong>vue.min.js</strong>。最重要区别在于：开发版错误提示更加详细、友好。上节例子中把<code>new</code>关键字拿掉后，错误提示如下：</p><figure><imgsrc="https://gitee.com/romango/picbed/raw/master/picgo/image-20210827232259448.png"alt="image-20210827232259448" /><figcaption aria-hidden="true">image-20210827232259448</figcaption></figure><h3 id="模板语法">模板语法</h3><p>通过vue提供的专有模板语法，可以将html元素相关内容与vue实例建立关联。</p><h4 id="标签体插值">标签体插值</h4><p>插值只用在标签体中，采用双大括号的<strong>mtstache</strong>语法。双大括号内可以插入js表达式，并且可以引用数据对象的属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>my name is &#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; number &#125;&#125; is &#123;&#123; 0 === number%2 ? &#x27;even&#x27; : &#x27;odd&#x27; &#125;&#125; number<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="属性绑定">属性绑定</h4><ol type="1"><li>v-bind</li></ol><p>v-bind指令用于绑定元素属性，由于该指令经常用到，可以省略指令名称。同标签体插值一样，属性中也可以插入js表达式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: flex;flex-flow: column;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://3roman.github.io&quot;</span>&gt;</span>我的主页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;site&quot;</span>&gt;</span>我的主页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;site&quot;</span>&gt;</span>我的主页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">site</span>: <span class="hljs-string">&#x27;https://3roman.github.io&#x27;</span></span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>v-model</li></ol><p>数据绑定一般是单向的，即数据从vue实例流向html元素。v-model指令实现了表单类元素的双向绑定，<strong>但该指令只能用于表单类元素。</strong>v-model实际就是一个语法糖，它实现了对如下代码的包装。</p><p><code>&lt;input v-bind:value="name" v-on:input="name = $event.target.value"&gt;</code></p><p>v-model指令默认收集的是value属性值，因此可将<code>v-model:value="name"</code>简写成<code>v-model="name"</code>。</p><h4 id="计算属性">计算属性</h4><p>计算属性具备缓存功能，这是方法调用无法比拟的，频繁操作时性能更好。</p><p>只有当计算属性首次被读取或依赖的属性发生变动时才会重新调用get访问器。比如以下示例代码中，控制台只输出了一次信息。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> &#123;&#123; fullName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> &#123;&#123; fullName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> &#123;&#123; fullName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">firstName</span>: <span class="hljs-string">&quot;王&quot;</span>,</span><br><span class="language-javascript">                <span class="hljs-attr">lastName</span>: <span class="hljs-string">&quot;二&quot;</span></span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">fullName</span>: &#123;</span><br><span class="language-javascript">                    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get访问器&#x27;</span>);</span><br><span class="language-javascript">                        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;</span><br><span class="language-javascript">                    &#125;</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>计算属性中的this指向vue示例，这是vue自动帮我们实现的。</p><p>get访问器只关注依赖的属性。set访问器实际很少用到，当只有get访问器时，可简写成方法的型式，方法名即为属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">fullName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get访问器&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="监视属性">监视属性</h4><p>TODO</p><h4 id="条件渲染">条件渲染</h4><p><code>v-show</code>和<code>v-if</code>都能控制节点是否在页面中出现。<code>v-if</code>控制当前节点是否渲染，而<code>v-show</code>始终渲染节点，只是改变了样式的<strong>display</strong>属性值。如果频繁切换显示，建议使用<code>v-show</code>，性能更优。</p><p>值得注意的是：多个if条件与if-else语法结构存在差异。示例1代码中会将3个条件依次判断一遍，不管上一个条件是否已满足；示例2代码中当某个分支条件满足后，将跳过后续判断。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 示例1 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;2021 === year&quot;</span>&gt;</span>牛年<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;2020 === year&quot;</span>&gt;</span>鼠年<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;2019 === year&quot;</span>&gt;</span>豬年<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 示例2 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;!gender&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>人妖<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>if-else结构中，多个分支必须连续，否则将不起作用。</p><p>单个if控制多个标签时，建议使用<code>template</code>标签，不推荐使用<code>div</code>标签，因为后者会在DOM结构中增加额外节点，但<code>template</code>只能配合<code>v-if</code>指令使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 不推荐 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isAdmin&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>发表文章<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>管理用户<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 推荐 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isAdmin&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>发表文章<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>管理用户<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>v-if</code>配合<code>div</code>和<code>template</code>的区别：</p><figure><imgsrc="https://gitee.com/romango/picbed/raw/master/picgo/image-20210829215041119.png"alt="image-20210829215041119" /><figcaption aria-hidden="true">image-20210829215041119</figcaption></figure><h4 id="循环渲染">循环渲染</h4><h4 id="事件绑定">事件绑定</h4><h2 id="组件">组件</h2><h2 id="路由">路由</h2><h2 id="vuex">vuex</h2>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>话说using语句</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/%E8%AF%9D%E8%AF%B4using%E8%AF%AD%E5%8F%A5/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/%E8%AF%9D%E8%AF%B4using%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>using 是 C#程序员非常熟悉的关键字，概括起来有两个用途：引入命名空间；释放非托管资源。第一个用途就不多说了，下面剖析下释放非托管资源的前前后后。</p><h2 id="资源分类">资源分类</h2><p>众所周知，C# 中的资源分托管资源和非托管资源。托管资源位于托管堆上，由GC 自动回收。由于非托管资源不在托管堆上，GC秉持“铁道警察各管一段”的职业道德，非托管资源它就不管了，交给程序员自己释放吧。</p><p>常见的非托管资源包括数据库连接、文件流、网络套接字等等，它们往往比内存更宝贵，用完应尽早释放。鉴于非托管资源自身的多样性和复杂性，GC也心有余而力不足。另外，GC 回收资源不是实时的，把非托管资源交给 GC释放也存在滞后。对于托管资源，GC早点、晚点来释放，无非就是多占点内存，没那么紧要。</p><h2 id="释放方法">释放方法</h2><p>.NET提供了两个非托管资源的释放方法：类型自身的<code>Finalize()</code>方法和<code>IDispose</code>接口的<code>Dispose()</code>方法。</p><p>GC回收对象时会调用<code>Finalize()</code>方法。重载某个类的<code>Finalize()</code>方法，再将清理逻辑写在其中，这样就实现了非托管资源的托管释放。但于非托管资源的释放与对象本身的回收往往无法同步，且<code>Finalize()</code>方法的调用也相当消耗资源。</p><p>为了方便及时释放非托管资源，微软专门定义了一个接口<code>IDisposable</code>，该接口中只包含一个方法<code>Dispose()</code>。任何包含非托管资源的类都应继承此接口，并将清理逻辑写入<code>Dispose()</code>方法的实现中，以确保非托管资源的正常释放。非常贴心的是，微软实现了大多数非托管资源操作类的<code>Dispose()</code>方法，比如FileStream 类、SqlConnection 类、WebClient 类等等。</p><h2 id="using语句">using语句</h2><h3 id="用法说明">用法说明</h3><p>文章开头就说了，using语句会隐式调用<code>Dispose()</code>方法。这里以创建数据库连接为例，展示一下这种写法简洁与优雅。注意：using语句只适用于实现了<code>IDispose</code>接口的类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Data.SqlClient;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">using</span>(<span class="hljs-keyword">var</span> dbConnection = <span class="hljs-keyword">new</span> SqlConnection(<span class="hljs-string">&quot;Server=.;Database=test;uid=sa;pwd=123&quot;</span>))<br>            &#123;<br>                dbConnection.Open();<br>                <span class="hljs-comment">// .......................</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>学习任何一门知识，不深入不专注都很难有所得。下面我们用<ahref="https://github.com/icsharpcode/ILSpy">ILSpy</a>查看下程序的中间码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.method private hidebysig static <br>void Main (<br>string[] args<br>) cil managed <br>&#123;<br>// Method begins at RVA 0x2050<br>// Header size: 12<br>// Code size: 35 (0x23)<br>.maxstack 1<br>.entrypoint<br>.locals init (<br>[0] class [System.Data]System.Data.SqlClient.SqlConnection dbConnection<br>)<br><br>IL_0000: nop<br>IL_0001: ldstr &quot;Server=.;Database=test;uid=sa;pwd=123&quot;<br>IL_0006: newobj instance void [System.Data]System.Data.SqlClient.SqlConnection::.ctor(string)<br>IL_000b: stloc.0<br>.try<br>&#123;<br>IL_000c: nop<br>IL_000d: ldloc.0<br>IL_000e: callvirt instance void [System.Data]System.Data.Common.DbConnection::Open()<br>IL_0013: nop<br>IL_0014: nop<br>IL_0015: leave.s IL_0022<br>&#125; // end .try<br>finally<br>&#123;<br>IL_0017: ldloc.0<br>IL_0018: brfalse.s IL_0021<br><br>IL_001a: ldloc.0<br>IL_001b: callvirt instance void [mscorlib]System.IDisposable::Dispose()<br>IL_0020: nop<br><br>IL_0021: endfinally<br>&#125; // end handler<br><br>IL_0022: ret<br>&#125; // end of method Program::Main<br></code></pre></td></tr></table></figure><p>可见 using 语句只是一个语法糖，背后还是依靠了传统的 try-finaly结构。秘密在于：finally语句块中调用了实例的<code>Dispose()</code>方法，以此保证了数据库连接始终能被释放。</p><h3 id="注意事项">注意事项</h3><ol type="1"><li><p>不要嵌套使用</p><p>不要嵌套使用 using 语句。否则，内层 using块发生异常时，外层的对象资源将得不到释放。</p></li><li><p>捕获异常</p><p>using 语句只是对 try-finaly 结构的包装，无法 catch异常。需要处理异常的场合，建议还是使用 try-catch-finaly，示例如下。另外，不要在 try 语句中嵌套使用 using ，也不要在 using语句中嵌套使用 try，因为都很难看！万事不必强求！！！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Data.SqlClient;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            SqlConnection dbConnection = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span><br>            &#123;<br>                dbConnection = <span class="hljs-keyword">new</span> SqlConnection(<span class="hljs-string">&quot;Server=.;Database=test;uid=sa;pwd=123&quot;</span>);<br>                dbConnection.Open();<br>                <span class="hljs-comment">// ....</span><br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e)<br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(e.Message);<br>            &#125;<br>            <span class="hljs-keyword">finally</span><br>            &#123;<br>                dbConnection?.Close();<br>                dbConnection?.Dispose();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>试试nameof表达式</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/%E8%AF%95%E8%AF%95nameof%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/%E8%AF%95%E8%AF%95nameof%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>nameof 是 C# 6.0新增的表达式，与 sizeof 不同， 它不是运算符。MSDN 上关于 nameof 的介绍很简单，但作用却不简单。</p><p>nameof用于获取变量、类型或成员的名称，可避免类名或属性名作为参数时使用hardcode，以防后续重构困难。同时 nameof也可部分代替反射，提高了程序的性能。下面介绍两个 nameof的典型应用场景。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/nameof.png" /></p><h2 id="属性通知">属性通知</h2><p>MVVM设计模式中，属性值改变时要触发相关事件，同时传递属性名称作为事件的参数，以告知View 具体是哪个属性发生了变化，代码一般写在属性的 set访问器中。原始写法和改进写法对比如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Stock</span>: <span class="hljs-title">INotifyPropertyChanged</span> <br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> _price;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Price<br>    &#123;<br>     <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _price;<br>&#125;<br><span class="hljs-keyword">set</span> <br>&#123;<br>    <span class="hljs-keyword">this</span>.OnPropertyChanged(<span class="hljs-string">&quot;UserName&quot;</span>);<br>    <span class="hljs-comment">// 原始写法使用了hardcode</span><br>    <span class="hljs-keyword">this</span>.OnPropertyChanged(<span class="hljs-keyword">nameof</span>(Price));<br>    <span class="hljs-comment">// 改进写法可被同步改名</span><br>    _price = <span class="hljs-keyword">value</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPropertyChanged</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> propertyName</span>)</span> <br>&#123;<br><span class="hljs-keyword">this</span>.PropertyChanged.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> PropertyChangedEventArgs(propertyName));<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PropertyChangedEventHandler PropertyChanged;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 hardcode 的原始写法存在两个明显弊端：</p><ol type="1"><li><p>排错难</p><p>若将字符串字面量<code>"Price"</code>误写成<code>"Priec"</code>，编译能通过，运行后还是无法实现通知功能。这类错误往往很难排查。</p></li><li><p>重构烦</p><p>当修改属性名时应同步修改对应的字符串参数，改多了就容易遗漏，当然一个一个改起来本身就很繁琐。</p></li></ol><h2 id="数据库字段映射">数据库字段映射</h2><p>使用 Dapper 这类 ORM 框架时，SQL 语句中的表名和字段名应与对应 POCO类的类名和属性名一致，否则无法建立映射关系。以往做法是写死 SQL语句中的表名和字段名，造成后期维护麻烦，比如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> <span class="hljs-keyword">record</span> = DbConnection.QueryFirstOrDefault(<span class="hljs-string">$&quot;SELECT TOP 1 FROM Stock WHERE Name=<span class="hljs-subst">&#123;tesla.Name&#125;</span>&quot;</span>);<br></code></pre></td></tr></table></figure><p>上例中，表名 Tesla 和 字段名 Name 都是写死的。后期若要重构 POCO类，逐条修改 SQL 语句要累成狗。使用 nameof改成以下写法，按按【Ctrl+R+R】轻松搞定，高下立判！</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> <span class="hljs-keyword">record</span> = DbConnection.QueryFirstOrDefault(<span class="hljs-string">$&quot;SELECT TOP 1 FROM <span class="hljs-subst">&#123;<span class="hljs-keyword">nameof</span>(Stock)&#125;</span> WHERE <span class="hljs-subst">&#123;<span class="hljs-keyword">nameof</span>(Stock.Name)&#125;</span> = <span class="hljs-subst">&#123;tesla.Name&#125;</span>&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="非完全限定名">非完全限定名</h2><p>nameof返回的是非完全限定名，如果需要完全限定名就只能靠反射了，这点需要留意。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine(<span class="hljs-keyword">nameof</span>(System.Console)); <span class="hljs-comment">// 打印 Console</span><br>Console.WriteLine(<span class="hljs-keyword">typeof</span>(System.Console).FullName); <span class="hljs-comment">// 打印 System.Console</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神奇的Fody</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/%E7%A5%9E%E5%A5%87%E7%9A%84Fody/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/%E7%A5%9E%E5%A5%87%E7%9A%84Fody/</url>
    
    <content type="html"><![CDATA[<h2 id="aop编程范式">AOP编程范式</h2><p>世界观与方法论是一个宏大的话题，世界观决定了方法论，方法论影响了世界观。在计算机的世界里，编程范式就是程序员的方法论。从时间维度看待编程，面向过程是自然而然的选择。从空间角度去看，必然会提炼出面对对象的编程方法。</p><p>面向过程、面向对象、函数式编程等都是常见的编程范式，AOP也属于编程范式的一种，笔者认为这是一种面向<strong>补充需求</strong>的编程范式。AOP的字面翻译为面向切片编程，它其实是对面向对象编程的补充。AOP的核心思想是将程序的功能点独立出来，使程序具备更高的模块化特性。就好比提供了红点瞄准器、倍镜、消音器、枪口制退器、扩容弹夹等枪械部件，根据任务需要搭配，最终组成一把功能齐备的步枪。</p><p>AOP 常见实现方式有三种：</p><ul><li>中间件</li><li>过滤器</li><li>代码织入</li></ul><p>本文将只谈代码织入，代码织入分动态织入和静态织入。静态织入在编译时就将各种涉及AOP拦截的代码注入到符合一定规则的类中，最终效果与直接在源码中给类增加属性或方法相同，只是这个工作交由编译器和框架完成。动态织入借助反射特性，动态生成代理类达成AOP。</p><h2 id="fody框架">Fody框架</h2><p><a href="https://github.com/FODY">Fody</a> 是 .NET平台下一款优秀的开源静态织入框架，以插件的方式灵活地为程序增加功能。</p><p>Fody 并没有对织入源码，而是直接织入编译好的程序集，其中至关重要的ILRepack 功能由 <a href="https://github.com/Fody/cecil">Ceil</a>库实现。这样处理使得框架更具通用性，毕竟 .Net 平台下的编程语言包括C#、VB.Net和 F#三种，不过它们生成的 IL 代码格式一致。只针对 IL代码，不针对具体语言，无形中降低了框架的开发难度。织入流程图如下。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/202204122108221.png"alt="Code weaving using Fody" /><figcaption aria-hidden="true">Code weaving using Fody</figcaption></figure><p>打包资源，参数 Null检查，通知属性等个性化需求以往都在源码层面通过大量的 plumbing code完成，这些代码通常高度一致。编写这些模板代码工作量很大，要求程序员掌握诸如反射、编译等多方面知识，如此重复性的工作意义不大，还造成代码冗余。插件解决了上述痛点，程序员可以用一种傻瓜化的方式实现各种需求，还避免了造轮子。目前官方提供10多个插件，具体用法见<ahref="https://github.com/Fody/FodyAddinSamples">示例项目</a>。</p><h2 id="propertychanged插件">PropertyChanged插件</h2><p>PropertyChanged 是一款非常方便的插件，省去了 MVVM编程中大量冗余代码。众所周知，属性要具备通知功能，传统做法是所属类先继承<code>INotifyPropertyChanged</code>接口，再在<code>setter</code>访问器中引发通知事件。事件的第一个参数是<code>this</code>指针，第二个参数是对应属性名（C#6.0新增的<code>nameof</code>关键字可代替硬编码属性名）。示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-title">INotifyPropertyChanged</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PropertyChangedEventHandler PropertyChanged;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _fullName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _fullName; &#125;<br>        <span class="hljs-keyword">set</span> <br>        &#123; <br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.Equals(<span class="hljs-keyword">value</span>, _fullName))<br>            &#123;<br>                _fullName = <span class="hljs-keyword">value</span>;<br>                OnPropertyChanged(<span class="hljs-keyword">nameof</span>(FullName)); <span class="hljs-comment">// C#6.0新增关键字</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPropertyChanged</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> propertyName = <span class="hljs-literal">null</span></span>)</span><br>    &#123;<br>        PropertyChanged?.Invoke(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> PropertyChangedEventArgs(propertyName));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>试想一下，如果有几十个通知属性，写起来多么麻烦！在没有<code>nameof</code>关键字的情况下，一旦属性名拼写错误，排错也不是件易事。这些弊端在引入PropertyChanged 插件后将完全根除，插件安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Install-Package PropertyChanged.Fody<br></code></pre></td></tr></table></figure><p>随之将上述代码简化为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-title">INotifyPropertyChanged</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PropertyChangedEventHandler PropertyChanged;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要某个类实现了<code>INotifyPropertyChanged</code>接口，插件就可根据此规则自动注入相关IL代码，将其所属全部属性升级为通知属性。如无必要的话，也可给属性单独设置<code>[DoNotNotifyAttribute]</code>特性以跳过代码注入，更多细节用法见<ahref="https://github.com/Fody/PropertyChanged/wiki">官方wiki</a>。</p><p>知其然而知其所有然，我们用 ILSpy 查看一下反编译后的代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-title">INotifyPropertyChanged</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName<br>&#123;<br>[<span class="hljs-meta">CompilerGenerated</span>]<br><span class="hljs-keyword">get</span><br>&#123;<br><span class="hljs-keyword">return</span> &lt;FullName&gt;k__BackingField;<br>&#125;<br>[<span class="hljs-meta">CompilerGenerated</span>]<br><span class="hljs-keyword">set</span><br>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.Equals(&lt;FullName&gt;k__BackingField, <span class="hljs-keyword">value</span>, StringComparison.Ordinal))<br>&#123;<br>&lt;FullName&gt;k__BackingField = <span class="hljs-keyword">value</span>;<br>&lt;&gt;OnPropertyChanged(&lt;&gt;PropertyChangedEventArgs.FullName);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> PropertyChangedEventHandler PropertyChanged;<br><br>[<span class="hljs-meta">GeneratedCode(<span class="hljs-string">&quot;PropertyChanged.Fody&quot;</span>, <span class="hljs-string">&quot;3.4.0.0&quot;</span>)</span>]<br>[<span class="hljs-meta">DebuggerNonUserCode</span>]<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> &lt;&gt;OnPropertyChanged(PropertyChangedEventArgs eventArgs)<br>&#123;<br><span class="hljs-keyword">this</span>.PropertyChanged?.Invoke(<span class="hljs-keyword">this</span>, eventArgs);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述自动生成的代码与传统方式编写的代码并无二致，笔者认为这是目前实现通知属性最优雅的方式。</p><h2 id="参考文章">参考文章</h2><p>1、https://codingcanvas.com/code-weaving-using-fody/2、https://www.cnblogs.com/weidaorisun/p/15627183.html3、https://github.com/Fody/Home</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>C#</tag>
      
      <tag>MVVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>托管代码简介</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>托管代码运行于CLR之上，CLR即<strong>通用语言运行平台</strong>，也叫<strong>通用语言运行时</strong>。作为一个平台，CLR提供了以下主要功能：</p><ul><li>实时编译JIT</li><li>垃圾回收GC</li><li>程序集加载</li><li>提供基础类库</li><li>内存管理</li><li>线程管理</li><li>异常管理</li><li>安全管理</li><li>类型安全检查</li><li>调试引擎</li></ul><p>托管代码实际就是中间语言（MSIL）代码，这些代码无法被CPU直接执行，这是与机器码（nativecode）的最大区别。编译器生成的托管代码应用程序或链接库被称为程序集，当程序集运行加载时，由CLR将程序集中的托管代码实时转换成机器码，此过程称为“实时编译JIT”。这样做虽然显得大费周章，同时不可避免地造成了效率下降，但是带来跨平台等多个好处。首次编译生成的机器码将被保留在内存中，后续再次执行同一程序集将无需重复编译。程序集生成、执行流程如下图：</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E7%25A8%258B%25E5%25BA%258F%25E9%259B%2586%25E7%2594%259F%25E6%2588%2590%25E3%2580%2581%25E6%2589%25A7%25E8%25A1%258C%25E6%25B5%2581%25E7%25A8%258B1.jpg"alt="程序集生成、执行流程1" /><figcaption aria-hidden="true">程序集生成、执行流程1</figcaption></figure><p>.NET Framework与CLR不一定一起更新。 例如，2.0、3.0 和 3.5版的 .NETFramework 都使用了 2.0版CLR 。 下表展示了 .NET Framework 与 CLR的对应关系。</p><table><thead><tr class="header"><th style="text-align: left;">.NET版本</th><th style="text-align: left;">CLR版本</th><th style="text-align: left;">CLR文件</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">1.1</td><td style="text-align: left;">1.1</td><td style="text-align: left;">mscorwks.dll</td></tr><tr class="even"><td style="text-align: left;">2.0</td><td style="text-align: left;">2.0</td><td style="text-align: left;">mscorwks.dll</td></tr><tr class="odd"><td style="text-align: left;">3.0</td><td style="text-align: left;">2.0</td><td style="text-align: left;">mscorwks.dll</td></tr><tr class="even"><td style="text-align: left;">3.5</td><td style="text-align: left;">2.0</td><td style="text-align: left;">mscorwks.dll</td></tr><tr class="odd"><td style="text-align: left;">4.0</td><td style="text-align: left;">4.0</td><td style="text-align: left;">clr.dll</td></tr><tr class="even"><td style="text-align: left;">4.5</td><td style="text-align: left;">4.0</td><td style="text-align: left;">clr.dll</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stylet框架非官方中文文档</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/Stylet%E6%A1%86%E6%9E%B6%E9%9D%9E%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/Stylet%E6%A1%86%E6%9E%B6%E9%9D%9E%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>Stylet 是一款非常优秀的 MVVM 框架，配套 wiki写的也很棒。为了让更多的人熟悉这款框架，同时也给自己一个全面学习 Stylet的机会，笔者决定将其 wiki译成中文。限于外语水平和专业知识有限，难免出现不到和纰漏之处，望读者海涵。</p><h1 id="简介">简介</h1><p>Stylet是一款小巧又强大的 MVVM 框架，它的诞生受到了<ahref="http://caliburnmicro.com/">Caliburn.Micro</a>的启发。开发本框架的意图是尽量降低MVVM 的复杂性和神秘性，让菜鸟也能快速上手。</p><p>Stylet 的部分功能是 Caliburn.Micro 不具备的，比如：IoC 容器、简单的ViewModel 验证，兼容 MVVM 的消息框（译者注：方便单元测试）。</p><p>Stylet 项目源码经过全面的单元测试，LOC指标优秀，非常适合一些由于使用和验证 SOUP导致开销很大的项目。得益于模块化的设计，本框架提供功能可按需引入。</p><blockquote><p>Stylet is a minimal, but powerful, MVVM framework inspired by <ahref="http://caliburnmicro.com/">Caliburn.Micro</a>. Its intention is tocut down on the complexity and magic even further, to allow people(coworkers) unfamiliar with any MVVM framework to get up to speed morequickly.</p><p>It also provides features not available in Caliburn.Micro, includingits own IoC container, easy ViewModel validation, and even anMVVM-compatible MessageBox.</p><p>The low LOC count and very comprehensive test suite makes it anattractive option for projects where using and validating/verifying SOUPcomes with a high overhead, which its modular toolkit-inspiredarchitecture means it's easy to use just the bits you like, or replacethe bits you don't.</p><p>A brief feature list is shown below. Follow the links on the right tolearn more.</p></blockquote><h2 id="viewmodel-优先模式">ViewModel 优先模式</h2><p>经典 MVVM 架构通常使用View优先的模式，该模式中由 View 隐式实例化ViewModel，ViewModel 一般不被显式实例化。Stylet 反其道而行之，先实例化ViewModel 再用 ViewModel 附加 View，形成了独具一格的ViewModel优先模式。这样做最明显的好处是方便组织 ViewModel。</p><blockquote><p>The classic MVVM structure, where a view knows how to instantiate itsViewModel, and ViewModels typically don't communicate directly, is knownas View-first. However, reversing this pattern - instantiating theViewModels yourself and having the Views automatically attached -provides many advantages, allowing you to compose your ViewModels in away which should feel very familiar. This ViewModel-first approach isthe only one supported by Stylet.</p></blockquote><h2 id="动作">动作</h2><p>WPF 的 ICommand接口很强大但也很笨重，譬如按钮点击动作用属性来实现而不是用方法，也不怎么符合直觉。通过前端 XAML动作绑定：<code>&lt;Button Command="&#123;s:Action DoSomething&#125;"/&gt;</code>，按钮被点击时将调用ViewModel 中定义好的<code>DoSomething()</code>方法。另外，还可创建一个名为<code>CanDoSomething</code>的监视属性用于判断该方法是否可被执行。事件也可绑定动作，比如为<code>MouseEnter</code>事件绑定动作：<code>&lt;Button MouseEnter="&#123;s:Action DoSomethingElse&#125;"/&gt;</code>。</p><blockquote><p>The ICommand interface used by WPF is powerful, but clunky when usedin an MVVM architecture. It doesn't seem right that actions to be takenby your ViewModel in response to things like button clicks should berepresented as properties, rather than methods. A simple<code>&lt;Button Command="&#123;s:Action DoSomething&#125;"/&gt;</code> will cause<code>DoSomething()</code> on your ViewModel to be called every time thebutton is clicked. Additionally, if you have a bool property called<code>CanDoSomething</code>, that will be observed and used to tellwhether the button should be enabled or disabled.</p><p>Actions also work with events, allowing you to do things like<code>&lt;Button MouseEnter="&#123;s:Action DoSomethingElse&#125;"/&gt;</code>.</p></blockquote><h2 id="页面和页面管理器">页面和页面管理器</h2><p>Screen 是 ViewModel 的基类，其本身实现了很多功能：事件通知、ViewModel校验、生命周期管理（何时显示、隐藏、关闭窗口及确定窗口能否被关闭）。</p><blockquote><p>The Screen class provides many things which make it an attractivebase class for your ViewModels: PropertyChanged notifications,validation, and the ability to be notified when it'sshown/hidden/closed, and the ability to control if and when it can beclosed.</p></blockquote><h2 id="事件总线">事件总线</h2><p>类似于 Caliburn.Micro的事件总线，订阅者直接从总线上获取某事件而无需了解该事件发布者的信息。事件总线有很多应用场景，比如ViewModel 间传递消息。</p><blockquote><p>Stylet's Event Aggregator is very similar to Caliburn.Micro's, andallows subscribers to receive messages from publishes without eitherhaving knowledge of, or retaining, the other. This is particularlyuseful for messaging between ViewModels, although it has plenty of otheruses.</p></blockquote><h2 id="窗口管理器">窗口管理器</h2><p>窗口具体实现了 Stylet 的 ViewModel 优先模式，还实现了兼容 MVVM的消息框。</p><blockquote><p>With a ViewModel-first approach, you display windows and dialogs byreferencing the ViewModel to display, and the View gets attachedautomatically. The WindowManager allows this to be done with ease.</p><p>An MVVM-compatible MessageBox implementation is also provided, so youdon't have to roll your own.</p></blockquote><h2 id="校验">校验</h2><p>在传统 MVVM 架构下，校验 ViewModel需要大量的模板文件，而且相关资源都是松散的。Stylet有一个专门用于校验的框架，该框架还支持自定义校验库（比如： <ahref="https://fluentvalidation.codeplex.com/">FluentValidation</a>）。</p><blockquote><p>Validation in MVVM is traditionally a bit of a pain: it requires afair amount of boilerplate in each ViewModel that requires validation,and resources on how to do this well are sparse.</p><p>Stylet comes with a framework for taking your favourite validationlibrary (e.g. <ahref="https://fluentvalidation.codeplex.com/">FluentValidation</a>) andhandles running validations and reporting the results to the View.</p></blockquote><h2 id="styletioc-容器">StyletIoC 容器</h2><p>Stylet 提供了一个强大、快速、轻量且易于使用的 IoC 容器。</p><blockquote><p>Stylet comes with its own lightweight and extremely fast (but stillpowerful) IoC container, although it's easy to use another one if you'dprefer.</p></blockquote><h2 id="mit-许可">MIT 许可</h2><p>Stylet 使用 MIT 许可，该许可证允许您自行修改 Stylet并将其用于商业用途，无归属者（唯一的限制是您必须包含本许可的副本）。若有需要，我们愿意根据具体情况重新许可。</p><blockquote><p>Stylet is distributed under the MIT license, which allows you tomodify Stylet, and include it in commercial projects, withoutattributation (the only restriction being that you must include a copyof the license). I'm open to re-licensing it on a case-by-case basis ifyou require this.</p></blockquote><h1 id="快速上手">快速上手</h1><p>想要上手试一下吗？那么请往下看吧！下面将创建一个简单的脚手架项目。</p><p><em><strong>注意</strong>：本项目的 git仓库包含示例代码，可自行下载学习。</em></p><blockquote><p>Want to get up and running as quickly as possible? This is the rightplace!</p><p><em>NOTE: If you're looking for example applications, download thesource code and look in the Samples folder.</em></p><p>The following instructions will set up a minimal skeletonproject.</p></blockquote><h2 id="自动安装">自动安装</h2><h3 id="net-framework">.NET Framework</h3><p><em><strong>注意</strong>：VS2013 及之前的版本不支持自动安装 Nuget包，若有需要请手动安装。</em></p><p>如果您刚接触 Stylet，最简单的上手步骤如下：</p><ol type="1"><li>打开Visual Studio，创建一个 WPF 项目；</li><li>通过 NuGet 包管理器（右键项目 -&gt;管理 Nuget包）安装<code>Stylet.Start</code>。</li><li>项目创建成功后，可删除 <code>Stylet.Start</code> 包。</li></ol><blockquote><p><strong>Note</strong>: This will <strong>not</strong> work if yourproject uses <strong>PackageReference</strong> for NuGet packages or ifyou are using VS2013 or earlier. Follow the "Manual Option" sectionbelow instead.</p><p>If you're new to Stylet (and you're running VS2015 or later), this isthe easiest way to get started.</p><ol type="1"><li>Open Visual Studio, and create a new <code>WPF Application</code>project.</li><li>Open NuGet (right-click your project -&gt; Manage NuGet Packages),and install the <code>Stylet.Start</code> package.</li></ol><p>This will give you a working skeleton project.</p><p>When it has finished installing, uninstall Stylet.Start.</p><p>Happy coding!</p></blockquote><h3 id="net-core">.NET Core</h3><p>建议通过 <code>dotnet new</code>命令使用 Stylet 模板创建 .NET Core脚手架项目。</p><p>在项目目录打开命令行，输入命令安装 Stylet 模板：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pow">dotnet new -i Stylet.Templates<br></code></pre></td></tr></table></figure><p>根据新安装的模板创建项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pow">dotnet new stylet -o MyStyletProject<br></code></pre></td></tr></table></figure><blockquote><p>For .NET Core projects, the quickest way to get started is by using<code>dotnet new</code> with Stylet's template.</p><p>Open a command window where you want to create your new project, andinstall the Stylet templates using:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">dotnet <span class="hljs-keyword">new</span> <span class="hljs-type"></span>-i Stylet.Templates<br></code></pre></td></tr></table></figure><p>Then create a new project with:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">dotnet <span class="hljs-keyword">new</span> <span class="hljs-type">stylet</span> -o MyStyletProject<br></code></pre></td></tr></table></figure><p>(changing <code>MyStyletProject</code> as appropriate).</p></blockquote><h2 id="手动安装">手动安装</h2><p>如果您想手动创建项目，步骤如下：</p><ol type="1"><li>打开 Visual Studio，创建一个 WPF 项目；</li><li>通过 NuGet 包管理器（右键项目 -&gt;管理 Nuget包）安装<code>Stylet</code>包。</li></ol><p>删除<code>MainWindow.xaml</code>和<code>MainWindow.xaml.cs/vb</code>这些以后用不到的文件。接着右键项目，新增一个名为<code>RootView</code>的WPF 窗口，前端示例代码如下：</p><blockquote><p>If you don't want to use the <code>Stylet.Start</code> package andwould prefer to create your own skeleton project, follow theinstructions in this section.</p><ol type="1"><li>Open Visual Studio, and create a new <code>WPF Application</code>project.</li><li>Open NuGet (right-click your project -&gt; Manage NuGet Packages),and install the <code>Stylet</code> package.</li></ol><p>First off, delete <code>MainWindow.xaml</code> and<code>MainWindow.xaml.cs/vb</code>. You won't be needing them.</p><p>Next, you'll need a root View and a ViewModel. The View has to be a<code>Window</code>, but there are no other restrictions.</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;Stylet.Samples.Hello.RootView&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>Hello, World<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建一个名为<code>RootViewModel</code>的 ViewModel 类。</p><blockquote><p>The ViewModel can be any old class (for now - you might want it to bea <ahref="https://github.com/canton7/Stylet/wiki/Screens-and-Conductors">Screenor Conductor</a>).</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RootViewModel</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>引导器类的基本职责是实例化主窗口的 ViewModel，诸如 IoC容器等其它功能详见后续章节。</p><blockquote><p>Next, you'll need a bootstrapper. For now, you don't need anythingspecial - just something to identify your root ViewModel. Later, you'llbe able to configure your IoC container here, as well as otherapplication-level stuff.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bootstrapper</span> : <span class="hljs-title">Bootstrapper</span>&lt;<span class="hljs-title">RootViewModel</span>&gt;<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除<code>App.xaml</code>中的<code>StartUri</code>特性并引入 Stylet命名空间后，通过该命名空间下的<code>ApplicationLoader</code>元素以加载资源的方式实例化引导器类，示例代码如下：</p><blockquote><p>Finally, this needs to be referenced as a resource in your<code>App.xaml</code>. You'll need to remove the <code>StartUri</code>attribute, and add <code>xmlns</code> entries for Stylet and your ownapplication. Finally, you'll need to add Stylet's<code>ApplicationLoader</code> to the resources, and identify thebootstrapper you created above.</p><p>It should look something like this:</p></blockquote><figure class="highlight plaintext"><figcaption><span>x:Class</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs <Application">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;<br>             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;<br>             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;<br>             xmlns:local=&quot;clr-namespace:Stylet.Samples.Hello&quot;&gt;<br>    &lt;Application.Resources&gt;<br>       &lt;s:ApplicationLoader&gt;<br>            &lt;s:ApplicationLoader.Bootstrapper&gt;<br>                &lt;local:Bootstrapper/&gt;<br>            &lt;/s:ApplicationLoader.Bootstrapper&gt;<br>        &lt;/s:ApplicationLoader&gt;<br>    &lt;/Application.Resources&gt;<br>&lt;/Application&gt;<br></code></pre></td></tr></table></figure><p>好了，可以运行程序了！</p><blockquote><p>That's it! Run that, and you should get a window with 'Hello World'in it.</p></blockquote><h2 id="应用程序装载器">应用程序装载器</h2><p>上述<code>&lt;s:ApplicationLoader&gt;</code>元素用于加载 Stylet内置的资源，此类继承自资源字典类 ResourceDictionary ，用法如下：</p><blockquote><p>It's worth noting that <code>&lt;s:ApplicationLoader&gt;</code> aboveis a ResourceDictionary subclass. This allows it to load in Stylet'sbuilt-in resources (see <ahref="https://github.com/canton7/Stylet/wiki/Screens-and-Conductors">Screensand Conductors</a>). You can choose not to load Stylet's resources likethis:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span> <span class="hljs-attr">LoadStyletResources</span>=<span class="hljs-string">&quot;False&quot;</span>&gt;</span><br>   ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><code>&lt;s:ApplicationLoader&gt;</code>元素也可用来创建不属于Stylet的应用程序级资源或资源字典，用法如下：</p><blockquote><p>If you want to add your own Resources / ResourceDictionaries to theApplication, the simplest way is like this:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">local:Bootstrapper</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Style</span> <span class="hljs-attr">x:Key</span>=<span class="hljs-string">&quot;MyResourceKey&quot;</span>&gt;</span><br>            ...<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Style</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.MergedDictionaries</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span> <span class="hljs-attr">Source</span>=<span class="hljs-string">&quot;MyResourceDictionary.xaml&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.MergedDictionaries</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上代码也写成如下习惯形式：</p><blockquote><p>If this makes you uncomfortable for some reason, you can also dothis:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary.MergedDictionaries</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">local:Bootstrapper</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span> <span class="hljs-attr">Source</span>=<span class="hljs-string">&quot;MyResourceDictionary.xaml&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ResourceDictionary.MergedDictionaries</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Style</span> <span class="hljs-attr">x:Key</span>=<span class="hljs-string">&quot;MyResourceKey&quot;</span>&gt;</span><br>            ...<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ResourceDictionary</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="引导器">引导器</h1><p>引导器负责引导应用程序，可完成多项任务，其中两项基本任务如下：</p><ol type="1"><li>配置 IoC 容器</li><li>通过窗口管理器实例化根 ViewModel</li></ol><p>引导器类 BootStrapper 有两种父类：</p><ol type="1"><li><p>BootstrapperBase<TRootViewModel></p><p>使用自定义的 IoC 容器</p></li><li><p>Bootstrapper<TRootViewModel></p><p>使用默认的 IoC 容器，示例代码如下：</p></li></ol><blockquote><p>The bootstrapper is responsible for bootstrapping your application.It configures the IoC container, creates a new instance of your rootViewModel and displays it using the <code>WindowManager</code>. It alsoprovides various other functions, described below.</p><p>The bootstrapper comes in two flavours:<code>BootstrapperBase&lt;TRootViewModel&gt;</code>, which requires youto configure the IoC container yourself, and<code>Bootstrapper&lt;TRootViewModel&gt;</code>, which uses Stylet'sbuilt-in IoC container, StyletIoC.</p><p>Example bootstrapper, using StyletIoC:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">Bootstrapper</span> : <span class="hljs-title">Bootstrapper</span>&lt;<span class="hljs-title">MyRootViewModel</span>&gt;<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStart</span>()</span><br>   &#123;<br>      <span class="hljs-comment">// This is called just after the application is started, but before the IoC container is set up.</span><br>      <span class="hljs-comment">// Set up things like logging, etc</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureIoC</span>(<span class="hljs-params">IStyletIoCBuilder builder</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// Bind your own types. Concrete types are automatically self-bound.</span><br>      builder.Bind&lt;IMyInterface&gt;().To&lt;MyType&gt;();<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>()</span><br>   &#123;<br>      <span class="hljs-comment">// This is called after Stylet has created the IoC container, so this.Container exists, but before the</span><br>      <span class="hljs-comment">// Root ViewModel is launched.</span><br>      <span class="hljs-comment">// Configure your services, etc, in here</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLaunch</span>()</span><br>   &#123;<br>      <span class="hljs-comment">// This is called just after the root ViewModel has been launched</span><br>      <span class="hljs-comment">// Something like a version check that displays a dialog might be launched from here</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnExit</span>(<span class="hljs-params">ExitEventArgs e</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// Called on Application.Exit</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUnhandledException</span>(<span class="hljs-params">DispatcherUnhandledExceptionEventArgs e</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// Called on Application.DispatcherUnhandledException</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义-ioc-容器">自定义 IoC 容器</h2><p>使用自定义 IoC 容器很简单，官方 git 仓库也提供了多个 IoC容器供您选择。这些容器都经过了全面的单元测试。</p><p>由于管理多个 IoC 容器很麻烦，同时为了减少依赖，本框架的发布包只内置一个 IoC 容器。若您需要使用其它容器，可从官方 git仓库下载后手动添加引用。使用方法见上一章，示例代码如下：</p><blockquote><p>Using another IoC container with Stylet is easy. I've includedbootstrappers for a number of popular IoC containers in the <ahref="https://github.com/canton7/Stylet/tree/master/Bootstrappers">Bootstrappersproject</a>. These are all unit-tested but not battle-tested: feel freeto customize them.</p><p>Note that the Stylet nuget package / dll don't include these, as itwould add unnecessary dependencies. Similarly, I don't publish IoCcontainer-specific packages, as that's a waste of effort.</p><p>Copy the bootstrapper you want from the above link into your projectsomewhere. Then subclass it, as you would normally subclass<code>Bootstrapper&lt;TRootViewModel&gt;</code>, documented above. Thenadd your subclass to your App.xaml.cs, as documented in <ahref="https://github.com/canton7/Stylet/wiki/Quick-Start">QuickStart</a>, e.g.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bootstrapper</span> : <span class="hljs-title">AutofacBootstrapper</span>&lt;<span class="hljs-title">ShellViewModel</span>&gt;<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Application</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;Stylet.Samples.Hello.App&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:local</span>=<span class="hljs-string">&quot;clr-namespace:Stylet.Samples.Hello&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">local:Bootstrapper</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Application</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="添加资源字典">添加资源字典</h2><p>由于<code>s:ApplicationLoader</code>本身就是资源字典，如果再想添加其它资源字典，就必须与<code>s:ApplicationLoader</code>一起嵌套在合并资源字典<code>MergedDictionaries</code>中，示例代码如下：</p><blockquote><p>s:ApplicationLoader is itself a ResourceDictionary. If you need toadd your own resource dictionary to App.xaml, you will have to nests:ApplicationLoader inside your ResourceDictionary as aMergedDictionary, like this:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary.MergedDictionaries</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">local:Bootstrapper</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span> <span class="hljs-attr">Source</span>=<span class="hljs-string">&quot;YourDictionary.xaml&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ResourceDictionary.MergedDictionaries</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ResourceDictionary</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="viewmodel-优先">ViewModel 优先</h1><p>ViewModel 优先是 Stylet框架的一大特点，其相对于传统的View优先更显自然。</p><blockquote><p>The ViewModel-first approach is one that's crucial to Stylet'sarchitecture, but unintuitive if you learnt MVVM in the traditionalView-first manner.</p><p>Hopefully this article will make everything clear.</p></blockquote><h2 id="view优先">View优先</h2><p>让我们先了解一下什么是 View优先。该模式下视图必须了解 ViewModel的详细情况，但反过来 ViewModel 可以不知 View的信息。将两者联系到一起的常用方法是：在 View 的后台代码中实例化ViewModel ，并赋给 View 的<code>DataContent</code>属性。</p><blockquote><p>Let's start by defining the View-first approach, and what exactly Imean by that. MVVM states that the ViewModel should know nothing aboutthe View, but that View should be aware of the ViewModel. The obviousway to attach a View and ViewModel, then, is have the View construct itsViewModel in its codebehind - something like this:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> : <span class="hljs-title">Window</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyView</span>()</span><br>   &#123;<br>      InitializeComponent();<br> <br>      <span class="hljs-keyword">this</span>.DataContext = <span class="hljs-keyword">new</span> MyViewModel();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目前看起来都还不错！但当 View 创建了其它View，并需按层次关系组合这些被创建的 View时，危机来到了。一个很典型场景是窗口 View 创建了标题栏 View 和工作区View。</p><blockquote><p>This is fine. Views can create and own other views, meaning that youcan compose your views into a hierarchy. All well and good.</p><p>The crunch comes when you've composed a couple of views, saysomething like this, where a shell contains a top bar and a frame,inside which any page can be shown:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- This is a window which contains a top bar and another page --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.ShellView&quot;</span> <span class="hljs-attr">....</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">my:TopBarView</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Frame</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;navigationFrame&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>三者都有各自的 ViewModel 。当标题栏 View的某些字段变化了，比如标题改变了，窗口的 ViewModel可以得知上述变化，但标题栏 ViewModel却不知道。常用做法是在窗口标题栏的前端代码中，将窗口标题绑定到窗口本身的某个依赖属性上，示例代码如下：</p><blockquote><p>where <code>TopBarView</code> has its own ViewModel,<code>TopBarViewModel</code>. Fine.</p><p>Now say that <code>TopBarView</code> has a field containing some datayou want to update, for example the title of the current page. Now, the<code>ShellViewModel</code> knows this (it's decided what the currentpage is, after all), but the <code>TopBarViewModel</code> doesn't (howwould it? It doesn't really know about anything). The temptation is toexpose a dependency property on the <code>TopBarView</code> and bind itinto the <code>ShellViewModel</code>, like so:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.ShellView&quot;</span> <span class="hljs-attr">....</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;rootObject&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">my:TopBarView</span> <span class="hljs-attr">CurrentPageTitle</span>=<span class="hljs-string">&quot;&#123;Binding CurrentPageTitle, ElementName=rootObject&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Frame</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;navigationFrame&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure><p>后续标题栏的其它属性或者工作区的属性也许也要如此操作一番，简直太麻烦了。</p><p>另一个主要问题发生在显示窗口和对话框时，此问题也是传统 MVVM模型中的一个痛点。在 ViewModel 中实例化并显示相应的 View不便于单元测试，更好一点的选择是在主视图的后台代码中实例化并显示某个子视图，后续通过某种方式将创建的子视图与其子视图模型结合起来。</p><p><code>Frame</code>元素的内容需先实例化一个 View ，该由窗口的ViewModel 还是 View 实例化这个 View 呢？</p><p>总之，View优先弊端很多。</p><blockquote><p>but that's just nasty. You've now got one-and-a-bit views bound tothe <code>ShellViewModel</code>.</p><p>Another major concern is displaying windows and dialogs. Intraditional MVVM, this is a bit of a pain. One option is to instantiateand display the View (using <code>Show()</code> or<code>ShowDialog()</code>) from inside the ViewModel (which makes it, orat least that bit of it, untestable). The better option is toinstantiate the View you want to display in the codebehind of your View,and show it from there. This means you need to establish ways of tellingto View to display this dialog, and a way of getting the results of thedialog back to the ViewModel.</p><p>Indeed, setting the content for the <code>Frame</code> above requiresinstantiating a View to put in it. This has the same dilemma - eitherthe ViewModel instantiates it (making it untestable), or the View does(leading to communication pain).</p><p>Either way, this approach has some nastiness.</p></blockquote><h2 id="viewmodel-优先-1">ViewModel 优先</h2><p>该模式下， ViewModel 不由 View 来实例化， ViewModel也无需知道与其对应 View的存在。一个第三方服务将通过命名约定的方式匹配相关联的 View 和 ViewModel（比如根据 MainView 去搜寻 MainViewModel），匹配成功后继续由该服务实例化 ViewModel ，然后将其赋给对应 View 的<code>DataContext</code>属性。详见后续章节。</p><blockquote><p>The ViewModel-first approach accepts that a ViewModel shouldn't knowanything about its View, but does not accept that the View should beresponsible for constructing the ViewModel either. Instead, a thirdservice is responsible for locating the correct View for a givenViewModel, and setting up its DataContext correctly.</p><p>The default implementation uses naming conventions to locate thecorrect View for a given ViewModel, replacing 'ViewModel' with 'View' inits name. That's explained in more detail in <ahref="https://github.com/canton7/Stylet/wiki/The-ViewManager">TheViewManager</a>.</p><p><strong>This allows ViewModels to be created by other ViewModels.Which allows ViewModels to know about, and own, other ViewModels. Whichallows you to compose your ViewModels properly.</strong></p><p>There's another part of this trick, which is best explained byexample:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShellViewModel</span><br>&#123;<br>   <span class="hljs-keyword">public</span> TopBarViewModel TopBar &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-comment">// Stuff to instantiate and assign TopBarViewModel</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.ShellView&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span> <span class="hljs-attr">.....</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ContentControl</span> <span class="hljs-attr">s:View.Model</span>=<span class="hljs-string">&quot;&#123;Binding TopBar&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>附加属性<code>View.Model</code>将会实例化其绑定 ViewModel的实例（本例中是<code>TopBarViewModel</code>的实例）并作为ContentControl元素的内容，然后即可定位到正确的View（本例中是 <code>TopBarView</code>）。</p><p>诀窍在于<code>TopBarView</code>可以根据命名约定找到对应的<code>TopBarViewModel</code>，<code>TopBarViewModel</code>也可以被<code>ShellViewModel</code>知会。问题解决了！</p><blockquote><p>The <code>View.Model</code> attached property will fetch theViewModel it's bound to (in this case it's an instance of<code>TopBarViewModel</code>), and locate the correct view(<code>TopBarView</code>). It will instantiate an instance, and set itas the content of that <code>ContentControl</code>.</p><p>The upshot is that the <code>TopBarView</code> can get the name ofthe current page from its <code>TopBarViewModel</code>, and the<code>TopBarViewModel</code> can be told this by the<code>ShellViewModel</code>. Problem solved!</p><p>The <code>ContentControl</code> trick also works well fornavigation:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.ShellView&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span> <span class="hljs-attr">.....</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ContentControl</span> <span class="hljs-attr">s:View.Model</span>=<span class="hljs-string">&quot;&#123;Binding TopBar&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ContentControl</span> <span class="hljs-attr">s:View.Model</span>=<span class="hljs-string">&quot;&#123;Binding CurrentPage&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>当多页面窗口应用程序切换页面时，由主窗口的 ViewModel 实例化页面的ViewModel ，并将该实例赋值给主窗口 ViewModel的的<code>CurrentPage</code>属性。主窗口的 ViewModel不必知道如何得到页面的View。窗口管理器会以大致相同的方式处理对话框应用程序和窗口应用程序，在获得某个ViewModel 实例后将由其显示对应的窗口 View 或对话框 View。</p><blockquote><p>The <code>ShellViewModel</code> will then navigate to a new page byinstantiating a new instance of that page's <code>ViewModel</code>, andassigning it to the property <code>CurrentPage</code>. Note how the<code>ShellViewModel</code> no longer needs to know anything aboutviews. <em>It hasn't had to instantiate a single view</em>. This is avery important, useful, and powerful point.</p><p>Dialogs and Windows are handled in much the same way by <ahref="https://github.com/canton7/Stylet/wiki/The-WindowManager">TheWindowManager</a>. This takes a given ViewModel instance, and displaysits View as a dialog or window.</p></blockquote><h2 id="删除后台代码">删除后台代码</h2><p>在 ViewModel优先模式下，通过动作、转换器、附加属性、附加行为几乎可以实现所有功能，View的后台代码也就没有存在的必要了。强烈建议您删除 View的后台代码文件，<code>InitializeComponent</code>方法会由 Stylet替您调用。</p><p><em><strong>注意</strong>：VB.NET中不建议删除后台代码。</em></p><blockquote><p>With this approach in place, there's nothing you actually need to doin the codebehind. You can of course do so, but there's very little youcan't solve with <ahref="https://github.com/canton7/Stylet/wiki/Actions">Actions</a> (forhandling events), Converters, Attached Properties, and (mostimportantly) Attached Behaviors.</p><p>Stylet lets you delete the codebehind entirely (it will call<code>InitializeComponent</code> for you), and you are stronglyencouraged to do so. Delete the codebehind!</p><p><em><strong>Note</strong>: If you're using VB.NET, sometimes yourXAML namespaces will stop working if you delete the codebehind. If thisis the case, simply recreate the codebehind with the matching filename,give it the correct namespace and class and then leave the remainderblank. For example, <code>MyView.xaml.vb</code> :</em></p></blockquote><h1 id="动作-1">动作</h1><p>点击按钮后调用 ViewModel 定义的方法，动作适用于诸如此场景。</p><blockquote><p>You have a button, and you want to click it and execute a method onyour ViewModel? Actions cover this use-case.</p></blockquote><h2 id="动作和方法">动作和方法</h2><p>WPF 中命令绑定步骤为：ViewModel实现<code>ICommand</code>接口后将按钮的 Command 特性绑定到 ViewModel的某个属性。尽管看起来有点混乱，这种机制其实也不错，至少 ViewModel无需了解 View且View的后台代码也可删除。但最好还是直接调用方法而不是通过某个属型间接调用。Stylet引入了动作来解决这个问题，示例代码如下：</p><blockquote><p>In 'traditional' WPF, you'd create a property on your ViewModel whichimplements the <ahref="http://msdn.microsoft.com/en-us/library/system.windows.input.icommand(v=vs.110).aspx">ICommand</a>interface, and bind your button's Command attribute to it. This worksfairly well (the ViewModel knows nothing about the View, and code-behindis not required), but it's a bit messy - you really want to be calling amethod on your ViewModel, not executing a method on some property.</p><p>Stylet solves this by introducing Actions. Look at this:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span> : <span class="hljs-title">Screen</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span><br>   &#123;<br>      Debug.WriteLine(<span class="hljs-string">&quot;DoSomething called&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.View&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action DoSomething&#125;&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上例中点击按钮后将直接调用<code>DoSomething</code>方法，多么简单！CommandParameter特性还可用来给方法传递一个参数，示例代码如下：</p><blockquote><p>As you might have guessed, clicking the button called the DoSomethingmethod on the ViewModel to be called.</p><p>It's that simple.</p><p>If your method accepts a single argument, the value of the button'sCommandParameter property will be passed. For example:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span> : <span class="hljs-title">Screen</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> argument</span>)</span><br>   &#123;<br>      Debug.WriteLine(String.Format(<span class="hljs-string">&quot;Argument is &#123;0&#125;&quot;</span>, argument));<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.View&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action DoSomething&#125;&quot;</span> <span class="hljs-attr">CommandParameter</span>=<span class="hljs-string">&quot;Hello&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>注意：动作也适用于任何 ICommand 类型的属性，比如 KeyBinding属性。</p><blockquote><p>Note that Actions also work on any ICommand property, on anything(e.g. a <ahref="http://msdn.microsoft.com/en-us/library/system.windows.input.keybinding(v=vs.110).aspx">KeyBinding</a>).</p></blockquote><h2 id="守卫属性">守卫属性</h2><p>1111</p><blockquote><p>You can also control whether you button is enabled just as easily,using <em>Guard Properties</em>. A guard property for a given method isa boolean property which has the name "Can<method name>", so if yourmethod is called "DoSomething", the corresponding guard property iscalled "CanDoSomething".</p><p>Stylet will check whether a guard property exists, and if so, willdisable the button if it returns false, or enable it if it returns true.It will also watch for PropertyChanged notifications for that property,so you can change whether the button is enabled.</p><p>For example:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span> : <span class="hljs-title">Screen</span><br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> _canDoSomething;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> CanDoSomething<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._canDoSomething; &#125;<br>      <span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>.SetAndNotify(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">this</span>._canDoSomething, <span class="hljs-keyword">value</span>); &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span><br>   &#123;<br>      Debug.WriteLine(<span class="hljs-string">&quot;DoSomething called&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事件">事件</h2><p>Stylet也支持事件绑定，语法同命令绑定，但是事件绑定不涉及守卫属性的概念。</p><blockquote><p>But what about if you want to call a ViewModel method when an eventoccurs? Actions have that covered as well. The syntax is exactly thesame, although there's no concept of a guard property here.</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.View&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;&#123;s:Action DoSomething&#125;&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br></code></pre></td></tr></table></figure><p>绑定事件的方法可以没有形参，也可以有一个或两个形参，方法的签名可能如下：</p><blockquote><p>The method which is called must have zero, one, or two parameters.The possible signatures are:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HasNoArguments</span>()</span> &#123; &#125;<br> <br><span class="hljs-comment">// This can accept EventArgs, or a subclass of EventArgs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HasOneSingleArgument</span>(<span class="hljs-params">EventArgs e</span>)</span> &#123; &#125;<br> <br><span class="hljs-comment">// Again, a subclass of EventArgs is OK</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HasTwoArguments</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h2 id="方法返回值">方法返回值</h2><p>动作通常不关心方法的返回类型和返回值，但返回 Task 是个例外。</p><blockquote><p>Actions don't care about the return type of the method, and thereturned value is discarded.</p><p>The exception to this is if a <code>Task</code> is returned (e.g. ifthe method being invoked is <code>async</code>). In this case, the<code>Task</code> will be awaited in an <code>async void</code> method.This means that if the method returns a <code>Task</code> which ends upcontaining an exception, this exception is rethrown and will bubble upto the Dispatcher, where it will terminate your application (unless youhandle it, with e.g.<code>BootstrapperBase.OnUnhandledException</code>). The effect is thesame as if the method being invoked was <code>async void</code>, butmeans it's easier to unit-test <code>async</code> ViewModel methods.</p></blockquote><h2 id="动作目标">动作目标</h2><blockquote><p>So far I've been telling a little white lie. I've been saying thatthe Action is invoked on the ViewModel, but that isn't strictly true.Let's go into a bit more detail.</p><p>Stylet defines an inherited attached property calledView.ActionTarget. When a View is bound to its ViewModel, theView.ActionTarget on the root element in the View is bound to theViewModel, and it's then inherited by each element in the View. When youinvoke an action, it's invoked on the View.ActionTarget.</p><p>This means that, by default, actions are invoked on the ViewModelregardless of the current DataContext, which is probably what youwant.</p><p>This is a very important point, and one that's worth stressing. TheDataContext will probably change at multiple points throughout thevisual tree. However, the View.ActionTarget will stay the same (unlessyou manually change it). This means the actions will always be handledby your ViewModel, and not by whatever object is being bound to, whichis almost always what you want.</p><p>You can of course alter the View.ActionTarget for individualelements, for example:</p></blockquote><h2 id="静态方法">静态方法</h2><p>动作也可调用静态方法</p><blockquote><p>Actions can also invoke static methods, if the target is a<code>Type</code> object (use <code>&#123;x:Type ...&#125;</code> in XAML forthis). You can set this using both <code>View.ActionTarget</code> andAction's <code>Target</code> property.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CommonButtonTarget</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span> &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action DoSomething, Target=&#123;x:Type my:CommonButtonTarget&#125;&#125;&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="动作和样式">动作和样式</h2><blockquote><p>Actions will not work from style setters. The classes required to dothis in WPF are all internal, which means there is no way to fix theissue. You will need to use old-fashioned Commands in this (rare) case,unfortunately.</p></blockquote><h2 id="上下文菜单和弹出式菜单陷阱">上下文菜单和弹出式菜单陷阱</h2><p>111</p><blockquote><p>View.ActionTarget is of course an attached property, which isconfigured to be inherited by the children of whatever element it is seton. Like any attached property, and indeed the DataContext, there arecertain boundaries it is not inherited across, such as:</p></blockquote><ul><li>Using a ContextMenu</li><li>Using a Popup</li><li>Using a Frame</li></ul><p>In these cases, Stylet will do the best it can to find a suitableActionTarget (it may, for example, find the the ActionTarget associatedwith the root element in the current XAML file), but this may not beexactly what you expect (e.g. it may ignore a<code>s:View.ActionTarget="&#123;Binding ...&#125;"</code> line you have somewherein the middle of your page), or it may (in rare circumstances) fail tofind an ActionTarget at all.</p><p>In this case, please set <code>s:View.ActionTarget</code> to asuitable value. You may struggle to get a reference to anything outsideof a ContextMenu from inside of one: I suggest the <ahref="http://www.thomaslevesque.com/2011/03/21/wpf-how-to-bind-to-data-when-the-datacontext-is-not-inherited/">BindingProxy</a>technique.</p><h2 id="附加行为">附加行为</h2><p>有两种可能会导致动作停止：<code>View.ActionTarget</code>为空或者<code>View.ActionTarget</code>中指定方法不存在。上述情况的默认处理如下：</p><table><thead><tr class="header"><th></th><th style="text-align: center;">View.ActionTarget为空</th><th style="text-align: center;">View.ActionTarget中指定方法不存在</th></tr></thead><tbody><tr class="odd"><td>命令</td><td style="text-align: center;">禁用控件</td><td style="text-align: center;">点击控件时抛出异常</td></tr><tr class="even"><td>事件</td><td style="text-align: center;">启用控件</td><td style="text-align: center;">事件被引发时抛出异常</td></tr></tbody></table><blockquote><p>There are two cases which will stop an action from working properly:if the <code>View.ActionTarget</code> is null, or if the specifiedmethod on the <code>View.ActionTarget</code> doesn't exist. The defaultbehaviour in each of these cases is as follows:</p><table><thead><tr class="header"><th></th><th>View.ActionTarget == null</th><th>No method on View.ActionTarget</th></tr></thead><tbody><tr class="odd"><td>Commands</td><td>Disable the control</td><td>Throw an exception when the control is clicked</td></tr><tr class="even"><td>Events</td><td>Enable the control</td><td>Throw an exception when the event is raised</td></tr></tbody></table><p>The justification for this is that if the<code>View.ActionTarget</code> is null, you must have set it yourself,so you probably know what you're doing. However, if the specified methoddoesn't exist on the <code>View.ActionTarget</code>, that's probably amistake, and you deserve to know.</p><p>Of course, this behaviour is configurable.</p><p>To control the behaviour when <code>View.ActionTarget</code> is null,set the <code>NullTarget</code> property on the <code>Action</code>markup extension so either <code>Enable</code>, <code>Disable</code>, or<code>Throw</code>. (Note that <code>Disable</code> is invalid when theAction is linked to an event, as we have no power to disableanything).</p><p>For example:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action MyMethod, NullTarget=Enable&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;&#123;s:Action MyMethod, NullTarget=Throw&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>11</p><blockquote><p>Similarly, you can set the <code>ActionNotFound</code> property tothe same values:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action MyMethod, ActionNotFound=Disable&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;&#123;s:Action MyMethod, ActionNotFound=Enable&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h1 id="窗口管理器-1">窗口管理器</h1><p>采用传统View优先的方法，要显示一个新的窗口或对话框应首先创建视图的实例，再调用实例方法<code>.Show()</code>或<code>.ShowDialog()</code>。采用ViewModel优先的方法时无法与视图直接交互，因此上述步骤行不通。窗口管理器正是为了解决这个问题，通过调用<code>IWindowManager.ShowWindow(someViewModel)</code>方法可定位并实例化对应的View，再将其绑定到 ViewModel，最后显示它。示例代码如下：</p><blockquote><p>In a traditional View-first approach, if you want to display a newwindow or dialog, you create a new instance of the View, then call<code>.Show()</code> or <code>.ShowDialog()</code>.</p><p>In a ViewModel-first approach, you can't interact directly with theviews, so you can't do this. The WindowManager solves this problem -calling <code>IWindowManager.ShowWindow(someViewModel)</code> will takethat ViewModel, find its view, instantiate it, bind it to thatViewModel, and display it.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeViewModel</span><br>&#123;<br>   <span class="hljs-keyword">private</span> IWindowManager windowManager;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SomeViewModel</span>(<span class="hljs-params">IWindowManager windowManager</span>)</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.windowManager = windowManager;<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowAWindow</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">var</span> viewModel = <span class="hljs-keyword">new</span> OtherViewModel();<br>      <span class="hljs-keyword">this</span>.windowManager.ShowWindow(viewModel);<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowADialog</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">var</span> viewModel = <span class="hljs-keyword">new</span> OtherViewModel();<br>      <span class="hljs-built_in">bool</span>? result = <span class="hljs-keyword">this</span>.windowManager.ShowDialog(viewModel);<br>      <span class="hljs-comment">// result holds the return value of Window.ShowDialog()</span><br>      <span class="hljs-keyword">if</span> (result.GetValueOrDefault(<span class="hljs-literal">true</span>))<br>      &#123;<br>         <span class="hljs-comment">// DialogResult was set to true</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多么简单有效！另外，通过构造注入的方式得到<code>IWindowManager</code>的实例而不是在ViewModel 中显式构造该实例使得单元测试方便很多。在 ViewModel 中调用父类<code>Screen</code> 的<code>RequestCLose</code>方法可关闭窗口或对话框。</p><blockquote><p>Nice and easy! In addition, the introduction of the IWindowManager(rather than calling methods directly on the ViewModel) makes testing alot easier.</p><p>To close a window or dialog from its ViewModel, use<code>Screen.RequestClose</code>, like this:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelDisplayedAsWindow</span><br>&#123;<br>   <span class="hljs-comment">// Called by pressing the &#x27;close&#x27; button</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Close</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.RequestClose();<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelDisplayedAsDialog</span><br>&#123;<br>   <span class="hljs-comment">// Called by pressing the &#x27;OK&#x27; button</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CloseWithSuccess</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.RequestClose(<span class="hljs-literal">true</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="消息框">消息框</h1><p>11</p><blockquote><p>As we all know, WPF comes with its own MessageBox implementation -<code>System.Windows.MessageBox</code>. And that's fine, except that youcan't call it from your ViewModel (well, you <em>can</em>, but it makesyour ViewModel untestable). The usual workaround suggested online is"write your own".</p><p>Well, Stylet comes with its own MessageBox clone, which looks andbehaves almost identically to the WPF one (including appearance,buttons, icons, auto-sizing, sounds, alignment, etc).</p></blockquote><h2 id="用法">用法</h2><p>11</p><blockquote><p>To use, simply call the <code>ShowMessageBox</code> method on<code>IWindowManager</code>, like this:</p><p>The MessageBox accepts all of the same options as as the WPFMessageBox, plus a few more.</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">public</span> MyViewModel<br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IWindowManager windowManager;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyViewModel</span>(<span class="hljs-params">IWindowManager windowManager</span>)</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.windowManager = windowManager;<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessagebox</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.windowManager.ShowMessageBox(<span class="hljs-string">&quot;Hello&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定制消息框">定制消息框</h2><p>111</p><blockquote><p>Stylet's MessageBox is implemented as a ViewModel,<code>MessageBoxViewModel</code>, and its corresponding View,<code>MessageBoxView</code>. The ViewModel implements an interface,<code>IMessageBoxViewModel</code>, and the <code>ShowMessageBox()</code>method uses this interface to retrieve an instance of the ViewModel.</p><p>Therefore, you can provide you own custom implementation of<code>MessageBoxViewModel</code> and <code>MessageBoxView</code> bywriting a ViewModel which implements <code>IMessageBoxViewModel</code>,and registering it with your IoC container. This will then be used by<code>ShowMessageBox()</code>.</p><p>If you just want to tweak the behaviour of the existing<code>MessageBoxViewModel</code>, you can. The following options areavailable:</p></blockquote><h3 id="自定义按钮内容">自定义按钮内容</h3><p>111</p><blockquote><p>You can edit the button text for any of the buttons on aper-application basis by modifying<code>MessageBoxViewModel.ButtonLabels</code>, which is a dictionaryholding the text to display for each button. If you just want to editthe text for a particular MessageBox, <code>ShowMessageBox</code> willaccept a dictionary allowing you to do just that:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#">MessageBoxViewModel.ButtonLabels[MessageBoxResult.No] = <span class="hljs-string">&quot;No, thanks&quot;</span>;<br> <br><span class="hljs-keyword">this</span>.windowManager.ShowMessageBox(<span class="hljs-string">&quot;Do you want breakfast?&quot;</span>, <br>                                   buttons: MessageBoxButton.YesNo, <br>                                   buttonLabels: <span class="hljs-keyword">new</span> Dictionary&lt;MessageBoxResult, <span class="hljs-built_in">string</span>&gt;()<br>        &#123;<br>            &#123; MessageBoxResult.Yes, <span class="hljs-string">&quot;Yes please!&quot;</span> &#125;,<br>        &#125;);<br> <br><span class="hljs-comment">// Will display a MessageBox with the buttons &quot;Yes please!&quot; and &quot;No, thanks&quot;</span><br></code></pre></td></tr></table></figure><h1 id="事件总线-1">事件总线</h1><p>事件总线是一个基于发布者/订阅者模型的事件管理器，其特征是去中心化和弱绑定。</p><blockquote><p>The EventAggregator is a decentralised, weakly-binding,publish/subscribe-based event manager.</p></blockquote><h2 id="发布者与订阅者">发布者与订阅者</h2><h3 id="订阅者">订阅者</h3><p>111</p><blockquote><p>subscribers interesting in a particular event can tell theIEventAggregator of their interest, and will be notified whenever apublisher publishes that particular event to the IEventAggregator.</p><p>Events are classes - do whatever you want with them. For example:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEvent</span><br>&#123; <br>  <span class="hljs-comment">// Do something </span><br>&#125;<br></code></pre></td></tr></table></figure><p>11</p><blockquote><p>Subscribers must implement <code>IHandle&lt;T&gt;</code>, where<code>T</code> is the event type they are interested in receiving (theycan of course implement multiple <code>IHandle&lt;T&gt;</code>'s formultiple <code>T</code>'s). They must then get hold of an instance ofthe IEventAggregator, and subscribe themselves, for example:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber</span> : <span class="hljs-title">IHandle</span>&lt;<span class="hljs-title">MyEvent</span>&gt;, <span class="hljs-title">IHandle</span>&lt;<span class="hljs-title">MyOtherEvent</span>&gt;<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Subscriber</span>(<span class="hljs-params">IEventAggregator eventAggregator</span>)</span><br>   &#123;<br>      eventAggregator.Subscribe(<span class="hljs-keyword">this</span>);<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">MyEvent message</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// ...</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">MyOtherEvent message</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// ...</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>111</p><blockquote><p>For VB.NET users, the <code>Sub New()</code> passing theeventAggregator by reference will probably fail across namespaces, andcan be irritating to have to define with each new subscriber. Thus, itmay be easier to define your eventAggregator in a global module, thensubscribe directly to it instead of passing its reference along to eachnew ViewModel you call.</p></blockquote><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Module</span> <span class="hljs-keyword">Global</span><br>  <span class="hljs-keyword">Public</span> eventAggregator <span class="hljs-keyword">as</span> IEventAggregator<br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Module</span><br><br><span class="hljs-keyword">Class</span> Subscriber : <span class="hljs-keyword">Implements</span> IHandle(<span class="hljs-keyword">Of</span> MyEvent)<br><br>  <span class="hljs-keyword">Public</span> <span class="hljs-keyword">Sub</span> <span class="hljs-built_in">New</span>()<br>  <span class="hljs-keyword">Global</span>.eventAggregator.Subscribe(<span class="hljs-keyword">Me</span>)<br>  <span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br>  <br>  <span class="hljs-comment">&#x27;Public Sub Handle...</span><br><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Class</span><br><br></code></pre></td></tr></table></figure><p>11</p><blockquote><p>Make sure to keep the namespace for the <em>module</em> blank, sothat it can be used throughout the program.</p></blockquote><h3 id="发布者">发布者</h3><p>11</p><blockquote><p>Publishers must also get an instance of the IEventAggregator, butthey don't need to subscribe themselves - they only need to callIEventAggregator.Publish every time they want to publish an event, forexample:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>   <span class="hljs-keyword">private</span> IEventAggregator eventAggregator;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Publisher</span>(<span class="hljs-params">IEventAggregator eventAggregator</span>)</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.eventAggregator = eventAggregator;<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PublishEvent</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.eventAggregator.Publish(<span class="hljs-keyword">new</span> MyEvent());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>11</p><blockquote><p>Again, for VB.NET users, if you've set up the global module then youdon't need to pass the eventAggregator to the Publisher. You can justpublish directly to the global eventAggregator;</p></blockquote><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Class</span> Publisher<br><br>  <span class="hljs-keyword">Public</span> <span class="hljs-keyword">Sub</span> PublishEvent()<br>  <span class="hljs-keyword">Global</span>.eventAggregator.Publish(<span class="hljs-built_in">New</span> MyEvent())<br>  <span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br>  <br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Class</span><br></code></pre></td></tr></table></figure><h2 id="取订和弱绑定">取订和弱绑定</h2><p>11</p><blockquote><p>Because the IEventAggregator is weakly binding, subscribers don'tneed to unsubscribe themselves - the IEventAggregator won't retain them.It is however possible for a subscriber to unsubscribe itself if itwants - call</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEventAggregator.Unsubscribe(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><h3 id="同步发布和异步发布">同步发布和异步发布</h3><p>111</p><blockquote><p>The default <code>IEventAggregator.Publish</code> method publishesthe event synchronously. You can also call<code>PublishOnUIThread</code> to dispatch asynchronously to the UIthread, or <code>PublishWithDispatcher</code> and pass any action youwant to act as the dispatcher (this can be useful if writing your ownmethods on IEventAggregator).</p></blockquote><h2 id="频道">频道</h2><h1 id="属性通知类">属性通知类</h1><p>PropertyChangedBase 提供了用于引发通知的方法，被用作那些要实现INotifyPropertyChanged 接口的类型的基类。</p><blockquote><p>PropertyChangedBase is base class for types implementingINotifyPropertyChanged, and provides methods for raising PropertyChangednotifications.</p></blockquote><h2 id="引发通知">引发通知</h2><p>目的不同，引发通知的方法也不一样，最常用的方法是属性被赋值时引发通知。使用<code>PropertyChangedBase</code>自带的工具方法<code>SetAndNotify</code>，当字段被赋新值时，赋值操作才实际发生，并引发<code>PropertyChanged</code>事件通知，示例代码如下：</p><blockquote><p>There are a number of ways to raise PropertyChanged notifications,depending on what exactly you want to do.</p><p>The most common case is having a property raise a notification eachtime it's assigned to. PropertyChangedBase provides a nice utilitymethod to help: SetAndNotify. It takes, by reference, a field, and avalue to assign to the field. If the field's value != the value, theassignment happens, and a PropertyChanged notification is raised. Forexample:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _name;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name; &#125;<br>      <span class="hljs-keyword">set</span> &#123; SetAndNotify(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">this</span>._name, <span class="hljs-keyword">value</span>); &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>绑定属性前台代码如下：</p><blockquote><p>To connect to the object you have to put in the view:</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextBox</span> <span class="hljs-attr">Text</span>=<span class="hljs-string">&quot;&#123;Binding Name, UpdateSourceTrigger=PropertyChanged&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>由于C#版本不同，在当前属性中引发其它属性通知的方法也不同。C#6.0及以上版本推荐使用<code>nameof()</code>方法，该方法非常简单并可在编译期进行安全检查；C#6.0以下版本使用 lambda表达式，可能相对慢一点，也可在编译期进行安全检查。如果有需要，甚至可采用原始字符串的方式。具体可结合以下代码来理解：</p><blockquote><p>If you want to raise a PropertyChanged notification for a propertyother than the current one, there are a few ways of achieving that, too(depending on whether you're using C#6, or below). The preferred C# 6way is to use <code>nameof()</code>, as that is very cheap and providescompile-time safety. If you're using C# 5 or below, you can use anexpression: this is slower, but also gives compile-time safety. If you<em>really</em> want, you can use a raw string as well. See below:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _firstName;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _firstName; &#125;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span><br>      &#123;<br>         SetAndNotify(<span class="hljs-keyword">ref</span> _firstName, <span class="hljs-keyword">value</span>);<br><br>         <span class="hljs-comment">// Preferred if you&#x27;re using C# 6, as it provides compile-time safety</span><br>         <span class="hljs-keyword">this</span>.NotifyOfPropertyChange(<span class="hljs-keyword">nameof</span>(<span class="hljs-keyword">this</span>.FullName));         <br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _lastName;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _lastName; &#125;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span><br>      &#123;<br>         SetAndNotify(<span class="hljs-keyword">ref</span> _lastName, <span class="hljs-keyword">value</span>);<br><br>         <span class="hljs-comment">// Preferred for C# 5 and below, as it provides compile-time safety</span><br>         <span class="hljs-keyword">this</span>.NotifyOfPropertyChange(() =&gt; <span class="hljs-keyword">this</span>.FullName);<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> FirstName + <span class="hljs-string">&quot; &quot;</span> + LastName; &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关联通知其它属性的代码集中放到构造函数里，比如：</p><blockquote><p>You can also wire things together in the constructor, like this:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _firstName, _lastName;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.Bind(s =&gt; s.FirstName, (o, e) =&gt; NotifyOfPropertyChange(<span class="hljs-keyword">nameof</span>(FullName)));<br>      <span class="hljs-keyword">this</span>.Bind(s =&gt; s.LastName, (o, e) =&gt; NotifyOfPropertyChange(<span class="hljs-keyword">nameof</span>(FullName)));<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _firstName; &#125;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span> &#123; SetAndNotify(<span class="hljs-keyword">ref</span> _firstName, <span class="hljs-keyword">value</span>); &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _lastName; &#125;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span> &#123; SetAndNotify(<span class="hljs-keyword">ref</span> _lastName, <span class="hljs-keyword">value</span>); &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> FirstName + <span class="hljs-string">&quot; &quot;</span> + LastName; &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分配事件">分配事件</h2><p>默认情况下，<code>PropertyChanged</code>事件先在当前线程被引发，再由WPF 具体负责分配到 UI 线程。当然，直接在 UI线程中引发事件也没问题，<code>PropertyChangedBase</code>有一个名为<code>PropertyChangedDispatcher</code>的属性，该属性有一个名为<code>Execute.DefaultPropertyChangedDispatcher</code>的默认委托，将委托值设为<code>Execute.OnUIThread</code>即可。改变<code>PropertyChangedBase</code>所有子类的事件引发方式应重写<code>Configure</code>函数，示例代码如下：</p><blockquote><p>By default, PropertyChanged events are raised on the current thread(and WPF takes care of dispatching them to the UI thread). If you dowant to change this, however, you can! PropertyChangedBase has aproperty called PropertyChangedDispatcher, which has an<code>Action&lt;Action&gt;</code>, and defaults toExecute.DefaultPropertyChangedDispatcher (which you can assign) (whichhas the value <code>a =&gt; a()</code>).</p><p>If you want to change this to execute on the UI thread, you can dothe following.</p><p>To change for all instances of PropertyChangedBase:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Bootstrapper</span> : <span class="hljs-title">Bootstrapper</span>&lt;<span class="hljs-title">MyRootViewModel</span>&gt;<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">base</span>.Configure();<br>      Execute.DefaultPropertyChangedDispatcher = Execute.OnUIThread;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对单独子类的示例代码如下：</p><blockquote><p>To change for just once instance of PropertyChangedBase:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.PropertyChangedDispatcher = Execute.OnUIThread;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="propertychanged.fody包">PropertyChanged.Fody包</h2><p><ahref="https://github.com/Fody/PropertyChanged">PropertyChanged.Fody</a>是一个非常神奇的nuget包，它能在编译期自动将用于引发<code>PropertyChanged</code>通知的代码注入到相关属性中，这样就使得代码整体很简洁。同时能够自行识别哪些属性需要引发通知，示例代码如下：</p><blockquote><p><ahref="https://github.com/Fody/PropertyChanged">PropertyChanged.Fody</a>is a fantastic package, which injects code at compile-time toautomatically raise PropertyChanged notifications for your properties,allowing you to write very concise code. It will also figure outdependencies between your properties and raise notificationsappropriately for example:</p></blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName &#123; <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> String.Format(<span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, <span class="hljs-keyword">this</span>.FirstName, <span class="hljs-keyword">this</span>.LastName); &#125; &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethod</span>()</span><br>   &#123;<br>      <span class="hljs-comment">// PropertyChanged notifications are automatically raised for both FirstName and FullName</span><br>      <span class="hljs-keyword">this</span>.FirstName = <span class="hljs-string">&quot;Fred&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>PropertyChangedBase</code>也注意与<code>Fody.PropertyChanged</code>的集成，实际采用<code>PropertyChangedDispatcher</code>引发通知。因此，<code>Screen</code>、<code>ValidatingModelBase</code>或<code>PropertyChangedBase</code>的子类使用<code>Fody.PropertyChanged</code>无需任何特别代码。</p><blockquote><p>PropertyChangedBase also takes care to integrate with<code>Fody.PropertyChanged</code>. Notifications raised by<code>Fody.PropertyChanged</code> are raised using the<code>PropertyChangedDispatcher</code>.</p><p>Therefore you do not need to do anything special in order to use<code>Fody.PropertyChanged</code> with any subclass of<code>Screen</code>, <code>ValidatingModelBase</code>, or<code>PropertyChangedBase</code>.</p></blockquote><h1 id="可绑定集合">可绑定集合</h1><h2 id="概述">概述</h2><p><code>BindableCollection&lt;T&gt;</code>集合类是<code>ObservableCollection</code>的子类，其实例一般用作ItemsControl 族控件的数据源（增、减元素时 View可以得到通知）。该集合类还新增了两个很有用的特性：</p><ul><li>新增方法<code>AddRange</code>, <code>RemoveRange</code> 和<code>Refresh</code></li><li>线程安全</li></ul><blockquote><p><code>BindableCollection&lt;T&gt;</code> is a subclass of <ahref="http://msdn.microsoft.com/en-us/library/ms668604(v=vs.110).aspx"><code>ObservableCollection</code></a>.It's the class to use if you have a collection of something in yourViewModel, and want to use it as the <code>ItemsSource</code> / etc forsomething in your View (and have the View be notified whenever an itemis added to / removed from that collection).</p><p>However, it adds a couple of useful extra features:</p><ul><li>New <code>AddRange</code>, <code>RemoveRange</code>, and<code>Refresh</code> methods</li><li>Is thread-safe</li></ul></blockquote><h2 id="新方法">新方法</h2><p><code>ObservableCollection&lt;T&gt;</code>集合增加元素时需手动迭代每个元素并多次调用<code>collection.Add(element)</code>方法，如此就会引发大量新增元素事件。通过新增的方法<code>AddRange</code>和<code>RemoveRange</code>，可以一次性批量增、减元素，同时只引发一次事件。</p><p><code>Refresh</code>方法不会改变集合，它只是触发<code>PropertyChanged</code>和<code>CollectionChanged</code> 事件，通知 UI其绑定的集合发生了变化，请 UI元素重载数据。尽管该方法很有用，但大多数场合都用不到。</p><blockquote><p><code>ObservableCollection&lt;T&gt;</code> is missing a couple ofvery useful methods: <code>AddRange</code> and <code>RemoveRange</code>.These do pretty much what you'd expect, allowing you to add a remove arange of elements at once, without having to manually iterate over eachelement and calling <code>collection.Add(element)</code> on each (whileraising lots of events for each element added). <code>AddRange</code>and <code>RemoveRange</code> will raise one set of events per rangeadded/removed only.</p><p><code>Refresh</code> is a convenience. It does not modify thecollection in any way, but does cause the <code>PropertyChanged</code>and <code>CollectionChanged</code> events to be fired, indicating to anyUI elements that the collection has been modified and that they shouldreload their data. It's not often needed, but when it is it's<em>really</em> needed.</p></blockquote><h2 id="线程安全">线程安全</h2><p>线程安全的实现方法是将集合元素的增加、删除、清空、重置等操作分配到的UI 线程，具体分配工作由<code>Execute.OnUIThreadSync</code>方法完成，也就是说：</p><ul><li>这些都是同步操作，即方法在动作完成后才返回；</li><li><code>PropertyChanged</code>和<code>CollectionChanged</code>事件总是由 UI 线程引发；</li><li>？？？</li></ul><p>属性相关的操作总是在 UI 线程中完成，因此事件也由 UI线程引发。基于此，<code>BindableCollection&lt;T&gt;</code>移除了<code>PropertyChangedDispatcher</code>、<code>CollectionChangedDispatcher</code>属性，在<code>PropertyChangedBase</code>中这些属性仍存在。</p><blockquote><p>Thread safety is achieved by dispatching all actions (adds, removes,clear, reset, etc) to the UI thread. The dispatch uses<code>Execute.OnUIThreadSync</code>, which means that:</p><ul><li>These operations are synchronous: the method being called won'treturn until the action has been completed.</li><li>They're free if you're already on the UI Thread - the operation willbe carried out synchronously in this case.</li><li>All <code>PropertyChanged</code> and <code>CollectionChanged</code>events are always raised on the UI thread.</li></ul><p>That last point means that there is no<code>PropertyChangedDispatcher</code> property on<code>BindableCollection&lt;T&gt;</code>, as there is with<code>PropertyChangedBase</code> - the event is always raised on the UIthread, since the operation the property relates to is always performedon the UI thread. Similarly, there's no<code>CollectionChangedDispatcher</code> concept.</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>编程</tag>
      
      <tag>C#</tag>
      
      <tag>MVVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dapper框架非官方中文文档</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/Dapper%E6%A1%86%E6%9E%B6%E9%9D%9E%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/Dapper%E6%A1%86%E6%9E%B6%E9%9D%9E%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<p>Dapper 是一款 .Net 平台下的微型 ORM框架，特点是：轻量、高效、简单、灵活并适用于 SQLServer、SQLite、MySQL等多款数据库。</p><p>Dapper 以 NuGet 包的形式提供，其扩展了 IDbConnection 接口的方法。</p><h2 id="方法">方法</h2><h3 id="query方法强类型返回值">Query方法：强类型返回值</h3><p>方法原型如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">Query</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> IDbConnection cnn,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-built_in">string</span> sql,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-built_in">object</span> param = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               IDbTransaction transaction = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-built_in">bool</span> buffered = <span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-built_in">int</span>? commandTimeout = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               CommandType? commandType = <span class="hljs-literal">null</span></span>)</span><br></code></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> Guid Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span>? Weight &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> IgnoredProperty &#123; <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125; &#125;  <span class="hljs-comment">// 被忽略的字段直接返回固定值</span><br>&#125;<br><br><span class="hljs-keyword">var</span> guid = Guid.NewGuid();<br><span class="hljs-keyword">var</span> dog = connection.Query&lt;Dog&gt;(<span class="hljs-string">&quot;SELECT Age = @Age, Id = @Id&quot;</span>,<br>                <span class="hljs-keyword">new</span> &#123; Age = (<span class="hljs-built_in">int</span>?)<span class="hljs-literal">null</span>, Id = guid &#125;);<br></code></pre></td></tr></table></figure><h3 id="query方法动态类型返回值">Query方法：动态类型返回值</h3><p>方法原型如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IEnumerable&lt;<span class="hljs-built_in">dynamic</span>&gt; <span class="hljs-title">Query</span> (<span class="hljs-params"><span class="hljs-keyword">this</span> IDbConnection cnn, </span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-built_in">string</span> sql,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-built_in">object</span> param = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               IDbTransaction transaction = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-built_in">bool</span> buffered = <span class="hljs-literal">true</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-built_in">int</span>? commandTimeout = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               CommandType? commandType = <span class="hljs-literal">null</span></span>)</span><br></code></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> rows = connection.Query(<span class="hljs-string">&quot;SELECT 1 A, 2 B UNION ALL SELECT 3, 4&quot;</span>).AsList();<br></code></pre></td></tr></table></figure><h3 id="excute方法返回受影响行数">Excute方法：返回受影响行数</h3><p>Excute 方法返回受影响的行数，一般用于增、删、改操作。</p><p>方法原型如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Execute</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IDbConnection cnn,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-built_in">string</span> sql,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-built_in">object</span> param = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            IDbTransaction transaction = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-built_in">int</span>? commandTimeout = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            CommandType? commandType = <span class="hljs-literal">null</span></span>)</span><br></code></pre></td></tr></table></figure><p>示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> count = connection.Execute(<span class="hljs-string">@&quot;</span><br><span class="hljs-string">      SET NOCOUNT ON</span><br><span class="hljs-string">      CREATE TABLE #t(i int)</span><br><span class="hljs-string">      SET NOCOUNT OFF</span><br><span class="hljs-string">      INSERT #t</span><br><span class="hljs-string">      SELECT @a a UNION ALL SELECT @b</span><br><span class="hljs-string">      SET NOCOUNT ON</span><br><span class="hljs-string">      DROP TABLE #t&quot;</span>, <br>      <span class="hljs-keyword">new</span> &#123;a=<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span> &#125;);<br></code></pre></td></tr></table></figure><h3 id="excute方法反复执行">Excute方法：反复执行</h3><p>该特性支持反复执行同一 SQL语句，传递对象数组或对象集合（实现了<code>IEnumerable&lt;T&gt;</code>集合）作为参数，常用于批量插数据。</p><p>示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 示例1</span><br><span class="hljs-keyword">var</span> count = connection.Execute(<span class="hljs-string">@&quot;INSERT MyTable VALUES (@a, @b)&quot;</span>,<br>    <span class="hljs-keyword">new</span>[] &#123; <span class="hljs-keyword">new</span> &#123; a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span> &#125;, <span class="hljs-keyword">new</span> &#123; a = <span class="hljs-number">2</span>, b = <span class="hljs-number">2</span> &#125;, <span class="hljs-keyword">new</span> &#123; a = <span class="hljs-number">3</span>, b = <span class="hljs-number">3</span> &#125; &#125;);<br><span class="hljs-comment">// 示例2</span><br><span class="hljs-keyword">var</span> foos = <span class="hljs-keyword">new</span> List&lt;Foo&gt;<br>&#123;<br>    <span class="hljs-keyword">new</span> Foo &#123; A = <span class="hljs-number">1</span>, B = <span class="hljs-number">1</span> &#125;,<br>    <span class="hljs-keyword">new</span> Foo &#123; A = <span class="hljs-number">2</span>, B = <span class="hljs-number">2</span> &#125;,<br>    <span class="hljs-keyword">new</span> Foo &#123; A = <span class="hljs-number">3</span>, B = <span class="hljs-number">3</span> &#125;<br><br>&#125;;<br><span class="hljs-keyword">var</span> count = connection.Execute(<span class="hljs-string">@&quot;INSERT MyTable(colA, colB) VALUES (@a, @b)&quot;</span>, foos);<br>Assert.Equal(foos.Count, count);<br></code></pre></td></tr></table></figure><h2 id="参数">参数</h2><h3 id="参数化查询">参数化查询</h3><p>SQL 语句采用匿名对象作为参数可实现参数化查询，且与 SQL Server的参数化查询语法一致。参数化查询有两个好处：</p><ol type="1"><li>防止 SQL 注入</li><li>提高代码复用率</li></ol><p>111111111111111111111111111111111111111111</p><h3 id="单个参数">单个参数</h3><p>Dapper 采用匿名对象作为查询参数，对象属性应与 SQL语句中@符号打头的参数名称一致。参数化查询可以有效地抵御<strong>SQL注入攻击</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> rows = connection.Query&lt;User&gt;(<span class="hljs-string">&quot;SELECT * FROM user WHERE username = @UserName And password = @PassWord&quot;</span>,<br>   <span class="hljs-keyword">new</span> &#123;UserName = <span class="hljs-string">&quot;admin&quot;</span>, PassWord = <span class="hljs-string">&quot;xxxxxxx&quot;</span>&#125;)  <span class="hljs-comment">// UserName属性值给到参数@UserName, PassWord属性值给到参数@PassWord </span><br></code></pre></td></tr></table></figure><h3 id="多条查询">多条查询</h3><p>Dapper同时支持<code>IEnumerable&lt;T&gt;</code>类型的多参数查询，集合中的元素被拆开后依次传入参数会被自动展开。</p><p>原始代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> rows = connection.Query&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-string">&quot;SELECT * FROM (SELECT 1 AS Id UNION ALL SELECT 2 UNION ALL SELECT 3) AS x WHERE Id IN @Ids&quot;</span>,<br>  <span class="hljs-keyword">new</span> &#123; Ids = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125; &#125;);<br></code></pre></td></tr></table></figure><p>展开后代码如下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">SELECT * FROM (SELECT <span class="hljs-number">1</span> AS Id UNION ALL SELECT <span class="hljs-number">2</span> UNION ALL SELECT <span class="hljs-number">3</span>) <span class="hljs-function">AS x WHERE Id <span class="hljs-title">IN</span> (<span class="hljs-params">@Ids1, @Ids2, @Ids3</span>)&quot; <span class="hljs-comment">// @Ids1 = 1 , @Ids2 = 2 , @Ids2 = 3</span></span><br></code></pre></td></tr></table></figure><h2 id="结果">结果</h2><h3 id="一对多映射">一对多映射</h3><p>Dapper支持将一条数据库记录映射到多个对象，这个关键特性可以减少额外查询。</p><p>相关联的两个实体类如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Title &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Content &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> User Owner &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>// TODO</p><h3 id="区别映射">区别映射</h3><p>一般情况下，同一个表的返回数据都被映射到同一个实体类，但偶尔也需要映射到不同的实体类，这时<code>IDataReader.GetRowParser</code>方法就派上用场了。</p><p>Shapes 表包含 Id、Type 和 Data 三个字段，依据 Type 字段值分别映射给<code>Circle</code>、<code>Square</code>、<code>Triangle</code>三个实体类。</p><p>示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> shapes = <span class="hljs-keyword">new</span> List&lt;IShape&gt;();<br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> reader = connection.ExecuteReader(<span class="hljs-string">&quot;SELECT * FROM Shapes&quot;</span>))<br>&#123;<br>    <span class="hljs-comment">// Generate a row parser for each type you expect.</span><br>    <span class="hljs-comment">// The generic type &lt;IShape&gt; is what the parser will return.</span><br>    <span class="hljs-comment">// The argument (typeof(*)) is the concrete type to parse.</span><br>    <span class="hljs-keyword">var</span> circleParser = reader.GetRowParser&lt;IShape&gt;(<span class="hljs-keyword">typeof</span>(Circle));<br>    <span class="hljs-keyword">var</span> squareParser = reader.GetRowParser&lt;IShape&gt;(<span class="hljs-keyword">typeof</span>(Square));<br>    <span class="hljs-keyword">var</span> triangleParser = reader.GetRowParser&lt;IShape&gt;(<span class="hljs-keyword">typeof</span>(Triangle));<br><br>    <span class="hljs-keyword">var</span> typeColumnIndex = reader.GetOrdinal(<span class="hljs-string">&quot;Type&quot;</span>);<br><br>    <span class="hljs-keyword">while</span> (reader.Read())<br>    &#123;<br>        IShape shape;<br>        <span class="hljs-keyword">var</span> type = (ShapeType)reader.GetInt32(typeColumnIndex);<br>        <span class="hljs-keyword">switch</span> (type)<br>        &#123;<br>            <span class="hljs-keyword">case</span> ShapeType.Circle:<br>            shape = circleParser(reader);<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ShapeType.Square:<br>            shape = squareParser(reader);<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ShapeType.Triangle:<br>            shape = triangleParser(reader);<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-literal">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotImplementedException();<br>        &#125;<br><br>      shapes.Add(shape);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他">其他</h2><h3 id="多参数重复执行">多参数重复执行</h3><p>Dapper支持一次函数调用中执行多条查询语句，并将返回结果分别映射到对应的实体类。</p><p>示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> sql =<br><span class="hljs-string">@&quot;</span><br><span class="hljs-string">SELECT * FROM Customers WHERE CustomerId = @id</span><br><span class="hljs-string">SELECT * FROM Orders WHERE CustomerId = @id</span><br><span class="hljs-string">SELECT * FROM Returns WHERE CustomerId = @id&quot;</span>;<br><br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> multi = connection.QueryMultiple(sql, <span class="hljs-keyword">new</span> &#123;id=selectedId&#125;))<br>&#123;<br>   <span class="hljs-keyword">var</span> customer = multi.Read&lt;Customer&gt;().Single();<br>   <span class="hljs-keyword">var</span> orders = multi.Read&lt;Order&gt;().ToList();<br>   <span class="hljs-keyword">var</span> returns = multi.Read&lt;Return&gt;().ToList();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字面量替换">字面量替换</h3><p>// TODO</p><h3 id="流式读取">流式读取</h3><p>首先了解一下数据适配器 <strong>SqlDataAdapter</strong> 和 数据读取器<strong>SqlDataReader </strong>的主要区别：</p><ol type="1"><li>SqlDataAdapter在建立数据库连接后一次性读取所有查询数据到内存，然后就关闭了连接。适用于少量查询结果。</li><li>SqlDataReader在建立数据库连接后流式读取数据，待发送缓存装满再返回查询数据，如此重复多次直至所有数据被返回。期间数据库连接一直处于open 状态，且被当前 SqlDataReader 独占。适用于大量查询结果。</li></ol><p>Dapper默认一次性读取所有查询结果，这样有利于最小化共享锁的占用时长和数据库的连接时长。这种读取方式的弊端也很明显：返回大量结果时内存耗费巨大。未解决此弊端，调用<code>Query</code>方法时<code>buffered</code>形参应传递<code>false</code>，改用流式读取方式。</p><h3 id="存储过程">存储过程</h3><p>Dapper 支持使用存储过程。</p><p>示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> user = cnn.Query&lt;User&gt;(<span class="hljs-string">&quot;spGetUser&quot;</span>, <span class="hljs-keyword">new</span> &#123;Id = <span class="hljs-number">1</span>&#125;,<br>        commandType: CommandType.StoredProcedure).SingleOrDefault();<br></code></pre></td></tr></table></figure><p>花哨点的写法如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> DynamicParameters();<br>p.Add(<span class="hljs-string">&quot;@a&quot;</span>, <span class="hljs-number">11</span>);<br>p.Add(<span class="hljs-string">&quot;@b&quot;</span>, dbType: DbType.Int32, direction: ParameterDirection.Output);<br>p.Add(<span class="hljs-string">&quot;@c&quot;</span>, dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);<br><br>cnn.Execute(<span class="hljs-string">&quot;spMagicProc&quot;</span>, p, commandType: CommandType.StoredProcedure);<br><br><span class="hljs-keyword">var</span> b = p.Get&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-string">&quot;@b&quot;</span>);<br><span class="hljs-keyword">var</span> c = p.Get&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-string">&quot;@c&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="varchar-类型支持">varchar 类型支持</h3><p>Dapper 支持 varchar 类型，当对 varchar 类型字段执行<code>WHERE</code> 字句时，应这样传递参数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> things = Query&lt;Thing&gt;(<span class="hljs-string">&quot;SELECT * FROM Thing WHERE Name = @Name&quot;</span>, <span class="hljs-keyword">new</span> &#123;Name = <span class="hljs-keyword">new</span> DbString &#123; Value = <span class="hljs-string">&quot;abcde&quot;</span>, IsFixedLength = <span class="hljs-literal">true</span>, Length = <span class="hljs-number">10</span>, IsAnsi = <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><p>正如上文所述，Dapper默认一次性缓存所有查询结果，这样可加快映射到实体类的进度。当前缓存机制依赖于<code>ConcurrentDictionary</code>对象，一次性的查询语句会经常刷新该对象缓存。另外，如果没有查询字句的约束，一下子取回整表数据可能造成内存暴涨。</p><p>Dapper 之所以简约是因为剥离了传统 ORM框架的很多功能。即便如此，也能应付大约95%的应用场景，千万不要期望本框架能处理所有问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>编程</tag>
      
      <tag>C#</tag>
      
      <tag>ORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解作用域</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/C/%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/C/%E7%90%86%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<p>对于任何一门编程语言，作用域（scope）都是极为重要的概念。由于设计缺陷，javascript天生没有块级作用域，这导致了变量提升等一系列问题，因此 ES6不得不引入了<code>let</code>关键字进行弥补。下面这段 js代码可以正常运行，换作C++、java等语言一定编译不过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">function <span class="hljs-title function_">say</span><span class="hljs-params">(year)</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">2021</span> === year) &#123;<br>    var msg = <span class="hljs-string">&quot;hello 2021&quot;</span>;<br>  &#125;<br>  <span class="hljs-comment">// 当前函数作用域不存在msg变量</span><br>  console.<span class="hljs-built_in">log</span>(msg);<br>&#125;<br><br>say(<span class="hljs-number">2021</span>);<br></code></pre></td></tr></table></figure><h2 id="作用域的定义">作用域的定义</h2><p>作用域即变量在代码结构中的作用范围，是变量的一个关键属性。作用域从空间的维度来描述对象，属于编译期的概念；而生命周期是从时间维度来描述，属于运行期的概念。C++作为一门现代、严谨的面向对象编程语言，其作用域划分很完善，从小到大可分为：块级作用域、函数作用域、类作用域、命名空间作用域、全局作用域。作用域的访问原则为：</p><ol type="1"><li><p><strong>内层作用域可访问外层作用域，反之不行</strong>；</p></li><li><p><strong>内层作用域优先级高于外层作用域</strong>。</p></li><li><p><strong>同层作用域之间不可见</strong></p></li></ol><p>下面介绍一下面向过程言和面向对象语言都应该具备的三个基本作用域：语句块作用域、函数作用域和全局作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 全局作用域</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> YEAR = <span class="hljs-number">2021</span>; <br><br><span class="hljs-keyword">namespace</span> School<br>&#123;<br>    <span class="hljs-comment">// 命名空间作用域 </span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br>    &#123;<br>    <span class="hljs-comment">// 类作用域</span><br>    <span class="hljs-keyword">public</span>:<br>       <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPassed</span><span class="hljs-params">(<span class="hljs-type">int</span> scores)</span> <span class="hljs-comment">// 函数作用域</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-type">bool</span> passed = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 函数作用域</span><br>            <span class="hljs-keyword">if</span> (scores &gt; <span class="hljs-number">90</span>)<br>            &#123;<br>                string encouragement = <span class="hljs-string">&quot;good good study, day day up&quot;</span>; <span class="hljs-comment">// 块级作用域</span><br>                passed = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> passed;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语句块作用域">语句块作用域</h2><p>块级作用域是最小的作用域，一对花括号形成的范围就是一个块级作用域。块级作用域不一定是<code>if</code>、<code>for</code>等控制结构的控制体，即使括起来的一句单独的代码也是一个新的块级作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-comment">// 块级作用域</span><br>        string slogan = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 函数级作用域</span><br>    cout &lt;&lt; slogan &lt;&lt; endl; <span class="hljs-comment">// 报错: 变量未定义</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码至少说明了两个事实：</p><ul><li>块级与函数不是同一个作用域</li><li>外层作用域无法访问内层作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string slogan = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#123;<br>        <span class="hljs-comment">// 当前作用域没有声明slogan变量,就去上级作用域查找</span><br>        cout &lt;&lt; slogan &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>得益于块级作用域的存在，同一函数体内的多个<code>for</code>循环可以声明同名控制变量而不会发生命名冲突。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    &#123;<br>        ...<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数作用域">函数作用域</h2><p>同一作用域的变量不可重名。函数的局部变量与形式变量（形参）同属一个作用域，因此这段代码编译不过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPassed</span><span class="hljs-params">(<span class="hljs-type">int</span> scores)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> scores = scores; <span class="hljs-comment">// 局部变量与形参重名</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局作用域">全局作用域</h2><p>当前文件的任何位置都能访问到全局作用域内声明的变量（也就是全局变量），全局变量一般声明在文件顶部，与<code>#include</code>、<code>using</code>等指令同级。</p><p>C++允许局部变量与全局变量重名，但声明了同名的局部变量后，全名变量在该局部变量的作用域内将被屏蔽。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> year = <span class="hljs-number">2021</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123; <span class="hljs-comment">// 块级作用域</span><br>        <span class="hljs-type">int</span> year;<br>        year = <span class="hljs-number">1974</span>;<br>        cout &lt;&lt; year &lt;&lt; endl;  <span class="hljs-comment">// =&gt; 1974;</span><br>    &#125;<br>    <span class="hljs-comment">// 函数作用域</span><br>    cout &lt;&lt; year &lt;&lt; endl; <span class="hljs-comment">// =&gt; 2021;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>遨游码海</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从C代码到二进制文件</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/C/%E4%BB%8EC%E4%BB%A3%E7%A0%81%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/C/%E4%BB%8EC%E4%BB%A3%E7%A0%81%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>诸如VisualStudio这类集成开发环境使得编程越发便捷，但也失去很多“捯饬”的乐趣。我很喜欢侯捷先生的一段话，简单朴素却又发人深省。</p><blockquote><p>使用一个东西，却不明白它的道理，<em>不高明</em>！</p></blockquote><p>当然，凡事没有绝对。发一封电子邮件却要事先把CPU的工作原理搞清楚，不把人逼疯才怪！</p><p>从C源代码到可执行程序一般经历四个主要过程：预处理(preprocess)、编译(compile)、汇编(assemble)、链接(link)，下面使用gcc工具详细剖析下。在集成开发环境中，这4个过程直接合为<strong>构建</strong>（Build）操作。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/1_wHKe6W4opLmk6pb7sxZz6w.png" /></p><p>gcc(GNU CCompiler)是一套开源、跨平台的C/C++编译器，它是Linux平台编译器的事实标准。gcc通过后台调用各子程序完成各项具体任务，比如汇编子程序as、链接子程序ldd。本文中用到的的命令如下：</p><ul><li><p>预处理</p><p>gcc默认不保存预处理后的文件（很少用到），可使用重定向保存结果。</p><p>-E</p><blockquote><p>Preprocess only; do not compile, assemble or link.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -E main.cpp &gt; main.i<br></code></pre></td></tr></table></figure></li><li><p>编译</p><p>-S</p><blockquote><p>Compile only; do not assemble or link.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -S main.cpp<br></code></pre></td></tr></table></figure></li><li><p>编译+汇编</p><p>-c</p><blockquote><p>Compile and assemble, but do not link.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c main.cpp<br></code></pre></td></tr></table></figure></li><li><p>AIO</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc main.cpp base.cpp<br></code></pre></td></tr></table></figure></li></ul><h2 id="预处理">预处理</h2><h3 id="过程描述">过程描述</h3><p>预处理的主要任务是处理源码中除编译器指令<code>#pragma</code>外其它以“#”打头的指令，具体如下：</p><ul><li><p>宏替换</p><p>替换<code>#define</code>自定义宏及编译器内置调试宏，比如将<code>PI</code>替换成<code>3.1415926</code></p></li><li><p>文件包含</p><p>插入头文件的内容到当前文件，注意文件包含是递归进行的，即<code>main.c</code>包含了<code>utility.h</code>，<code>utility.h</code>包含了<code>base.h</code>，最终<code>base.h</code>也会出现在<code>main.c</code>预编译结果中，可能带来的问题稍后再议。</p><blockquote><p>带后缀名的<strong>iostream.h</strong>和不带后缀名的<strong>iostream</strong>是不同的两个头文件，C++程序建议使用<strong>iostream</strong>，后者引入了命名空间且更现代、更安全。</p></blockquote></li><li><p>条件编译</p><p>根据<code>#if、#ifndef、#ifdef、#endif、#undef</code>条件编译指令，保留部分代码，抛弃一些代码，以实现版本控制、防止重复包含等目的。</p></li><li><p>添加行号和文件名标识符</p><p>供编译器生成pdb调试文件及输出错误或警告的具体位置。比如<code>main.c</code>包含的头文件<code>base.h</code>中<code>int</code>关键字笔误，编译器给出了详细的错误定位，以便查找修改。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210915211625676.png"alt="image-20210915211625676" /><figcaption aria-hidden="true">image-20210915211625676</figcaption></figure></li><li><p>移除注释</p><p>移除所有块注释和行注释，因此注释的多少并不不影响可执行文件的体积。</p></li></ul><h3 id="代码清单">代码清单</h3><p><em>mian.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;base.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.1415926</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 地球体积</span><br>    <span class="hljs-type">double</span> earth = <span class="hljs-number">4</span> / <span class="hljs-number">3</span> * PI * <span class="hljs-number">6378.137e3</span> * <span class="hljs-number">6378.137e3</span> * <span class="hljs-number">6378.137e3</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>base.h</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoveWithFreedom</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>处理后的文件内容如下：</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210904212117898.png" /></p><h3 id="防卫式声明">防卫式声明</h3><p>设想这么一个场景，main.cpp直接包含了animal.h和person.h，person.h也包含了animal.h，这就意味着main.cpp包含animal.h两次，造成animal.h声明的变量在main.cpp中重复声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;animal.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// person.h</span><br><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;animal.h&quot;</span></span><br><br><span class="hljs-comment">// animal.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>预处理阶段只是简单的替换，因此此阶段不会报错，但后续必然无法通过编译。为了避免这种情况，头文件应采用<strong>防卫式声明</strong>。因为部分编译器不兼容，所以不推荐使用<code>#pragma once</code>指令的方法，推荐方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __animal__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __animal__</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="编译">编译</h2><p>编译是整个过程最核心、最复杂的步骤，可分为两个子阶段：预编译和优化。</p><h3 id="预编译">预编译</h3><p>预编译阶段执行词法分析、语法分析、语义分析并生成汇编文件。预编译大致流程如下：</p><blockquote><p>基本词法元素包括：标识符（identifier）、关键字（keyword）、操作符（operator）、分隔符（delimiter）、字面量（literal）。</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210915211033509.png"alt="image-20210915211033509" /><figcaption aria-hidden="true">image-20210915211033509</figcaption></figure><ol type="1"><li>词法分析将整个源代码拆分成独立的记号，然后给这些记号归类、编码。当碰到无法归类的记号时，编译器就会报错，典型例子就是不合法的变量名。</li></ol><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210913221603348.png" /></p><ol start="2" type="1"><li><p>语法分析根据语法规则识别出语法单位（赋值语句、条件语句之类），并检查语法单位结构的正确性。诸如行末缺少分号等错误都会被查出。</p></li><li><p>语义分析是对语法单位进行静态的语义审查（比如声明与类型是否匹配），动态的在运行时才可确定（比如除0的错误），分析其含义，下一步就会用另一种接近目标语言（比如汇编语言）或直接用目标语言去描述这个含义。此阶段要求语句的含义和使用规则正确。</p></li></ol><h3 id="优化">优化</h3><p>优化目的是提高代码执行效率，过程非常复杂、艰深。常见优化有：将乘法循环转换为多次加法循环；避免函数频繁调用造成入栈、出栈开销过大，使用内联直接将函数调用替换为函数体本身；等等。</p><h3 id="跨平台">跨平台</h3><p>CPU架构不同指令集可能不同。即使同一份代码，在X86和ARM架构下生成的汇编代码就不同，这直接造成了纯编译型语言无法实现跨平台。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210905222202793.png"alt="image-20210905222202793" /><figcaption aria-hidden="true">image-20210905222202793</figcaption></figure><h2 id="汇编">汇编</h2><p>汇编语言实际就是用助记符代替机器指令，用符号代替内存地址。汇编过程只是机械地将每一条汇编指令翻译成相对应的机器指令，通俗点讲就是将人看的懂的汇编代码转换成机器看的懂的二进制代码，因此过程并不复杂。汇编生成后缀名为.o的目标文件（objectfile）。</p><h2 id="链接">链接</h2><h3 id="重定位">重定位</h3><p>链接是整个流程的最后一步，主要任务是处理模块间的符号引用问题。如果当前文件引用了外部函数或全局变量，编译及汇编阶段无法确定其偏移量，只能暂保留原始符号。链接器将多个目标文件的各个段捆绑到一起后就能确定所有符号的最终段内偏移，这个过程称为重定位（Relocation）。CRT标准静态库也会打包到最终可执行程序中，文件大小对比见下图：</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210915221225990.png"alt="image-20210915221225990" /><figcaption aria-hidden="true">image-20210915221225990</figcaption></figure><p>以下示例代码中，main函数分别调用了内部的<code>foo</code>和<code>bar</code>函数，以及外部<code>help</code>函数、标准库函数<code>puts</code>，使用<code>gcc -c main.c</code>命令编译、汇编生成目标文件main.o。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;help.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    foo();<br>    bar();<br>    help();<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过命令<code>nm -n main.o</code>查看目标文件的符号信息，结果一目了然，内部函数都具有<strong>.text</strong>段内偏移地址，而<code>help</code>和<code>puts</code>函数显示为未定义的符号<strong>U</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210914224528225.png"alt="image-20210914224528225" /><figcaption aria-hidden="true">image-20210914224528225</figcaption></figure><blockquote><p>nm工具可列出目标文件的符号信息，包括：段内偏移地址，段名，符号</p></blockquote><p>根据类型和时机不同，重定位分为三类：</p><ul><li>程序内部跨文件引用，链接时重定位（其它目标文件、静态库）</li><li>引用外部库文件，程序装载时重定位（静态调用动态链接库 #pragmacomment）</li><li>引用外部库文件，程序运行期重定位（动态调用动态链接库LoadLibrary）</li></ul><h3 id="符号表">符号表</h3><p>为了便于链接阶段重定位，汇编器在生成的目标文件中嵌入了一个符号表（sysmboltable），表里保存了两部分信息：</p><ul><li>该目标文件<strong>本身定义的</strong>函数和全局变量</li><li>该目标文件<strong>引用的外部</strong>函数和全局变量</li></ul><h3 id="入口函数">入口函数</h3><p>从代码角度而言，<code>main</code>是大家公认的入口函数，程序从硬盘映射到内存后应该从<code>main</code>函数的第一句代码开始执行，但是大家有没有想过：是谁给main函数传递了命令行参数？</p><p>事实上，程序被加载后，首先执行的是入口函数<code>mainCRTStartup</code>（针对MSVC控制台程序），随之控制权也由操作系统转移过来。接下来该函数需完成以下工作：</p><ol type="1"><li>初始化CRT库和程序运行环境，包括初始化堆、线程、IO、全局变量等；</li><li>调用main函数（可自定义）并传递命令行参数；</li><li>main函数执行完毕后，返回到入口函数，完成善后清理工作，包括销毁堆、关闭I/O、全局变量析构等；</li><li>呼叫操作系统结束进程。</li></ol><p>使用olldbg动态反汇编一个简单的C语言helloword程序，程序加载后停在了<code>0x0044125B</code>的位置，此处即调用了入口点函数<code>mainCRTStartup</code>。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210915223026614.png"alt="image-20210915223026614" /><figcaption aria-hidden="true">image-20210915223026614</figcaption></figure><h2 id="番外篇">番外篇</h2><p>节选了网上的一篇文章，比较全面的描述了PE文件的加载、运行过程：</p><blockquote><p>WinMain函数被执行之前，有一系列复杂的加载动作，还要执行一大段启动代码。运行程序MyApp.exe时，操作系统的加载程序首先为进程分配一个4GB的虚拟地址空间，然后把程序MyApp.exe所占用的磁盘空间作为虚拟内存映射到这个4GB的虚拟地址空间中。一般情况下，映射到虚拟地址空间中0X00400000的位置。加载一个应用程序所花的时间比想象的要少，因为加载一个PE文件并不是把整个文件一次性的从磁盘读到内存中，而是简单的做一下内存映射，因此映射一个大文件和映射一个小文件所花费的时间相差无几。当然，真正执行文件中的代码时，操作系统还是要把存在于磁盘上的虚拟内存中的代码交换到物理内存(RAM)中。但是，这种交换也不是把整个文件所占用的虚拟地址空间一次性的全部从磁盘交换到物理内存中，操作系统会根据需要和内存占用情况交换一页或多页。当然，这种交换是双向的，即存在于物理内存中的一部分当前没有被使用的页也可能被交换到磁盘中。接着，系统在内核中创建进程对象和主线程对象以及其它内容。然后操作系统的加载程序搜索PE文件中的输入表，加载所有应用程序所使用的动态链接库。动态链接库的加载与对应用程序的加载完全类似。</p><p>所有加载完成后，操作系统执行PE文件头部所指定地址（入口点）处的代码，开始应用程序主线程的执行。首先被执行的代码并不是MyApp.exe中的WinMain函数，而是被称为CRuntime startupcode的WinMainCRTStartup函数，该函数是链接时由链接程序附加到MyApp.exe中的。在MSVC下，链接器对控制台程序设置的入口函数是mainCRTStartup，mainCRTStartup 再调用main函数；对图形界面程序设置的入口函数是WinMainCRTStartup，WinMainCRTStartup 调用你自己写的 WinMain函数。具体设置哪个入口点函数由链接器的“/subsystem:”选项确定的，它告诉操作系统如何加载运行EXE文件。可指定四种方式：CONSOLE|WINDOWS|NATIVE|POSIX。</p><p>WinMainCRTStartup函数获得本进程的全部命令行指针和环境变量的指针，完成一些全局变量以及C运行时内存分配函数的初始化工作。如果使用C++，还要执行全局对象的构造函数。最后，WinMainCRTStartup函数调用WinMain函数，并传给WinMain函数的4个参数：hInstance、hPrevInstance、lpCmdline、nCmdShow。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C程序的内存布局</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/C/C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/C/C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>原文地址：<ahref="https://hackthedeveloper.com/memory-layout-c-program/">MemoryLayout Of A C Program</a></p><p>理解 C程序及其进程的内存布局对于程序员学习内存管理至关重要。Java、Python、C#这类高级语言由GC 自动释放堆内存，但 C 和 C++ 没有 GC机制，因此需要程序员手动申请、释放。C代码先被编译成可执行文件，运行后可执行文件被载入内存，然后 CPU开始逐条读取、执行指令。注意：在被载入前，可执行文件不占用内存空间。如果您想了解从C 代码到二进制文件的编译过程，可阅读此文章<ahref="https://hackthedeveloper.com/c-program-compilation-process/">CProgram Compilation Process - Source To Binary</a>。</p><p>C 程序的典型内存布局含以下几个区段：</p><ul><li><p>命令行参数</p></li><li><p>栈</p></li><li><p>堆</p></li><li><p>未初始化数据段（BSS）</p></li><li><p>已初始化数据段</p></li><li><p>代码段</p><p><imgsrc="https://hackthedeveloper.com/wp-content/uploads/2020/11/Memory-layout.png.webp" /></p></li></ul><p>按内存分配方式不同，上述区段可分为：</p><ol type="1"><li>静态内存区域：代码段、已初始化数据段、未初始化数据段</li><li>动态内存区域：堆、栈</li></ol><p>在编译期静态内存区域就已划分，动态内存区域必须等到程序跑起来才会形成。下面具体学习下各个区段。</p><h2 id="静态内存区域">静态内存区域</h2><p>静态内存区域由代码段、已初始化数据段和未初始化数据段组成。这些区段最初划分在可执行文件中，加载时再由操作系统加载器将其从硬盘映射到内存。</p><p>最简单的 C 程序代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>size </strong>是 Linux下用于查看目标文件、库文件和可执行文件中各个区段信息及其大小的工具。将上述代码编译后用该工具查看生成的可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc 1.c -o 1.out<br><br>$ size 1.out<br>text    data     bss     dec     hex filename<br>785     276       4      1065     429 1.out <br></code></pre></td></tr></table></figure><h3 id="代码段">代码段</h3><p>代码段是静态内存区域的核心段，该区段包含了程序的机器指令、常量和字面量，这些指令实现了程序的逻辑。</p><p>代码段在堆和数据段之下，可读、可执行。为了避免遭受<strong>堆栈溢出</strong>的破坏，防止代码被意外修改，代码段不可写。</p><p><strong>objdump </strong>是 Linux下反汇编目标文件和可执行文件的工具。以下反汇编代码中的<code>&lt;main&gt;</code>函数对应了示例代码中的<code>main</code>函数。限于篇幅原因，只截取了部分代码展示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ objdump -d 1.out<br><br><br>1.out:     file format elf32-littlearm<br><br><br>Disassembly of section .init:<br><br>0001029c &lt;_init&gt;:<br>   1029c:       e92d4008        push    &#123;r3, lr&#125;<br>   102a0:       eb00001d        bl      1031c &lt;call_weak_fn&gt;<br>   102a4:       e8bd8008        pop     &#123;r3, pc&#125;<br><br>Disassembly of section .plt:<br><br>000102a8 &lt;.plt&gt;:<br>   102a8:       e52de004        push    &#123;lr&#125;            ; (str lr, [sp, <span class="hljs-comment">#-4]!)</span><br>   102ac:       e59fe004        ldr     lr, [pc, <span class="hljs-comment">#4]    ; 102b8 &lt;.plt+0x10&gt;</span><br>   102b0:       e08fe00e        add     lr, pc, lr<br>   102b4:       e5bef008        ldr     pc, [lr, <span class="hljs-comment">#8]!</span><br>   102b8:       00010d48        .word   0x00010d48<br><br>000102bc &lt;__libc_start_main@plt&gt;:<br>   102bc:       e28fc600        add     ip, pc, <span class="hljs-comment">#0, 12</span><br>   102c0:       e28cca10        add     ip, ip, <span class="hljs-comment">#16, 20 ; 0x10000</span><br>   102c4:       e5bcfd48        ldr     pc, [ip, <span class="hljs-comment">#3400]!        ; 0xd48</span><br><br>000102c8 &lt;__gmon_start__@plt&gt;:<br>   102c8:       e28fc600        add     ip, pc, <span class="hljs-comment">#0, 12</span><br>   102cc:       e28cca10        add     ip, ip, <span class="hljs-comment">#16, 20 ; 0x10000</span><br>   102d0:       e5bcfd40        ldr     pc, [ip, <span class="hljs-comment">#3392]!        ; 0xd40</span><br><br>000102d4 &lt;abort@plt&gt;:<br>   102d4:       e28fc600        add     ip, pc, <span class="hljs-comment">#0, 12</span><br>   102d8:       e28cca10        add     ip, ip, <span class="hljs-comment">#16, 20 ; 0x10000</span><br>   102dc:       e5bcfd38        ldr     pc, [ip, <span class="hljs-comment">#3384]!        ; 0xd38</span><br><br>Disassembly of section .text:<br><br>000102e0 &lt;_start&gt;:<br>   102e0:       e3a0b000        mov     fp, <span class="hljs-comment">#0</span><br>   102e4:       e3a0e000        mov     lr, <span class="hljs-comment">#0</span><br>   102e8:       e49d1004        pop     &#123;r1&#125;            ; (ldr r1, [sp], <span class="hljs-comment">#4)</span><br>   102ec:       e1a0200d        mov     r2, sp<br>   102f0:       e52d2004        push    &#123;r2&#125;            ; (str r2, [sp, <span class="hljs-comment">#-4]!)</span><br>   102f4:       e52d0004        push    &#123;r0&#125;            ; (str r0, [sp, <span class="hljs-comment">#-4]!)</span><br>   102f8:       e59fc010        ldr     ip, [pc, <span class="hljs-comment">#16]   ; 10310 &lt;_start+0x30&gt;</span><br>   102fc:       e52dc004        push    &#123;ip&#125;            ; (str ip, [sp, <span class="hljs-comment">#-4]!)</span><br>   10300:       e59f000c        ldr     r0, [pc, <span class="hljs-comment">#12]   ; 10314 &lt;_start+0x34&gt;</span><br>   10304:       e59f300c        ldr     r3, [pc, <span class="hljs-comment">#12]   ; 10318 &lt;_start+0x38&gt;</span><br>   10308:       ebffffeb        bl      102bc &lt;__libc_start_main@plt&gt;<br>   1030c:       ebfffff0        bl      102d4 &lt;abort@plt&gt;<br>   10310:       0001044c        .word   0x0001044c<br>   10314:       000103d0        .word   0x000103d0<br>   10318:       000103ec        .word   0x000103ec<br><br>0001031c &lt;call_weak_fn&gt;:<br>   1031c:       e59f3014        ldr     r3, [pc, <span class="hljs-comment">#20]   ; 10338 &lt;call_weak_fn+0x1c&gt;</span><br>   10320:       e59f2014        ldr     r2, [pc, <span class="hljs-comment">#20]   ; 1033c &lt;call_weak_fn+0x20&gt;</span><br>   10324:       e08f3003        add     r3, pc, r3<br>   10328:       e7932002        ldr     r2, [r3, r2]<br>   1032c:       e3520000        cmp     r2, <span class="hljs-comment">#0</span><br>   10330:       012fff1e        bxeq    lr<br>   10334:       eaffffe3        b       102c8 &lt;__gmon_start__@plt&gt;<br>   10338:       00010cd4        .word   0x00010cd4<br>   1033c:       00000018        .word   0x00000018<br><br>00010340 &lt;deregister_tm_clones&gt;:<br>   10340:       e59f0018        ldr     r0, [pc, <span class="hljs-comment">#24]   ; 10360 &lt;deregister_tm_clones+0x20&gt;</span><br>   10344:       e59f3018        ldr     r3, [pc, <span class="hljs-comment">#24]   ; 10364 &lt;deregister_tm_clones+0x24&gt;</span><br>   10348:       e1530000        cmp     r3, r0<br>   1034c:       012fff1e        bxeq    lr<br>   10350:       e59f3010        ldr     r3, [pc, <span class="hljs-comment">#16]   ; 10368 &lt;deregister_tm_clones+0x28&gt;</span><br>   10354:       e3530000        cmp     r3, <span class="hljs-comment">#0</span><br>   10358:       012fff1e        bxeq    lr<br>   1035c:       e12fff13        bx      r3<br>   10360:       00021024        .word   0x00021024<br>   10364:       00021024        .word   0x00021024<br>   10368:       00000000        .word   0x00000000<br><br>0001036c &lt;register_tm_clones&gt;:<br>   1036c:       e59f0024        ldr     r0, [pc, <span class="hljs-comment">#36]   ; 10398 &lt;register_tm_clones+0x2c&gt;</span><br>   10370:       e59f1024        ldr     r1, [pc, <span class="hljs-comment">#36]   ; 1039c &lt;register_tm_clones+0x30&gt;</span><br>   10374:       e0411000        sub     r1, r1, r0<br>   10378:       e1a01141        asr     r1, r1, <span class="hljs-comment">#2</span><br>   1037c:       e0811fa1        add     r1, r1, r1, lsr <span class="hljs-comment">#31</span><br>   10380:       e1b010c1        asrs    r1, r1, <span class="hljs-comment">#1</span><br>   10384:       012fff1e        bxeq    lr<br>   10388:       e59f3010        ldr     r3, [pc, <span class="hljs-comment">#16]   ; 103a0 &lt;register_tm_clones+0x34&gt;</span><br>   1038c:       e3530000        cmp     r3, <span class="hljs-comment">#0</span><br>   10390:       012fff1e        bxeq    lr<br>   10394:       e12fff13        bx      r3<br>   10398:       00021024        .word   0x00021024<br>   1039c:       00021024        .word   0x00021024<br>   103a0:       00000000        .word   0x00000000<br><br>000103a4 &lt;__do_global_dtors_aux&gt;:<br>   103a4:       e92d4010        push    &#123;r4, lr&#125;<br>   103a8:       e59f4018        ldr     r4, [pc, <span class="hljs-comment">#24]   ; 103c8 &lt;__do_global_dtors_aux+0x24&gt;</span><br>   103ac:       e5d43000        ldrb    r3, [r4]<br>   103b0:       e3530000        cmp     r3, <span class="hljs-comment">#0</span><br>   103b4:       18bd8010        popne   &#123;r4, pc&#125;<br>   103b8:       ebffffe0        bl      10340 &lt;deregister_tm_clones&gt;<br>   103bc:       e3a03001        mov     r3, <span class="hljs-comment">#1</span><br>   103c0:       e5c43000        strb    r3, [r4]<br>   103c4:       e8bd8010        pop     &#123;r4, pc&#125;<br>   103c8:       00021024        .word   0x00021024<br><br>000103cc &lt;frame_dummy&gt;:<br>   103cc:       eaffffe6        b       1036c &lt;register_tm_clones&gt;<br><br>000103d0 &lt;main&gt;:<br>   103d0:       e52db004        push    &#123;fp&#125;            ; (str fp, [sp, <span class="hljs-comment">#-4]!)</span><br>   103d4:       e28db000        add     fp, sp, <span class="hljs-comment">#0</span><br>   103d8:       e3a03000        mov     r3, <span class="hljs-comment">#0</span><br>   103dc:       e1a00003        mov     r0, r3<br>   103e0:       e28bd000        add     sp, fp, <span class="hljs-comment">#0</span><br>   103e4:       e49db004        pop     &#123;fp&#125;            ; (ldr fp, [sp], <span class="hljs-comment">#4)</span><br>   103e8:       e12fff1e        bx      lr<br></code></pre></td></tr></table></figure><h3 id="已初始化数据段">已初始化数据段</h3><p>已初始化数据段存储了代码中所有已初始化的全局变量和已初始化的静态变量。</p><p>已初始化数据段可读、可写，储存在该段的数据可被实时修改。在上节代码中各增加一个全局变量和一个静态局部变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 2.c</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">123</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> b = <span class="hljs-number">456</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比可知，新文件的 data 段增加了8个字节，正好等于32位平台下2个<code>int</code>型变量的字节数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ size 1.out 2.out  <br><br>   text    data     bss     dec     hex filename<br>    785     276       4    1065     429 1.out<br>    785     284       4    1073     431 2.out <br></code></pre></td></tr></table></figure><h3 id="未初始化数据段bss">未初始化数据段（BSS）</h3><p>未初始化数据段也叫<code>BSS</code>段，其名称来源于一个古老的汇编操作符，该操作符代表<strong>block started by the symbol</strong>（以符号开始的块）。</p><p>未初始化数据段存储了代码中所有未初始化的全局变量和未初始化的静态变量，本段同样可读、可写。</p><p>去掉上节代码中的初始化语句，只留下变量的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 3.c</span><br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对比可知，新文件的 data 段减少了8个字节，bss段恰好增加了8个字节。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ size 1.out  2.out 3.out <br> <br>  text    data     bss     dec     hex filename<br>    785     276       4    1065     429 1.out<br>    785     284       4    1073     431 2.out<br>    785     276      12    1073     431 3.out  <br></code></pre></td></tr></table></figure><h2 id="动态分配的内存">动态分配的内存</h2><p>下图是在程序运行期间对应进程的内存情况：</p><p><imgsrc="https://hackthedeveloper.com/wp-content/uploads/2020/11/Memory-Management-in-C-768x251.png.webp" /></p><h3 id="栈">栈</h3><p>栈是进程虚拟地址空间中的一块区域，该区域按先进后出、后进先出的方式增加、移除数据，并且增加数据时地址从高往低增长。程序运行时可以没有堆，但不能没有栈，由此可见栈的重要性。</p><p>调用新的一个函数将创建一个新栈帧，函数返回后对应栈帧将被自动清除。每个函数都有一个独立的栈帧，也称为<strong>活动记录</strong>。栈帧的总大小是浮动的，这取决于局部变量、形参和函数调用情况。</p><p>每个进程都有自己固定或可配置的栈空间，栈空间中可容纳多个栈帧，操作系统会在进程结束后回收这些栈空间。使用<code>ulimit -s</code>命令查看当前Linux 系统支持的最大栈空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bas">$ ulimit -s<br>8192<br></code></pre></td></tr></table></figure><p><code>cat /proc/xxx/limits</code>命令可查看某具体进程的栈空间限额。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /proc/6673/limits<br>Limit                     Soft Limit           Hard Limit           Units<br>Max cpu time              unlimited            unlimited            seconds<br>Max file size             unlimited            unlimited            bytes<br>Max data size             unlimited            unlimited            bytes<br>Max stack size            8388608              unlimited            bytes<br>Max core file size        0                    unlimited            bytes<br>Max resident <span class="hljs-built_in">set</span>          unlimited            unlimited            bytes<br>Max processes             6865                 6865                 processes<br>Max open files            1024                 1048576              files<br>Max locked memory         67108864             67108864             bytes<br>Max address space         unlimited            unlimited            bytes<br>Max file locks            unlimited            unlimited            locks<br>Max pending signals       6865                 6865                 signals<br>Max msgqueue size         819200               819200               bytes<br>Max <span class="hljs-built_in">nice</span> priority         0                    0<br>Max realtime priority     2                    2<br>Max realtime <span class="hljs-built_in">timeout</span>      unlimited            unlimited            us<br></code></pre></td></tr></table></figure><h4 id="内存布局">内存布局</h4><p>栈帧存储了4类数据：</p><ul><li>传给被调用者的形参（按从右到左的顺序入栈）</li><li>调用者的返回地址</li><li>调用者的帧指针</li><li>被调用者中的局部变量</li></ul><p>32位操作系统中，调用者的返回地址和帧指针各占4个字节，而64位操作系统中各占8个字节。</p><p>以下代码用于展示栈的内存布局：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// stack_layout.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">float</span> <span class="hljs-title function_">avg</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-type">int</span> s = sum(a, b);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">float</span>)s / <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Average of %d, %d = %f\n&quot;</span>, a, b, avg(a, b));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码生成的程序运行起来后栈布局如下：</p><p><imgsrc="https://hackthedeveloper.com/wp-content/uploads/2020/11/Stack-Layout.png.webp" /></p><p>当前函数的栈帧总是位于进程栈区段的顶部。指向当前栈帧起始的指针称为帧指针或基指针；指向当前栈帧末尾的指针称为栈指针。被调用者帧针指向的4字节的内存空间存储了调用者的帧指针，其作用是被调用者返回后能够重新定位调用者的帧指针，以此恢复调用者的栈帧。</p><p>操作系统内存管理模块负责栈空间的分配与回收，程序员无法干涉。函数的栈帧被构造后，局部变量方能在此获得内存空间；若函数的栈帧被操作系统回收，局部变量也将随之消失；这就是所谓的变量作用域。</p><h4 id="错误类型">错误类型</h4><p>接下来谈一谈可能发生的栈错误。</p><ol type="1"><li>栈溢出</li></ol><p>这种错误通常发生在一长串函数调用时，相应的栈帧不断累加，直至超过程序的栈内存限额。具体分以下两种情况：</p><ul><li>函数的递归调用</li><li>函数中声明了长数组</li></ul><p>因此，不推荐在栈中储存大对象。</p><ol start="2" type="1"><li>栈损坏</li></ol><p>当向目标空间拷贝了过量的数据往往就会发生栈损坏。</p><p>以下代码中先声明了一个10个元素的字符数组，再将命令行参数拷贝进来。命令行参数是人为给定的，当参数的字符总数超出了数组大小，多余字符将非法覆盖与数组相邻的栈空间，这就造成了栈损坏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(<span class="hljs-type">char</span> *argv)</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">strcpy</span>(name, argv);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    copy(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Exit\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆">堆</h3><p>从上文可知，栈空间的大小存在限制，因此不能用来存储大数据，并且程序员无法控制。堆不存在这些问题，也不被操作系统管理，您可以随时申请或释放一段连续的内存地址空间。</p><p><strong>Glibc</strong> 运行库提供了多个堆操作函数，详见 stdlib.h头文件中相关函数的声明。其中，<code>malloc()</code>和<code>calloc()</code>函数用于向操作系统申请堆块，再通过返回指针访问堆块；<code>free()</code>函数用于释放堆块；这些函数底层都调用了<code>brk()</code>和<code>sbrk()</code>系统调用。以下代码展示了堆块申请和释放过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span>* aptr = &amp;a;<br>    <span class="hljs-type">int</span>* ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    *ptr = <span class="hljs-number">20</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pointing in Stack = %d\n&quot;</span>,  *aptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap Memory Value = %d\n&quot;</span>,  *ptr);<br>    <span class="hljs-built_in">free</span>(ptr);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    func();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>malloc()</code>函数申请了4字节的堆块并返回一个指针（虚拟地址），通过该指针定位到区块，再将整型数20存储入其中。内存管理单元（MMU）会将虚拟地址转换成物理地址，因此20实际就存储在计算机的物理内存中。生成程序的堆、栈布局如下图。</p><p><imgsrc="https://hackthedeveloper.com/wp-content/uploads/2020/11/heap-layout.png.webp" /></p><p>堆中存储的数据不涉及作用域的概念，也无法被自动释放，要求程序员及时、自行释放，否则会造成内存泄漏。</p><p>感谢您的阅读，希望您喜欢这些有趣的知识。</p>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>编程</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C代码编译过程</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/C/C%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/C/C%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>原文地址：<ahref="https://hackthedeveloper.com/c-program-compilation-process/">CProgram Compilation Process</a></p><p>也许您能够熟练编写 C 程序，但是您未必了解如何由 C代码得到二进制文件，本文将系统介绍下这个过程。</p><h2 id="编译器介绍">编译器介绍</h2><h3 id="编译器的定义">编译器的定义</h3><p>维基百科关于编译器的定义如下：</p><blockquote><p>编译器（compiler）是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）。它的主要目的是将便于人类编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低级机器语言的程序，也就是可执行文件。</p></blockquote><h3 id="编译器的分类">编译器的分类</h3><p>在正式讲编译过程之前，有必要提前了解下 C 编译器的分类。</p><h4 id="gcc">GCC</h4><p>GCC 是 <strong>GNU Compiler Collection</strong> 的缩写，也是 GNU项目的重要一员。只要遵循 <strong>GPL</strong>协议，任何人都可以免费使用它。本文将使用该编译器作演示。</p><h4 id="clang">Clang</h4><p>Clang 编译器采用 LLVM 后端，可以编译C、C++、Object-C、Object-C++四种C 系程序。该编译器基本用于 macOS 平台。</p><blockquote><p>当程序较大、较复杂时，GCC 在 macOS 上的表现欠佳，因此想到了 Clang。—<a href="https://www.educba.com/best-c-compilers/">EDUCBA</a></p></blockquote><p>您可在该<ahref="https://en.wikipedia.org/wiki/List_of_compilers">维基词条</a>下找到包括C 编译器在内的市面上所有的编译器。下面让我们来剖析一下 C程序的编译流程。</p><h2 id="编译流程详解">编译流程详解</h2><p>写好代码之后，第一件要做的事就是编译代码，此过程往往耗费数秒。代码在这期间经过一系列转换，得到了二进制文件。另外，这个过程是顺序进行的，就好比工厂里的流水线，上一工序的输出是下一工序的输入。</p><p>进一步讲解之前，先声明以下两个约定：</p><ul><li>仅编译源文件</li><li>分开编译源文件</li></ul><p>C 程序的编译流程分四大步骤：</p><ol type="1"><li>预处理</li><li>编译</li><li>汇编</li><li>链接</li></ol><p>只有顺利通过上述所有步骤，才能输出产物。操作系统不同，输出产物也不同。在Windows 系统下，通常得到 <strong>.exe</strong> 文件，而在 Linux系统下默认生成<strong>a.out</strong>。在上述任何步骤中，即使发生了一个细微的错误也会造成编译或链接失败。</p><p>下图展示了整个编译流程，您可以快速总览一下。</p><p><imgsrc="https://nerdyelectronics.com/wp-content/uploads/2017/07/GCC_CompilationProcess.png" /></p><p>以下命令可得到编译过程产生的所有中间文件和可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc –Wall –save-temps cprogram.c –o cprogram<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>-Wall</p><p>显示所有错误信息和警告信息</p></li><li><p>-save-temps</p><p>保存编译过程产生的中间文件</p></li><li><p>-o</p><p>指定输出文件名</p></li></ul><p>中间文件：</p><ul><li><p>cprogram.i</p><p>预处理器生成物</p></li><li><p>cprogram.s</p><p>编译器生成物</p></li><li><p>cprogram.o</p><p>汇编器生成物</p></li><li><p>cprogram.out</p><p>最终产物—可执行文件</p></li></ul><h3 id="预处理">预处理</h3><p>预处理是整个编译流程的第一步，经过预处理的代码称为<strong>翻译单元</strong>。</p><p>任何 C代码中都不可避免地要包含一些库、定义一些宏，有时还要设一些条件编译指令。所有这些指令被称为预处理指令。经过预处理后，预处理指令将被替换成原始值。</p><h4 id="头文件">头文件</h4><p>C代码的开头一般会包含一个或多个头文件。预处理器根据<code>#include</code>指令将相关头文件的内容替换进来。</p><h4 id="宏">宏</h4><p>C语言中使用<code>#define</code>指令定义宏，预处理器会将这些宏替换成相应值。</p><h4 id="条件编译">条件编译</h4><p>为了提高编译效率，我们期望需要编译的代码尽可能少，这时就用到了条件编译。预处理器会根据条件编译指令去除那些无需编译的代码。常见条件编译指令如下：</p><ul><li><strong>#undef</strong></li><li><strong>#ifdef</strong></li><li><strong>#ifndef</strong></li><li><strong>#if</strong></li><li><strong>#else</strong></li><li><strong>#elif</strong></li><li><strong>#endif</strong></li></ul><h4 id="注释">注释</h4><p>为了提高程序的可读性，代码中经常要写注释。对于计算机而言，这些注释都是多余的，因此预处理器会移除代码中的注释。</p><h4 id="gcc-命令">GCC 命令</h4><p>一个简单 C 程序的示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Header File</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Max 10</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World&quot;</span>); <span class="hljs-comment">// Print Hello World</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, Max);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>-E</code>参数将源文件转换成编译单元。由于包含了 stdio.h头文件，翻译后的代码行数多达上千，以下只截取关键部分展示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -E cprogram.c<br><br><br><span class="hljs-comment"># 1 &quot;cprogram.c&quot;</span><br><span class="hljs-comment"># 1 &quot;&quot;</span><br><span class="hljs-comment"># 1 &quot;&quot;</span><br><span class="hljs-comment"># 1 &quot;cprogram.c&quot;</span><br>.......<br>.......<br>.......<br>typedef __time64_t time_t;<br><span class="hljs-comment"># 435 &quot;C:/msys64/mingw64/x86_64-w64-mingw32/include/corecrt.h&quot; 3</span><br><br>typedef struct localeinfo_struct &#123;<br>  pthreadlocinfo locinfo;<br>  pthreadmbcinfo mbcinfo;<br>&#125; _locale_tstruct,*_locale_t;<br><br>typedef struct tagLC_ID &#123;<br>  unsigned short wLanguage;<br>  unsigned short wCountry;<br>  unsigned short wCodePage;<br>&#125; LC_ID,*LPLC_ID;<br><br>.......<br>.......<br>.......<br><span class="hljs-comment"># 1582 &quot;C:/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h&quot; 2 3</span><br><span class="hljs-comment"># 3 &quot;cprogram.c&quot; 2</span><br><br><br><span class="hljs-comment"># 5 &quot;cprogram.c&quot;</span><br>int <span class="hljs-function"><span class="hljs-title">main</span></span>()<br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, 10);<br>    <span class="hljs-built_in">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>C 开发工具箱提供了一个专门用于预处理的工具 cpp，其用法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cpp cprogram.c<br></code></pre></td></tr></table></figure><p>综上，预处理器只是做了一些很基础的字符替换、移除等工作。预处理得到的文件扩展名为<code>.i</code>。如果将其直接作为编译器的输入，编译器假定此文件已完成预处理，自动跳过预处理步骤。</p><h3 id="编译">编译</h3><p>编译是很关键的一步，此步骤的输入为翻译单元，输出为汇编代码。汇编代码接近硬件，但人类仍可读。</p><p>先用<code>-S</code>参数将源文件预处理、编译成汇编代码，再用<code>cat</code>命令查看结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -S cprogram.c<br><br>$ <span class="hljs-built_in">cat</span> cprogram.s<br><br>.file<span class="hljs-string">&quot;cprogram.c&quot;</span><br>.text<br>.def<span class="hljs-built_in">printf</span>;.scl3;.<span class="hljs-built_in">type</span>32;.endef<br>.seh_proc<span class="hljs-built_in">printf</span><br><span class="hljs-built_in">printf</span>:<br>pushq%rbp<br>.seh_pushreg%rbp<br>pushq%rbx<br>.seh_pushreg%rbx<br>subq<span class="hljs-variable">$56</span>, %rsp<br>.seh_stackalloc56<br>leaq128(%rsp), %rbp<br>.seh_setframe%rbp, 128<br>.seh_endprologue<br>movq%rcx, -48(%rbp)<br>movq%rdx, -40(%rbp)<br>movq%r8, -32(%rbp)<br>movq%r9, -24(%rbp)<br>leaq-40(%rbp), %rax<br>movq%rax, -96(%rbp)<br>movq-96(%rbp), %rbx<br>movl<span class="hljs-variable">$1</span>, %ecx<br>movq__imp___acrt_iob_func(%rip), %rax<br>call*%rax<br>movq%rbx, %r8<br>movq-48(%rbp), %rdx<br>movq%rax, %rcx<br>call__mingw_vfprintf<br>movl%eax, -84(%rbp)<br>movl-84(%rbp), %eax<br>addq<span class="hljs-variable">$56</span>, %rsp<br>popq%rbx<br>popq%rbp<br>ret<br>.seh_endproc<br>.def__main;.scl2;.<span class="hljs-built_in">type</span>32;.endef<br>.section .rdata,<span class="hljs-string">&quot;dr&quot;</span><br>.LC0:<br>.ascii <span class="hljs-string">&quot;Hello World\0&quot;</span><br>.LC1:<br>.ascii <span class="hljs-string">&quot;%d\0&quot;</span><br>.text<br>.globlmain<br>.defmain;.scl2;.<span class="hljs-built_in">type</span>32;.endef<br>.seh_procmain<br>main:<br>pushq%rbp<br>.seh_pushreg%rbp<br>movq%rsp, %rbp<br>.seh_setframe%rbp, 0<br>subq<span class="hljs-variable">$32</span>, %rsp<br>.seh_stackalloc32<br>.seh_endprologue<br>call__main<br>leaq.LC0(%rip), %rcx<br>call<span class="hljs-built_in">printf</span><br>movl<span class="hljs-variable">$10</span>, %edx<br>leaq.LC1(%rip), %rcx<br>call<span class="hljs-built_in">printf</span><br>movl<span class="hljs-variable">$0</span>, %eax<br>addq<span class="hljs-variable">$32</span>, %rsp<br>popq%rbp<br>ret<br>.seh_endproc<br>.ident<span class="hljs-string">&quot;GCC: (Rev3, Built by MSYS2 project) 10.2.0&quot;</span><br>.def__mingw_vfprintf;.scl2;.<span class="hljs-built_in">type</span>32;.endef<br></code></pre></td></tr></table></figure><p>编译结果与 CPU 架构相关。即使同一份代码用同一个编译器编译，在不同 CPU架构的机器上得到汇编结果也不同。编译得到的汇编代码属于低级语言，下一步骤将被转换为可重定位对象文件。</p><h3 id="汇编">汇编</h3><p>汇编器用上一步得到的汇编代码生成机器代码，输出可重定位对象文件。CPU架构不同，汇编器也不同。不同架构下的汇编器将汇编代码转换成匹配本架构的机器代码。</p><h4 id="生成可重定位对象文件">生成可重定位对象文件</h4><p><code>as</code>工具可由汇编文件生成可重定位对象文件，用法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ as cprogram.s -o cprogram.o<br></code></pre></td></tr></table></figure><p>gcc使用<code>-c</code>参数合并预处理、编译、汇编三个操作，直接从源文件生成对象文件。多个源文件要重复执行以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -c cprogram.c<br></code></pre></td></tr></table></figure><p>机器指令人类不可读。截止目前，我们学会了如何从汇编文件或者源文件生成对象文件，下面仅就剩最后一步链接。</p><h3 id="链接">链接</h3><p>链接也是至关重要的一步，这一步我们将合并/链接多个对象文件，得到另一种可执行的对象文件。</p><p>假设有以下两个文件：htd.h 中声明了<code>printHTD()</code>函数，htd.c中定义了<code>printHTD()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// htd.h</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printHTD</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;htd.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printHTD</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hack The Developer&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>cprogram.c中的<code>main</code>()调用<code>printHTD</code>()输出字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// cprogram.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;htd.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    printHTD();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先将源文件分别生成两个对象文件，然后使用<code>ld</code>工具将生成的对象文件链接起来。由于未链接标准库，链接器报错<strong>未定义的引用</strong>，链接失败！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -c cporgram.c<br>$ gcc -c htd.c<br>$ ld htd.o cprogram.o -o cprogram.out<br><br>ld: warning: cannot find entry symbol _start; defaulting to 00010074<br>ld: htd.o: <span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span> `printHTD<span class="hljs-string">&#x27;:</span><br><span class="hljs-string">htd.c:(.text+0xc): undefined reference to `printf&#x27;</span><br></code></pre></td></tr></table></figure><p>gcc内置的链接器可自动链接标准库，用法如下。链接成功，终于得到梦寐以求的可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc cprogram.o htd.o -o cprogram.out<br></code></pre></td></tr></table></figure><h2 id="对象文件分析">对象文件分析</h2><p><code>nm</code>工具用于显示对象文件里的各种符号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nm htd.o<br>         U <span class="hljs-built_in">printf</span><br>00000000 T printHTD<br>$ nm cprogram.o<br>00000000 T main<br>         U printHTD<br></code></pre></td></tr></table></figure><p>以上结果中，00000000为符号在对象文件中的偏移量，U代表未定义(undefined)的符号，T代表该符号位于代码段(Text)。链接器会从一起链接的标准库和其它对象文件中搜寻这些未定义符号，如果在别处都找到就能成功链接。下图展示了可重定位对象文件的文件结构。</p><p><imgsrc="https://hackthedeveloper.com/wp-content/uploads/2020/10/Object-File-Structure.png.webp" /></p><p>众多节中，以下4个节非常关键：</p><ul><li><p>.text</p><p>此节可读、可执行但不可写，存储了机器代码。</p></li><li><p>.data</p><p>此节可读，可写，存储了所有已初始化的全局变量和已初始化的静态变量。</p></li><li><p>.rodata</p><p>此节仅可读，储存了常量和字面量。</p></li><li><p>.bss</p><p>此节可读，可写，存储了所有未初始化的全局变量和未初始化的静态变量。</p></li></ul><p>ELF是可执行文件、可重定位文件、共享库文件、核心转储文件的共同文件标准。在Linux 下可用<code>readelf</code>工具读取标准 ELF文件的信息。限于篇幅原因，这里不再演示。</p><p>可执行文件中的主要节的结构如下：</p><p><imgsrc="https://hackthedeveloper.com/wp-content/uploads/2020/10/Structure.png.webp" /></p><p>感谢您的阅读，希望您喜欢这些有趣的知识。</p>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>编程</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WinDbg快速入门</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/WinDbg%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/WinDbg%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>WinDbg 是 Windows 平台下的一款多用途调试器，由微软官方维护。区别于OD，WinDbg 既可调试用户态代码，又能调试内核态代码及驱动程序。</p><h2 id="安装">安装</h2><p>Win10及以上系统可通过<ahref="https://www.microsoft.com/en-us/p/windbg-preview/9pgjgd53tn86#activetab=pivot:overviewtab">微软商店</a>安装最新Preview 程序，Win10以下只能下载安装包安装。</p><h2 id="符号表">符号表</h2><p>PDB(Program Database Files)符号表文件由链接器生成，它是调试器与源文件之间的桥梁，记录了变量及函数的名称与地址、参数和局部变量的堆栈偏移量、源码的文件名和行号等信息，一般用于调试目的。PDB文件默认搜索路径如下：</p><ol type="1"><li>当前被调试文件所在目录</li><li>当前被调试文件硬编码记录的 build 目录</li><li>symbol server 的本地缓存</li><li>远程 symbol server</li></ol><p>指定3路径、4路径命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">.sympath SRV*c:\windows\localsymbols*http://msdl.microsoft.com/download/symbols<br></code></pre></td></tr></table></figure><h2 id="插件">插件</h2><h3 id="加载插件">加载插件</h3><p>强大的程序大都支持插件，WinDbg亦然。加载插件很简单，一句命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">.load C:\Windows\Microsoft.NET\Framework\v4.0.30319\SOS.dll<br></code></pre></td></tr></table></figure><p>上述命令只能一次性加载，下次还得重新执行。解决方法是将加载命令添加到启动命令组中。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/202202031653402.png"alt="image-20220203165342328" /><figcaption aria-hidden="true">image-20220203165342328</figcaption></figure><h3 id="查看插件">查看插件</h3><p><code>.chain</code>命令查看当前已加载插件列表</p><h3 id="常用插件">常用插件</h3><p>SOS 插件随 .NET Framework 一同发布，提供了查看托管堆的方法。其对应dll 文件既分 x86 和 x64 版本，又分 .NET版本，因此应根据具体调试对象区分加载。</p><ul><li>.NET 4.0及上32位程序集</li></ul><p>C:.NET.0.30319.dll</p><ul><li>.NET 4.0及上64位程序集</li></ul><p>C:.NET.0.30319.dll</p><p>该插件常用方法如下：</p><ol type="1"><li><p>Name2EE</p><p>根据名称查找类型、属性及方法，其原理是遍历对象的<code>MethodTable</code>和<code>EEClass</code>结构体。</p><p>基本语法：<code>Name2EE &lt;module name&gt; !&lt;type or method name&gt;</code>，通配符* 代表所有模块，名称区分大小写。</p><p>典型用法：<code>!name2ee *!Program.Main</code></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>善用佳软</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>json 小抄</title>
    <link href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/json%E5%B0%8F%E6%8A%84/"/>
    <url>/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/json%E5%B0%8F%E6%8A%84/</url>
    
    <content type="html"><![CDATA[<p>JSON(JavaScript ObjectNotation)即JS对象表示法，是一种脱胎于JS的轻量级数据交换语言，语法非常简单易学。JSON独立于JS语言，常用于WEB应用开发及程序配置信息存储，可被多种编程语言支持。</p><p>JSON由对象<code>&#123;…&#125;</code>和数组<code>[…]</code>构成，对象采用<code>键值对</code>的书写方式，具体约定如下：</p><ul><li>键用字符串表示</li><li>值类型为字符串、数字、布尔型</li><li>每对键值用逗号隔开，末尾键值对不加逗号</li><li>数组元素类型为字符串、数字、布尔型及JSON对象</li><li>每对元素用逗号隔开，末尾元素不加逗号</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>钢铁的一些知识</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E9%92%A2%E9%93%81%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E9%92%A2%E9%93%81%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>有一本很著名的书，书名叫《枪炮、病菌与钢铁：人类社会的命运》，这本书讲述了人类文明的演化史，特别是西方现代文明的起源。从书名就可以看出钢铁对于人类文明发展的重要性。</p><p>第一次工业革命也叫蒸汽机革命，其实代表性的技术并非蒸汽机，而是铁路。无论是蒸汽机还是铁路，都需要大量的钢铁作为支撑。</p><p>本文将介绍一些关于钢铁的零碎知识，篇幅不会太长，避免像教科书般面面俱到地陈述。</p><h2 id="钢和铁">钢和铁</h2><p>钢和铁就好比连体婴一样，常常一起出现在我们日常用语中。大多数人并不能分清钢和铁的区别，正如很少有人知道规和矩的不同。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/9944.jpg_wh300.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>钢和铁都是铁碳合金，纯铁和纯碳（比如石墨）质地都较软，工业用途有限。当铁原子、碳原子以体心立方或面心立方的型式排列形成晶胞后，反而展现出了强大的强度、刚度、硬度和韧性，广泛用于国民经济的各个领域。</p><p>根据含碳量的不同划分钢和铁。一般含碳量小于0.0218%的叫熟铁或纯铁，<strong>含量在0.0218%-2.11%之间的叫钢</strong>，含量在2.11%以上叫生铁。生铁又可分为炼钢生铁和铸造生铁。</p><h2 id="牌号">牌号</h2><p>牌号是商品的重要属性，小小一个车厘子都能分出那么多品类和等级来，何况最重要的工业商品—钢。很多国家都自己独立的工业发展历程，因此衍生出了五花八门的牌号。常见的牌号有国标、美标、德标、日标等，<strong>304</strong>就是一个很典型的日标不锈钢牌号。</p><p>国标采用汉语拼音字母、化学元素符号和阿拉伯数字相结合的方式表示钢铁产品的牌号，具体命名规则如下。</p><h3 id="普通碳素结构钢">普通碳素结构钢</h3><p>由前缀符号+强度值+质量等级符号+脱氧方式符号+后缀符号五个部分组成，每个部分的意义如下：</p><ol type="1"><li><p>前缀符号</p><p>通用结构钢前缀符号为屈服强度，用字母 Q表示。结构配筋图中也有两个前缀很常见：HPB—热轧光圆钢筋、HRB—热轧带肋钢筋。</p></li><li><p>强度值</p><p>表示强度的具体数值，单位为 MPa。注意不要将其与许用应力混淆。</p></li><li><p>质量等级符号（非必要）</p><p>用 A、B、C、D…等字母表示不同的质量等级。</p></li><li><p>脱氧方式（非必要）</p><p>沸腾钢、半镇静钢、镇静钢和特殊镇静钢分别以字母 F、b、Z、TZ表示，镇静钢和特殊镇静钢不用表示。</p></li><li><p>后缀符号（非必要）</p><p>代表产品的用途、特性和工艺方法，比如 Q345R代表该钢种用于压力容器。</p></li></ol><p>Q235B 是最常用的普通碳素结构钢，其常温屈服强度为235MPa，质量等级B（经过常温冲击试验），镇静钢。</p><h3 id="优质碳素结构钢">优质碳素结构钢</h3><p>优质碳素钢的含碳小于0.8%，并且硫、磷等有害元素及非金属夹杂物的含量都比普通碳素结构钢少，因此机械性能也更佳。</p><p>由平均含碳量+锰元素符号+冶金质量符号+脱氧方式符号+后缀符号五个部分组成，每个部分的意义如下：</p><ol type="1"><li><p>平均含碳量</p><p>以两位数字表示平均碳含量（万分之几计），比如20#。</p></li><li><p>锰元素符号（非必要）</p><p>含锰量量较高时加锰元素符号Mn特别说明，比如 16MnR。</p></li><li><p>冶金质量符号（非必要）</p><p>高级优质钢、特级优质钢分别以字母 A、E 表示，优质钢不用表示。</p></li><li><p>脱氧方式符号（非必要）</p><p>沸腾钢、半镇静钢、镇静钢和特殊镇静钢分别以字母 F、b、Z、TZ表示，镇静钢和特殊镇静钢不用表示。</p></li><li><p>后缀符号（非必要）</p><p>代表产品的用途、特性和工艺方法。</p></li></ol><h3 id="合金结构钢">合金结构钢</h3><h4 id="分类">分类</h4><p>合金元素总含量＜5%时称为低合金钢，5%≤合金元素总含量＜10%时称为中合金钢，合金元素总含量≥10%时称为高合金钢。</p><h4 id="表示方法">表示方法</h4><p>由平均含碳量+主要合金元素含量+冶金质量符号+后缀符号四个部分组成，每个部分的意义如下：</p><ol type="1"><li><p>平均含碳量</p><p>以两位数字表示平均碳含量（万分之几计）。</p></li><li><p>主要合金元素含量</p><p>除个别微量合金元素外，主要合金元素一般以百分之几表示。</p><p>当平均合金含量&lt;1.5%时，牌号中一般只标出元素符号，而不标明具体含量。但特殊情况下可能导致混淆时，在元素符号后也可标以数字"1"，例如牌号"12CrMoV"和"12Cr1MoV"，前者铬含量为0.4-0.6%，后者为0.9-1.2%，其余成分完全相同。</p><p>当合金元素平均含量≥1.5%、≥2.5%、≥3.5%…时，在元素符号后面应标明含量，可相应表示为2、3、4…等。</p></li><li><p>冶金质量符号（非必要）</p><p>高级优质钢、特级优质钢分别以字母 A、E 表示，优质钢不用表示。</p></li><li><p>后缀符号（非必要）</p><p>代表产品的用途、特性和工艺方法。</p></li></ol><p>锅炉常用钢 12Cr1MoVG牌号意义为：碳含量在0.08%-0.15%之间；铬含量在0.90%-1.2%之间；钼、钒各自平均含量在1.5%以下，不表示；G代表锅炉用钢。</p><h4 id="合金元素作用">合金元素作用</h4><p>钢中加入合金元素后，能形成一定数量的合金碳化物，细化晶粒，提高淬透性，增加回火稳定性，以达到增加耐磨性和提高韧性的作用。所加入的主要合金元素及其作用如下：</p><ol type="1"><li><p>铬</p><p>铬显著增加钢的淬透性，有效提高钢的回火稳定性。</p></li><li><p>钼</p><p>钼可增加钢的淬透性和高温蠕变强度，回火稳定性和二次硬化效果也强于钼，但钼增加脱碳倾向。</p></li><li><p>钒</p><p>钒主要以 V<sub>4</sub>C<sub>3</sub>的形式存在于钢中，能显著提高钢的耐磨性和热硬性，同时还可细化晶粒、降低过热敏感性。</p></li><li><p>镍</p><p>镍既能提高钢的强度，又能提高钢的韧性，同时提高钢的淬透性；含量较高时，可显著提高钢的耐腐烛性。</p></li></ol><h2 id="电化学腐蚀">电化学腐蚀</h2><h3 id="规范条文">规范条文</h3><p>国标《管道支吊架第1部分：技术规范》GBT17116.1-2018中关于隔离垫的要求如下：</p><blockquote><p>与有色金属管道直接接触的管部结构，为防止电化学腐蚀，应在其与管道接触部位的表面涂衬足够绝缘强度的非金属涂层、防护膜或衬垫。</p><p>不锈钢管道与管部结构之间应加置不锈钢板衬垫，防止不锈钢管道的电化学损伤。</p></blockquote><p>电力规《火力发电厂汽水管道设计规范》DL/T 5054-2016中的要求类似：</p><blockquote><p>不锈钢管道不应直接与碳钢支吊架管部焊接或接触，应在不锈钢管道与碳钢管部之间设不锈钢垫板或非金属材料隔离垫。</p></blockquote><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%E9%9A%94%E7%A6%BB%E5%9E%AB.jpg" /></p><h3 id="腐蚀机理">腐蚀机理</h3><p>金属腐蚀按机理不同，一般分为化学腐蚀和电化学腐蚀。</p><p>化学腐蚀是金属在干燥气体中或非电解质溶液中（如酒精、石油等〉发生的腐蚀，腐蚀过程中无电流产生。</p><p>电化学腐蚀是指金属在电解质溶液中因电化学作用导致的腐蚀，腐蚀过程中有电流产生。大气腐蚀、海水腐蚀、土壤腐蚀等都属于电化学腐蚀。大气腐蚀指金属在潮湿空气中其表面吸附了空气中的水份，形成一层水膜，而空气中的二氧化碳、二氧化硫、二氧化氮等气体溶解在这层水膜中后形成了电解质溶液，进而发生的电化学腐蚀。</p><p>电化学腐蚀发生时，活泼元素充当阳极，发生氧化反应后溶解，非活泼元素充当阴极，仅发生还原反应。高合金钢含有大量合金成分，部分合金成分的活性比铁元素高，当与普通碳钢直接接触时，容易诱发电化学反应。因此，相关标准才作出上节要求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工业技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蒸汽安全阀相关计算</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E8%92%B8%E6%B1%BD%E5%AE%89%E5%85%A8%E9%98%80%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E8%92%B8%E6%B1%BD%E5%AE%89%E5%85%A8%E9%98%80%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>安全阀是各行各业都会用到的重要安全泄放装置，大到运载火箭，小到家用高压锅，都出现了安全阀的身影。另一种常见安全泄放装置是爆破片或者两者的组合。</p><p>本文的目的不在于扫盲，不会介绍安全阀的入门知识。读者如果不具备相关背景知识，请提前做好功课，仔细阅读<ahref="http://std.samr.gov.cn/gb/search/gbDetailed?id=BD89DE8E079C3D08E05397BE0A0A4FAD">GB/T12241-2021《安全阀 一般要求》</a>和<ahref="http://std.samr.gov.cn/gb/search/gbDetailed?id=C1A814733B2C7A48E05397BE0A0A1C8D">GB/T12243-2021《弹簧直接载荷式安全阀》</a>两本规范。同时也不会站在制造商的角度，阐述安全阀该如何设计、制造、检验。本文只针对<strong>蒸汽用弹簧直接荷载式安全阀</strong>，谈谈排放面积、出口压力及排放反力的计算[^1]。</p><h2 id="手工计算">手工计算</h2><p>国内涉及安全阀相关计算的规范主要有两本：HG/T20570.02-1995《安全阀的设置和选用》及DL/T 5054-2016《火力发电厂汽水管道设计规范》，GB/T12243-2021附录B也介绍了排放面积的计算。另外，强烈推荐读读ASME规范、API规范，顺便还提高英语水平。</p><h3 id="排放面积计算">排放面积计算</h3><p>经过收集对比，排放面积（也称喉部面积）计算公式无一例外如下： <spanclass="math display">\[A_c = \frac {W_r}  {5.25 \times  P_{dr} \times K_{dr} \times K_{sh}\times K_n \times K_b \times K_c}\]</span></p><p>式中：</p><ul><li><p>A<sub>c</sub>—计算排放面积，mm<sup>2</sup>；</p></li><li><p>W<sub>r</sub> —需要排放量，kg/h；</p></li><li><p>P<sub>dr</sub>—额定排放压力，MPaA(绝对压力)；</p></li><li><p>K<sub>dr</sub>—额定排量系数，其实就是裕度系数，全启式安全阀取值范围为0.6~0.7，制造商数据一般不低于0.75；</p></li><li><p>K<sub>sh</sub>—过热修正系数，查GB/T 12243-2021附表B.1；</p></li><li><p>K<sub>n</sub>—Napier修正系数（也称高压系数），当P<sub>dr</sub>≤10.44时，K<sub>n</sub>=1；当10.44Mpa&lt;P≤22.17时，<span class="math display">\[K_n = \frac {27.637-1000} {33.234P_{dr}-1061}\]</span></p></li><li><p>K<sub>b</sub>—背压修正系数，该系数仅用于波纹管平衡式安全阀，对于弹簧直接荷载式安全阀，K<sub>b</sub>=1；</p></li><li><p>K<sub>c</sub>—爆破片修正系数，不带爆破片时，K<sub>c</sub>=1。</p></li></ul><p>上述参数中，除额定排放压力外，其余参数要么用户给定，要么取默认值，要么查表。仅额定排放压力需单独计算，计算公式如下：<span class="math display">\[P_{dr} = P_s \times (1+\Delta P_o) + P_{atm}\]</span> 式中：</p><ul><li><p>P<sub>s</sub>—整定压力，MPag；</p></li><li><p>ΔP<sub>o</sub> —允许超压百分比，查GB/T 12243-2021表6；</p></li></ul><table><thead><tr class="header"><th style="text-align: center;">蒸汽锅炉用</th><th style="text-align: center;">其它蒸汽设备用</th><th style="text-align: center;">气体用</th><th style="text-align: center;">液体用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">3%</td><td style="text-align: center;">10%</td><td style="text-align: center;">10%</td><td style="text-align: center;">10%</td></tr></tbody></table><ul><li>P<sub>atm</sub>—当地大气压，平原地区可取0.101</li></ul><p>下面将某项目真实数据依次代入上述两个公式，求解排放面积。此安全阀位于减温减压器二次蒸汽管道，选用弹簧直接荷载式，设计输入如下：</p><table><thead><tr class="header"><th>参数</th><th style="text-align: center;">单位</th><th style="text-align: center;">数值</th></tr></thead><tbody><tr class="odd"><td>需要排放量</td><td style="text-align: center;">kg/h</td><td style="text-align: center;">10000</td></tr><tr class="even"><td>整定压力</td><td style="text-align: center;">MPag</td><td style="text-align: center;">1.7</td></tr><tr class="odd"><td>排放温度</td><td style="text-align: center;">℃</td><td style="text-align: center;">250</td></tr></tbody></table><ol type="1"><li><p>排放压力 <span class="math display">\[P_{dr} = P_s \times (1+\Delta P_o) + P_{atm} = 1.7 \times {(1+0.1)} +0.101 =1.971  MPaA\]</span></p></li><li><p>排放面积</p><p>查表得到过热蒸汽修正系数为0.963，代入数据： <spanclass="math display">\[A_c = \frac {W_r}  {5.25 \times  P_{dr} \times K_{dr} \times K_{sh}\times K_b \times K_c \times K_n} = \frac {10000}  {5.25 \times  1.971\times 0.87 \times 0.963 \times 1 \times 1 \times 1} = 1153.5mm^2\]</span></p></li></ol><p>得到计算面积后就可以选择具体型号，保证流道面积满足要求，流道系列详下表。选型完成后，再根据实际排放面积反算额定排放量，以校核排放能力是否满足要求。</p><center>国标安全阀流道直径—流道面积对应表</center><table><thead><tr class="header"><th style="text-align: center;">流道直径(mm)</th><th style="text-align: center;">流道面积(mm<sup>2</sup>)</th><th style="text-align: center;">全启式进口公称直径</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">12</td><td style="text-align: center;">113.1</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">16</td><td style="text-align: center;">201.1</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;">314.2</td><td style="text-align: center;">32</td></tr><tr class="even"><td style="text-align: center;">25</td><td style="text-align: center;">490.9</td><td style="text-align: center;">40</td></tr><tr class="odd"><td style="text-align: center;">32</td><td style="text-align: center;">804.2</td><td style="text-align: center;">50</td></tr><tr class="even"><td style="text-align: center;">40</td><td style="text-align: center;">1256.6</td><td style="text-align: center;">65</td></tr><tr class="odd"><td style="text-align: center;">50</td><td style="text-align: center;">1963.5</td><td style="text-align: center;">80</td></tr><tr class="even"><td style="text-align: center;">65</td><td style="text-align: center;">3318.3</td><td style="text-align: center;">100</td></tr><tr class="odd"><td style="text-align: center;">80</td><td style="text-align: center;">5026.5</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">100</td><td style="text-align: center;">7854.0</td><td style="text-align: center;">150</td></tr><tr class="odd"><td style="text-align: center;">125</td><td style="text-align: center;">12271.8</td><td style="text-align: center;">200</td></tr></tbody></table><center>美标安全阀流道直径—流道面积对应表</center><table><thead><tr class="header"><th style="text-align: center;">流道代号</th><th style="text-align: center;">流道直径(mm)</th><th style="text-align: center;">流道面积(mm<sup>2</sup>)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">D</td><td style="text-align: center;">9.5</td><td style="text-align: center;">70.9</td></tr><tr class="even"><td style="text-align: center;">E</td><td style="text-align: center;">12.7</td><td style="text-align: center;">126.7</td></tr><tr class="odd"><td style="text-align: center;">F</td><td style="text-align: center;">15.9</td><td style="text-align: center;">198.6</td></tr><tr class="even"><td style="text-align: center;">G</td><td style="text-align: center;">20.3</td><td style="text-align: center;">323.7</td></tr><tr class="odd"><td style="text-align: center;">H</td><td style="text-align: center;">25.4</td><td style="text-align: center;">506.7</td></tr><tr class="even"><td style="text-align: center;">J</td><td style="text-align: center;">32.5</td><td style="text-align: center;">829.6</td></tr><tr class="odd"><td style="text-align: center;">K</td><td style="text-align: center;">38.9</td><td style="text-align: center;">1188.5</td></tr><tr class="even"><td style="text-align: center;">L</td><td style="text-align: center;">48.4</td><td style="text-align: center;">1839.8</td></tr><tr class="odd"><td style="text-align: center;">M</td><td style="text-align: center;">54.4</td><td style="text-align: center;">2324.3</td></tr><tr class="even"><td style="text-align: center;">N</td><td style="text-align: center;">59.7</td><td style="text-align: center;">2799.2</td></tr><tr class="odd"><td style="text-align: center;">P</td><td style="text-align: center;">72.4</td><td style="text-align: center;">4116.9</td></tr><tr class="even"><td style="text-align: center;">Q</td><td style="text-align: center;">95.3</td><td style="text-align: center;">7133.1</td></tr><tr class="odd"><td style="text-align: center;">R</td><td style="text-align: center;">114.6</td><td style="text-align: center;">10386.9</td></tr><tr class="even"><td style="text-align: center;">T</td><td style="text-align: center;">146</td><td style="text-align: center;">16741.5</td></tr></tbody></table><h3 id="出口压力计算">出口压力计算</h3><p>安全阀出口排放压力影响排放管壁厚的计算，目前国内涉及的规范唯有DL/T5054-2016《火力发电厂汽水管道设计规范》，但有研究显示其中的计算方法存在瑕疵，饱和蒸汽计算误差较大。笔者推荐几篇论文供大家赏析：</p><ol type="1"><li><ahref="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2003&amp;filename=RLFD200301006&amp;uniplatform=NZKPT&amp;v=%25mmd2BytLHo8%25mmd2Bl%25mmd2FwXd0Dd%25mmd2BtPmSi%25mmd2FuTvmorcycCbGeHF5M4f60FJ7YdsFk7g9YC2M2MpRC">火电厂安全阀排汽管道参数计算方法的讨论</a></li><li><ahref="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2009&amp;filename=GXDL200905028&amp;uniplatform=NZKPT&amp;v=cYQg794Gra%25mmd2BWG3KT1jDR4HXlFvjBswsk5efZJSSM98B7nosX8WB%25mmd2BN8qjcEqAa4d%25mmd2B">330MW机组锅炉安全阀排汽管道强度核算及探讨</a></li><li><ahref="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2011&amp;filename=SLDL201111005&amp;uniplatform=NZKPT&amp;v=IAA00VzThx10FU446oGtY5RAwiCWPDqxrJGGvuB1gZAV1JYwdITLBDnoutXnkyB%25mmd2B">电厂安全阀排汽管道热力计算及应用</a></li></ol><p>ASME B31.1《POWERPIPING》非强制附录II提供的计算方法按<strong>滞止焓</strong>计算，被认为适用性更广、计算精度更高。该规范中安全阀出口排放管压力计算公式如下：<span class="math display">\[P = \frac {G} {A} \cdot \frac {b-1}{b} \cdot \sqrt \frac{2(h_o-a)}{2b-1}\]</span> 式中：</p><ul><li>G—排放管流量，可取1.11倍安全阀额定排放量，kg/s；</li><li>A —排放管面积，m<sup>2</sup>；</li><li>h<sub>0</sub>—安全阀进口滞止焓，J/kg；</li><li>a—蒸汽状态系数；</li><li>b—蒸汽状态系数。</li></ul><ol type="1"><li><p>滞止焓</p><p>安全阀内达到稳定流动时的实际压力是排放压力，不是整定压力，因此滞止压力应取排放压力。滞止温度取蒸汽最高操作温度。根据滞止压力和滞止温度可计算得到滞止焓，常规计算公式为<ahref="https://web1.hszg.de/thermo_fpc/">IAPWS-IF97</a>。</p></li><li><p>蒸汽状态参数</p></li></ol><table><thead><tr class="header"><th>排汽终态</th><th style="text-align: center;">a(j/kg)</th><th style="text-align: center;">b</th></tr></thead><tbody><tr class="odd"><td>湿蒸汽，干度&lt;90%</td><td style="text-align: center;">677000</td><td style="text-align: center;">11</td></tr><tr class="even"><td>饱和蒸汽，干度≥90%<br />0.15MPaA ≤ P ≤ 6.89MPaA</td><td style="text-align: center;">1913000</td><td style="text-align: center;">4.33</td></tr><tr class="odd"><td>过热蒸汽，干度≥90%<br />6.89MPaA ≤ P ≤ 13.79MPaA</td><td style="text-align: center;">1933000</td><td style="text-align: center;">4.33</td></tr></tbody></table><p>结合下节安全阀实际数据得到：排放管流量为3.513kg/s，排放管面积为0.00456㎡；1.971MPaA/265℃蒸汽滞止焓为2941.94kJ/kg，代入上述公式： <span class="math display">\[P = \frac {G} {A} \cdot \frac {b-1}{b} \cdot \sqrt \frac{2(h_o-a)}{2b-1}=\frac {3.513} {0.00456} \cdot \frac {4.33-1}{4.33}\cdot \sqrt \frac{2\times(2941.94-1933)\times1000}{2\times4.33-1}=0.305MPaA\]</span>在安全阀排放的刹那，管道内可能形成冲击波，因此<strong>B31.1规范要求管道设计压力取两倍计算值。</strong></p><p>出口流速计算如下： <span class="math display">\[W = \sqrt \frac {2(h_o-a)}{2b-1}=\sqrt \frac{2\times(2941.94-1933)\times1000}{2\times4.33-1}=513.255m/s\]</span></p><h3 id="排放反力计算">排放反力计算</h3><p>尽管安全阀通常都是偶然、短暂排放，排放形成的反作用力对管系造成的不利影响却不容小觑，因此管道应力分析需要考虑安全阀排放工况。得到出口压力和出口流速后，即可计算出口反力，公式如下：<span class="math display">\[F=GW+1000\times({P-P_{atm}})A\]</span> 代入数据： <span class="math display">\[F=3.513\times513.255+({0.305-0.101})\times1000000\times0.00456=2733N\]</span></p><h2 id="软件计算">软件计算</h2><h3 id="软件简介">软件简介</h3><p>艾默生是一家跨国电气公司，其旗下的Fisher调节阀、Crosby安全阀、DCS系统、各种仪表等在石化、电力行业应用广泛。下面我们使用其免费提供的PRV<sup>2</sup>SIZE软件进行安全阀选型计算，<ahref="https://valvesizing.emerson.com/Software/PRV2SIZEOverview.aspx">官方介绍</a>如下。软件具体包括哪些功能、怎么使用请参考官方<ahref="https://valvesizing.emerson.com/ReferenceDocuments/PRV2SIZEQuickStartGuide.pdf">快速上手</a>，这里不再累述。</p><blockquote><p>PRV<sup>2</sup>SIZE software is an easy to use and comprehensiveprogram that offers sizing, selection and configuration capabilities forAnderson Greenwood, Crosby and Varec brand Over Pressure ProtectionValves and for Yarway brand Automatic Recirculation Control Valves</p><p>PRV<sup>2</sup>SIZE是一款功能全面且易于上手的阀门计算、选型软件，样本库包括了：AndersonGreenwood、Crosby 、Varec品牌安全阀和Yarway品牌最小流量阀。</p></blockquote><p>现在基于<strong>ASME Section VIII(API 520 Part I,9thedition)</strong>规范新建一个蒸汽安全阀计算实例，如果用于蒸汽锅炉，请选择<strong>ASMESection I</strong>规范。</p><h3 id="计算过程">计算过程</h3><p>输入上节的排放温度、需要排放量、整定压力三个参数，运行后，软件很快给出了选型列表。我们选择列表第2项：Crosby的HSL系列安全阀，结构型式为常规式，阀盖型式为敞开式。对比发现，手算结果与软件计算结果差别很小。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/PRV2SIZE.png" /></p><p><strong>其实计算方法都是公开统一的，唯一的区别就在于额定排放系数的取值，这对于选型有直接影响。在没有得到制造商数据的前提下，HG规范推荐取值0.6~0.7，DL规范推荐取值0.6，笔者认为都偏保守。当然最终应以制造商计算书为准。</strong></p><p>确定具体型号之后，接着要设置安全阀本体参数，包括材质、管口参数等。当红色警告消失，即可输出排汽反力。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/PRV2SIZE%25E6%258E%2592%25E6%25B1%25BD%25E5%258F%258D%25E5%258A%259B.png" /></p><p>由于软件计算得到的出口压力与按B31.1手工计算结果出入较大，这里不再介绍此功能，读者可以自行发掘研究。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工业技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>管道应力分析</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E7%AE%A1%E9%81%93%E5%BA%94%E5%8A%9B%E5%88%86%E6%9E%90/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E7%AE%A1%E9%81%93%E5%BA%94%E5%8A%9B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识">前置知识</h2><h3 id="应力分类">应力分类</h3><p>取构件截面内一无限小微元体为研究对象。</p><ol type="1"><li>垂直于截面的应力分量称为正应力，用<code>σ</code>表示；</li><li>平行于截面的应力分量称为剪应力（也称切应力），用<code>τ</code>表示；</li><li>大多数截面上，正应力与剪应力同时存在，但在主平面上剪应力为零，此处的正应力被称为主应力。</li></ol><p>三维世界中的微元体由六个面组成，因此至多存在三对大小相同，方向相反的应力对。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210512093520226.png"alt="image-20210512093520226" /><figcaption aria-hidden="true">image-20210512093520226</figcaption></figure><h3 id="应力状态">应力状态</h3><ul><li>单向（简单）应力状态：三个主应力中只有一个不为零；</li><li>二向应力状态：三个主应力中有两个主应力不为零，剩下一个为零；</li><li>三向应力状态：三个主应力均不为零。</li></ul><h2 id="强度理论">强度理论</h2><h3 id="理论定义">理论定义</h3><ol type="1"><li><p>第一强度理论，即最大拉应力理论，仅适用于脆性材料受拉的情况，不包括单向压缩。</p></li><li><p>第二强度理论，即最大伸长线应变理论，主要适用于脆性材料受单向和双向压缩为主的情况。经实验验证，该理论误差很大，只有极少数的几种材料适用。</p></li><li><p>第三强度理论，即最大剪应力理论，主要适用于塑性材料单向和二向应力的情况，形式简单，计算方便，因此应用最广。</p></li><li><p>第四强度理论，即畸变能理论（vonmises理论），主要适用于塑性材料单向和二向应力的情况，精度比第三强度理论要高，当然计算也麻烦些。</p></li></ol><h3 id="适用范围">适用范围</h3><ol type="1"><li>第一、第二强度理论适用于铸铁、石料、混凝土、玻璃等，通常<strong>断裂失效</strong>的脆性材料。　</li><li>第三、第四强度理论适用于碳钢、铜、铝等，通常<strong>屈服失效</strong>的塑性材料。由于第三强度理论结果较保守，实际工程中压力容器、压力管道、管道应力等计算采用第三强度理论，钢结构计算采用的是第四强度理论。</li></ol><h3 id="应力合成">应力合成</h3><p>强度理论仅告诉我们所谓当量应力的合成方式，即将一次应力、二次应力、冷态应力、热态应力不同大小、方向的应力成份合成当量应力。<code>ASME B31.3</code>依据第三强度理论合成当量应力，<code>EN13941</code>和<code>GOST55596</code>则采用了第四强度理论。</p><blockquote><p>In piping stress analysis, we deal mostly with tow-dimensional fieldswith the stess at the third dimensional either zero or insignificant.Inthis case,it is simple to calculate the stress intensity directly formthe general stress field,without calculating the principal stress.</p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210512095029849.png"alt="image-20210512095029849" /><figcaption aria-hidden="true">image-20210512095029849</figcaption></figure><h3 id="强度刚度稳定性">强度、刚度、稳定性</h3><ul><li>强度：构件抵抗破坏的能力</li><li>刚度：构件抵抗变形的能力</li><li>稳定性：构件抵抗失稳而维持原平衡状态的能力</li></ul><h2 id="管道机械">管道机械</h2><h3 id="管道荷载分类">管道荷载分类</h3><ol type="1"><li><p>持续荷载</p><p>此类荷载由重力、内压、支架摩擦反力、盲板力等引起，特点是荷载大小不随管道变形改变。</p></li></ol><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210512094747622.png"alt="image-20210512094747622" /><figcaption aria-hidden="true">image-20210512094747622</figcaption></figure><ol start="2" type="1"><li><p>位移荷载</p><p>管道热胀冷缩、端点附加位移引起管道发生变形。如果变形受到限制就会产生位移荷载；<strong>而变形一旦被放开，位移荷载将大幅降低甚至消失</strong>此特征称为自限性。</p></li></ol><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/38930.png"alt="38930" /><figcaption aria-hidden="true">38930</figcaption></figure><ol start="3" type="1"><li><p>偶然荷载</p><p>通常指安全阀排放反力、风、雪、地震等荷载，与持续荷载特征一致，但这种荷载不会持续出现。</p></li></ol><h3 id="管道失效形式">管道失效形式</h3><ol type="1"><li><p>破裂：管道内压使管道产生环向应力，而过大的环向应力会造成管道破裂。环向应力计算公式为<code>P*D/2t</code>，增加壁厚可降低环向应力。</p></li><li><p>腐蚀：材料耐腐蚀性不够</p></li><li><p>垮塌：支架过载导致</p></li><li><p>疲劳：加载次数过多、频繁开停车、反复热胀冷缩就会导致疲劳破坏，焊缝开裂就是典型疲劳破坏。</p></li><li><p>碰撞：大变形导致</p></li><li><p>管口过载：管口焊口处或法兰密封面将发生泄漏</p></li></ol><h3 id="管道力学模型">管道力学模型</h3><p>实际工程中管道会被弯曲（主要形式）、被扭转、被剪切，类似于材料力学的简单梁单元，因此可以将管道当作梁进行分析。梁的力学行为一般通过端点来描述，因此CaesarII软件算的都是梁端部节点的应力。计算梁单元模型管道应力需下述参数：外径、壁厚、密度、弹性模量、泊松比、线胀系数、刚度等。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210512093552072.png"alt="image-20210512093552072" /><figcaption aria-hidden="true">image-20210512093552072</figcaption></figure><h3 id="管道基本应力">管道基本应力</h3><ul><li><strong>轴向应力（重点）</strong>：轴向应力比其它方向应力都大，主要由轴向集中力（盲板力、摩擦力）、内压、重力、温度引发的弯矩（管截面外侧拉力&gt;内侧压力）导致。</li><li>环向应力：第2节已描述</li><li>径向应力：一般不超管道内压，基本无需校核。</li><li>剪应力：只有在管道受扭的情况下才会产生剪应力。动力管道支架大量采用弹簧吊，而弹簧的横向刚度几乎为零，因此即使管道本身受扭，管系也不会大幅扭转变形。工艺管道则会考虑扭转变形。</li></ul><h3 id="管道规范应力">管道规范应力</h3><p>规范定义的应力不是真实应力，且规范只规定校核轴向应力。根据荷载不同分为三类：</p><ul><li>一次应力（sustainstress）：由持续性荷载产生，从变形和破坏两个角度分析；</li><li>二次应力（expansionstress）：由温差、沉降等带来的位移荷载产生，仅从疲劳一个角度分析；</li><li>偶然应力（occasional stress）：由偶然荷载产生</li></ul><h4 id="一次应力">一次应力</h4><p>一次应力计算公式：</p><p><span class="math display">\[\frac{F}{A}+\frac{P\ast D_i^2}{D_o^2-D_i^2}+i\frac{M}{Z}\leq S_h\]</span></p><p>其中：F为轴向集中力，i为应力增大系数，M为重力产生的弯矩，Z为抗弯截面模量，S<sub>h</sub>为材料热态许用应力。结合公式与工程实际可知，降低一次应力的最有效途径是减小弯矩M，即减小支吊架跨距。CaesarII一次应力校核公式如下：</p><p><span class="math display">\[\sigma_{sus}=\sigma_1=0.75i\frac{M_A}{Z}+\frac{PD_o}{4t}\leq \sigma_h\]</span></p><p>重力为均布荷载，其弯矩近似认为介于受均布荷载作用的简支梁（端部为铰接，可以自由转动）与固支梁之间。通过反算得到管道跨距公式：</p><p><span class="math display">\[L\leq \sqrt{(S_h-\frac{PD }{4t})(\frac{10Z}{iw})}\]</span></p><p>因此一次应力的校核实际就是校核管道跨距。考虑动力管道常选用吊架且极少使用补偿器，因此B31.1忽略了<code>F/A</code>这一项，但B31.3规范仍有考虑。</p><h4 id="二次应力">二次应力</h4><h5 id="二次应力计算">二次应力计算</h5><p>二次应力是位移荷载在管道轴向产生的应力，如果管道能够自由变形就不会产生位移荷载，也无需校核二次应力。位移的主要来源为：设备本体的热胀冷缩作用于管口、基础沉降作用于管口、主管的位移作用于支管。</p><p>首先分析下两端固支直管对支架的推力，推导过程如下：</p><p><span class="math display">\[F=\sigma\ast A=E\frac{\Delta L}{L}=E\frac{\alpha\DeltaTL}{L}=E\alpha\Delta T\]</span></p><p>其中，E为弹性模量，α为线胀系数，ΔT为温差；由此可见，推力与管道的长度无关。</p><p><img src="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210225162831717.png" alt="image-20210225162831717" style="zoom:50%;" /></p><p>假设上图AB段为主管，BC段为补偿臂（非约束段），二次应力推导过程如下：</p><p><span class="math display">\[\Delta = \frac{FL^3}{12EI}\Rightarrow F=\frac{12EI}{L^3}\Delta\]</span></p><p>假定B端转角<spanclass="math inline">\(\theta\)</span>为零，则合成弯矩</p><p><span class="math display">\[M=\frac{FL}{2}=\frac{6EI}{L^2}\Delta\]</span></p><p><span class="math display">\[S=\frac{M}{Z}=\frac{1}{Z}\frac{6EI}{L^2}\Delta=\frac{1}{\pir^2t}\frac{6E\pi r^3t}{L^2}\Delta =\frac{6Er}{L^2}\Delta=\frac{3ED_o}{L^2}\Delta\]</span></p><p><span class="math display">\[S_h=i\frac{3ED_o}{L^2}\Delta\leq S_a\]</span></p><p>其中，E为材料热态弹性模量，D<sub>o</sub>为管道外径，L为补偿臂长度，Δ为主管热胀量，i为应力增大系数。</p><h3 id="安定性准则">安定性准则</h3><p>二次应力是根据安定性原则进行校核，即一次应力和二次应力之和不超过2倍屈服极限σ<sub>s</sub>，校核公式如下：</p><p><span class="math display">\[\sigma_{exp}=\sigma_2\leq f(1.25[\sigma]_c+1.25[\sigma]_h-\sigma_1)\]</span></p><h3 id="应力增大系数">应力增大系数</h3><p>表征管件局部应力集中的程度，早期通过实验获得该值。</p><h2 id="计算软件">计算软件</h2><p>市面有多种应力计算软件，依托理论无非<code>有限元</code>和<code>梁单元</code>两种。有限元计算结果更精确，但计算量很大、计算速度偏慢，可将其理解成是一种硬刚的方式。CaesarII软件采用简单梁单元计算方法，在精度和速度之间平衡较好，目前广泛应用于石化、电力等行业。</p><h3 id="功能模块">功能模块</h3><p>CaesarII软件全部分析功能可分为管道、元件、设备三大类别，其中管道静态分析最常用。管道动态分析适用于管系振动、安全阀排放、地震等工况。NEMASM23功能依据美国NEMA协会SM23规范校核工业透平管嘴及设备整体承受的作用力、作用力矩是否满足要求。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/CAESARII%25E5%258A%259F%25E8%2583%25BD%25E6%25A8%25A1%25E5%259D%2597.png"alt="CAESARII功能模块" /><figcaption aria-hidden="true">CAESARII功能模块</figcaption></figure><h3 id="软件设置">软件设置</h3><ol type="1"><li><p>默认单位制</p><p>CaesarII内置多种单位制，用户可根据自身需求设置默认单位制。光标在输入框中短暂停留，将提示当前物理量单位。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210605202520410.png"alt="当前单位" /><figcaption aria-hidden="true">当前单位</figcaption></figure><p>某选型具体的单位制：</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210605194455378.png"alt="Japan单位制" /><figcaption aria-hidden="true">Japan单位制</figcaption></figure><p>点击软件主界面左上角<strong>配置快捷按钮</strong>进行配置，此处配置均为全局配置，即再次运行软件后配置仍有效。通常需调整<code>Database Definitions</code>配置页下的弹簧表和默认单位制，用户修改过的配置将以加粗黑体展现。<strong>注意：设置完成后必须点击保存，否则不生效。</strong></p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210605195730734.png"alt="image-20210605195730734" /><figcaption aria-hidden="true">image-20210605195730734</figcaption></figure></li><li><p>默认弹簧表</p><p>CaesarII提供了极其丰富的弹簧表选项，涉及多个国家的不同行业，国内项目一般采用电力标弹簧（<code>China Power</code>）或者石化标弹簧（<code>SINOPEC (China)</code>）。</p></li><li><p>最大允许内存</p><p>21世纪的今天个人电脑的内存都动辄4GB、8GB，更别谈专用工作站，因此有必要将软件最大允许使用内存值放宽点，以使运行更流畅。建议修改<code>Miscellanelous Options</code>配置页下<code>Memory Allocated (Mb)</code>数值在512MB以上。</p></li><li><p>默认数据目录</p><p>默认数据目录极其重要，上述自定义配置及计算文件默认存放位置都在该目录下。除非特殊需求，一般<strong>强烈不建议修改</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210605202108668.png"alt="默认数据目录" /><figcaption aria-hidden="true">默认数据目录</figcaption></figure></li></ol><h3 id="结果分析">结果分析</h3><p>// TODO</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>热电装置安全隔离</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E7%83%AD%E7%94%B5%E8%A3%85%E7%BD%AE%E5%AE%89%E5%85%A8%E9%9A%94%E7%A6%BB%E6%80%BB%E7%BB%93/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/%E7%83%AD%E7%94%B5%E8%A3%85%E7%BD%AE%E5%AE%89%E5%85%A8%E9%9A%94%E7%A6%BB%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="安全隔离目的">安全隔离目的</h2><p>安全隔离的主要目的是将生产介质完全隔离，防止由于切断阀关闭不严，导致高压介质串入低压系统或有害介质泄漏，进而影响生产，甚至造成事故。</p><p>结合实际使用经验，很多阀门都存在关闭不严的情况，一味增加切断阀数量或额外设置止回阀无法确保完全隔离。使用8字盲板、拆卸短节等安全隔离手段能够将系统彻底隔离；对于生产单位而言，8字盲板等安全措施需登记入账，开、停工时需逐一核实状态，管理级别相对较高。</p><h2 id="风险点归纳">风险点归纳</h2><h3 id="管廊">管廊</h3><p>界区处至少对有毒、有害、易燃、易爆介质使用盲板完全隔离，常见介质包括燃料气、氮气、点火油、氨水、脱硫废水等，其余介质隔离要求可参见总体院统一规定。</p><h3 id="锅炉">锅炉</h3><ol type="1"><li><p>反上水是典型的“高压串低压”风险点，定排系统压力通常高达12MPag，而疏水泵出口压力只有0.8MPag左右，两个系统压力等级相差甚大；据业主反映，曾发生由于阀门自身密封不严高压水串入了低压管道，导致管道爆裂伤人的事故，应引起警醒。<u><strong>风险工况：高压串低压</strong></u></p></li><li><p>锅炉汽包为密闭空间，停工阶段人员可能进入检修。如果相关充氮保护线阀门存在内漏，氮气一旦漏入汽包，可能造成人员窒息。<u><strong>风险工况：有害介质泄漏</strong></u></p></li><li><p>点火油线，燃料气线，近期项目锅炉还掺烧VOCS等工艺废气，上述危险介质倘若漏进炉膛，可能造成“闪爆”事故发生。<u><strong>风险工况：有害介质泄漏</strong></u></p></li><li><p>由于煤仓内的存煤可能发生自燃，一般均设置消防氮气线，停工阶段人员可能从顶部爬梯进入煤仓内部检修，因此存在造成人员窒息的风险。<u><strong>风险工况：有害介质泄漏</strong></u></p></li></ol><h3 id="汽机">汽机</h3><ol type="1"><li><p>除氧器由于设置了充氮保护线，且为密闭空间，同锅炉汽包类似存在氮气泄漏的风险。<u><strong>风险工况：有害介质泄漏</strong></u></p></li><li><p>高加同样设置充氮保护线，但鉴于高加汽侧操作压力很高，因此同时存在两种风险工况。<u><strong>风险工况：高压串低压+有害介质泄漏</strong></u></p></li><li><p>当给水泵入口阀关闭，出口阀忘记关闭且出口止回阀存在内漏，母管侧高压锅炉给水将串入入口线，造成入口低磅级管线和阀门爆裂。<u><strong>风险工况：高压串低压</strong></u></p></li><li><p>给水泵再循环线隔离阀及出口阀同时关闭，此时启动给水泵，再循环线隔离阀将承受最大给水压力，因此该阀本身及之前管线按给水压力设计。<u><strong>风险工况：高压串低压</strong></u></p></li></ol><h2 id="隔离方法">隔离方法</h2>]]></content>
    
    
    
    <tags>
      
      <tag>工业技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SPPID 学习笔记</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/SPPID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/SPPID%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="图纸管理器">图纸管理器</h2><h3 id="列表视图">列表视图</h3><p>窗口菜单：【View】→【Customize Current View】，常用列表项如下：</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E5%2588%2597%25E8%25A1%25A8%25E8%25A7%2586%25E5%259B%25BE.png"alt="列表视图" /><figcaption aria-hidden="true">列表视图</figcaption></figure><h3 id="版本备份">版本备份</h3><p>为避免数据丢失，应定期备份图纸。右键菜单：【Revisions】→【NewVersion】。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210512092700147.png"alt="版本查看" /><figcaption aria-hidden="true">版本查看</figcaption></figure><h3 id="手动同步数据">手动同步数据</h3><p>右键菜单：【Out-Of-Date-Drawings】→【Update】，同步成功后，第一列黄色惊叹号将消除，否则请查看report寻找失败原因。</p><h2 id="绘图区">绘图区</h2><h3 id="常规操作">常规操作</h3><ul><li>按住<code>Alt</code>键移动可保持连接关系</li><li>按住<code>Ctrl</code>键移动复制对象</li><li>选择图面现有Label后右键<code>Place New</code>快速新增Label</li><li>SPP&amp;ID具备自动保存功能，手动保存将清空缓存区，带来撤销操作失效。</li><li>Piperun拆分原则：<ul><li><p>管道分支</p></li><li><p>管道断开</p></li><li><p>任一管道属性变化</p></li></ul></li><li>介质填写在OPC大框中，注意放置时方向。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/OPC%25E6%2596%25B9%25E5%2590%2591.png"alt="OPC方向" /><figcaption aria-hidden="true">OPC方向</figcaption></figure><ul><li><p>配对OPC不建议放置在stockpile中，窗口菜单：【Tools】→【Options】→【Placement】取消对应选项。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E9%2585%258D%25E5%25AF%25B9OPC.png"alt="配对OPC" /><figcaption aria-hidden="true">配对OPC</figcaption></figure></li><li><p>选择静态网格</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E9%259D%2599%25E6%2580%2581%25E7%25BD%2591%25E6%25A0%25BC.png"alt="静态网格" /><figcaption aria-hidden="true">静态网格</figcaption></figure></li></ul><h2 id="图例浏览器">图例浏览器</h2><h2 id="属性窗口">属性窗口</h2><h2 id="工程数据管理器">工程数据管理器</h2><ul><li>自定义管理器列表项</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>善用佳软</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SP3D 学习笔记</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/SP3D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/SP3D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识">前置知识</h2><ul><li><p><code>system</code>层级不设防，应注意选对层级，避免选择<code>system</code>层级。</p></li><li><p>如果只能工具条没有自动跳到下一步（即需要点击<code>accept</code>按钮完成当前步骤的选择）就说明该步操作支持多选。</p></li><li><p><strong>黄色高亮</strong>说明存在关联关系</p></li><li><p>属性页中的坐标永远都是绝对坐标</p></li><li><p><code>bu rule</code>即需要在图面手动选择操作</p></li><li><p>同一个用户可以拥有多重身份，只有身份相同的用户才可以操作相互的模型</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/S3D%25E7%2594%25A8%25E6%2588%25B7%25E8%25BA%25AB%25E4%25BB%25BD.png"alt="S3D用户身份" /><figcaption aria-hidden="true">S3D用户身份</figcaption></figure></li><li><p>数据库架构（报表数据库、项目层级数据、模型数据库、元件数据库）</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%25E6%259E%25B6%25E6%259E%2584.png"alt="数据库架构" /><figcaption aria-hidden="true">数据库架构</figcaption></figure></li></ul><h2 id="通用模块">通用模块</h2><h3 id="组合过滤器">组合过滤器</h3><p>过滤器可按<code>what</code>和<code>where</code>组合的方式创建，常用方式是直接选择<code>System</code>标签页里的对象。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E7%25BB%2584%25E5%2590%2588%25E8%25BF%2587%25E6%25BB%25A4%25E5%2599%25A820210528.png"alt="组合过滤器20210528" /><figcaption aria-hidden="true">组合过滤器20210528</figcaption></figure><h3 id="捕捉工具条">捕捉工具条</h3><p>根据需要实时开关捕捉对象，比如测量到封头距离时暂时关闭管口捕捉，以免附近管口形成干扰。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%258D%2595%25E6%258D%2589%25E5%25B7%25A5%25E5%2585%25B7%25E6%259D%25A1.png" /></p><p>捕捉设置如下图，一般选择特征点、管嘴、等分点和参考方向线即可满足日常画图需求。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%258D%2595%25E6%258D%2589%25E8%25AE%25BE%25E7%25BD%25AE2020529.png"alt="捕捉设置2020529" /><figcaption aria-hidden="true">捕捉设置2020529</figcaption></figure><h3 id="快速定位对象">快速定位对象</h3><p>在工作区浏览器中输入位号（支持通配符），找到对象后点击<code>满屏</code>按钮。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210528231943859.png" /></p><h3 id="对象动态提示">对象动态提示</h3><h4 id="问题描述">问题描述</h4><p>S3D的默认状态为：光标悬停在轴线上时只显示<code>Gridline</code>字样，不显示具体轴线号，非常不便。</p><h4 id="操作步骤">操作步骤</h4><ol type="1"><li><p>依次点击菜单项<code>[Tools]→[Options]→[ToolTips]</code>，对象类型选择<code>Grid Line</code>，标签类型选择<code>Structure ToolTip Grid Line</code>。</p><p><img src="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/tooltip.png" /></p></li><li><p>建议界面只显示0米层轴网；<code>Piping</code>模块下过滤器选择<code>All</code>再查看；上述操作完成后保存<code>Session</code>文件，避免下次打开重复设置。</p></li></ol><h3 id="旋转视图">旋转视图</h3><p>旋转视图命令有两种用法：绕坐标轴旋转和绕对象轴线旋转，第二种方法更常用。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%2597%258B%25E8%25BD%25AC%25E8%25A7%2586%25E5%259B%25BE.gif"alt="旋转视图" /><figcaption aria-hidden="true">旋转视图</figcaption></figure><h3 id="切割视图">切割视图</h3><p>按由对象围成的区域切割视图，应先点击命令，再依次选择对象。</p><h3 id="镜像拷贝">镜像拷贝</h3><p>镜像拷贝有两种方式，方式一需依次选择起始点和目标点，操作如下。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E9%2595%259C%25E5%2583%258F%25E6%258B%25B7%25E8%25B4%259D.gif"alt="镜像拷贝" /><figcaption aria-hidden="true">镜像拷贝</figcaption></figure><h2 id="结构模块">结构模块</h2><h3 id="轴网命名">轴网命名</h3><p>标高命名选择<code>Position</code>，新增的层将以层高命名，比如<code>El.9.000m</code>；轴网命名选择<code>AlphaNumric</code>。</p><p><img src="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E5%25B1%2582%25E5%2591%25BD%25E5%2590%258D.png" alt="层命名" style="zoom:67%;"  /></p><h3 id="轴网修改">轴网修改</h3><p>修改轴网原点坐标通过属性标签页完成，修改轴线或者层通过相应水平工具条完成，对应的过滤器是<code>Grid Plane</code>和<code>Elevation Plane</code>。</p><h3 id="关闭标尺">关闭标尺</h3><p>关闭标尺显示：【View】→【Rulers】</p><h3 id="连续布置杆件">连续布置杆件</h3><p>布置完一根杆件后，点击智能工具条的终点按钮即可连续布置下一根管件，并能基层上一根杆件的属性。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E8%25BF%259E%25E7%25BB%25AD%25E5%25B8%2583%25E7%25BD%25AE%25E5%258D%2595%25E6%25A0%25B9%25E6%259D%2586%25E4%25BB%25B6.png"alt="连续布置单根杆件" /><figcaption aria-hidden="true">连续布置单根杆件</figcaption></figure><h3 id="梁捕捉要点">梁捕捉要点</h3><p>放置梁时，梁的起始点应捕捉柱子与某根轴线的交点，如此便能将梁与层关联起来。</p><h2 id="设备模块">设备模块</h2><h3 id="正负实体">正负实体</h3><p>需要进行布尔运算的<code>shape</code>必须放在同一<code>solid</code>下，否则不会生效。</p><h3 id="重设定位点">重设定位点</h3><p><strong>注意：移动操作时应取消<code>fast move</code>模式</strong></p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E9%2587%258D%25E8%25AE%25BE%25E5%25AE%259A%25E4%25BD%258D%25E7%2582%25B9.gif"alt="重设定位点" /><figcaption aria-hidden="true">重设定位点</figcaption></figure><h2 id="管道模块">管道模块</h2><h3 id="单位设置">单位设置</h3><ul><li>长度的单位为mm，精度改为4位；</li><li>坡度单位改为mm/m，精度默认。</li></ul><h3 id="管道组成">管道组成</h3><ul><li><p>Pipe Feature</p><p>大部分管道操作应选择Feature过滤器</p></li><li><p>Pipe Part</p><p>Part过滤器常用于出料设置和增加批注</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">`-- Pipeline<br>    `-- Pipe Runs<br>        `-- Pipe Features<br>            |-- Ports<br>            |-- Parts&amp;Components<br>            `-- Connections<br></code></pre></td></tr></table></figure><h3 id="管道命名">管道命名</h3><p>为确保后续<strong>二三维校验</strong>顺利进行，手动新建管道（<code>pipeline</code>）时应以短管线号命名，一般手动输入即可。如果后台配置了管线号命名规格，可根据物料代号和流水号自动生成，很少会用。</p><p><strong>注意：流体类型必须设置，否则后续无法关联。</strong></p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E7%25AE%25A1%25E7%25BA%25BF%25E5%258F%25B7%25E5%2591%25BD%25E5%2590%258D.png"alt="管线号命名" /><figcaption aria-hidden="true">管线号命名</figcaption></figure><p>新建管段（<code>piperun</code>）的管段号不采用手动输入，选择所在管道后并确定了管径、等级、保温信息，系统将依据预置命名规则自动生成管段号。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E7%25AE%25A1%25E6%25AE%25B5%25E5%258F%25B7%25E5%2591%25BD%25E5%2590%258D.png"alt="管段号命名" /><figcaption aria-hidden="true">管段号命名</figcaption></figure><h3 id="斜管角度">斜管角度</h3><p>修改斜管角度前必先锁定面，否则无法输入。其原因是在未锁定的前提下，给定的斜管角度存在无穷多个方向，软件无法判断。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%2596%259C%25E7%25AE%25A1%25E8%25A7%2592%25E5%25BA%25A6.png"alt="斜管角度" /><figcaption aria-hidden="true">斜管角度</figcaption></figure><h3 id="调整斜接直管">调整斜接直管</h3><p>目前没有很好的办法，只能通过删掉再连的方式调整。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%E8%B0%83%E6%95%B445%C2%B0%E8%BF%9E%E6%8E%A5%E9%AB%98%E5%BA%A6.gif" /></p><h3 id="改变piperun">改变piperun</h3><p>先选择需要改变的features，然后通过图形方式选择新的piperun。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E5%25BF%25AB%25E9%2580%259F%25E6%2594%25B9%25E5%258F%2598piperun.gif" /></p><h3 id="最小直管段">最小直管段</h3><p>SP3D中可能会配置最小直管段的规则，一般不小于管道外径，可按以下操作快速定位该长度。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E5%25BF%25AB%25E9%2580%259F%25E5%25AE%259A%25E9%2595%25BF%25E6%259C%2580%25E7%259F%25AD%25E7%259B%25B4%25E7%25AE%25A1%25E6%25AE%25B5.gif"alt="快速定长最短直管段" /><figcaption aria-hidden="true">快速定长最短直管段</figcaption></figure><h3 id="镜像复制">镜像复制</h3><p>选择两个点从而连成一条线，默认该直线就作为镜像面的中垂线；如果又选择了镜像面，则具体确定镜像面的位置。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E9%2595%259C%25E5%2583%258F%25E5%25A4%258D%25E5%2588%25B6.gif" /></p><h3 id="偏移定位">偏移定位</h3><p>偏移定位一般可采用临时原点或偏移捕捉两种方式，经实践，后者操作效率更高。注意：锁定平面后才能捕捉到偏移线。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%E5%81%8F%E7%A7%BB%E5%AE%9A%E4%BD%8D.gif" /></p><h3 id="翻转管件">翻转管件</h3><p>当管道流向确定后，具备流向性的管阀件禁止翻转，应先去除管道流向性。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E7%25BF%25BB%25E8%25BD%25AC%25E5%2585%2583%25E4%25BB%25B6.gif"alt="翻转元件" /><figcaption aria-hidden="true">翻转元件</figcaption></figure><h3 id="改变三通流向">改变三通流向</h3><p>插入三通时选择装配连接点改变三通的流向</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%E4%B8%89%E9%80%9A%E6%B5%81%E5%90%91.gif" /></p><h3 id="改变插入位置">改变插入位置</h3><p>预览时选择合适的插入点来修改插入位置</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%E6%8F%92%E5%85%A5%E5%AE%9A%E4%BD%8D%E7%82%B9.gif" /></p><h3 id="管口捕捉">管口捕捉</h3><p>画管子时必须保证<strong>管口捕捉</strong>处于激活状态，否则管子不能正确连接。选择不合适时会弹出新建管段对话框，应引起注意。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E7%25AE%25A1%25E5%258F%25A3%25E6%258D%2595%25E6%258D%2589.png" /></p><h3 id="冗余连接点">冗余连接点</h3><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5%E7%82%B9.gif" /></p><h3 id="特殊件">特殊件</h3><h4 id="角阀">角阀</h4><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E8%25A7%2592%25E9%2598%2580.gif" /></p><h2 id="支吊架模块">支吊架模块</h2><p>放置支吊架有三种方式：</p><ul><li><p>通过结构放置</p><p>要求支吊架与结构在某个面上交叉</p></li><li><p>通过定位点放置</p></li><li><p>通过参考放置</p></li><li><p>通过逻辑架放置</p><p>即以逻辑架为基础用 part 搭积木的方式放置</p></li></ul><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%E6%94%AF%E5%90%8A%E6%9E%B6%E6%A8%A1%E5%9D%97.PNG"alt="支吊架模块" /><figcaption aria-hidden="true">支吊架模块</figcaption></figure><h2 id="出图与报表">出图与报表</h2><h3 id="快选螺栓垫片">快选螺栓垫片</h3><p>// TODO</p><h3 id="批量不出料">批量不出料</h3><p>常规操作配对法兰、垫片及紧固件不出料需单独设置，步骤非常繁琐且容易遗漏；希望垫片及紧固件出料设置继承配对法兰，即配对法兰不出料，相应的垫片及紧固件亦不出料，而且可以批量操作。具体步骤如下：</p><ol type="1"><li><p>新建S3D_PLUGINS目录，将<code>BoltedJointNotReported.dll</code>拷到此目录下。</p></li><li><p>打开S3D软件，依次点击<code>[Tools]→[Custom Commands]→[Add]</code>菜单项，弹出插件加载窗口；前两行分别填入<code>D:\S3D_PLUGINS\BoltedJointNotReported.dll,BoltedJointNotReported.BoltedJointNotReported</code>，<code>BoltedJointNotReported</code>后点击ok按钮。</p></li></ol><p><img src="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%258F%2592%25E4%25BB%25B6%25E5%258A%25A0%25E8%25BD%25BD%25E9%2585%258D%25E7%25BD%25AE.png" alt="插件加载配置" style="zoom:67%;" /></p><ol start="3" type="1"><li><p>新建一个过滤器，将需要批量处理的管子都放到此过滤器下；按先前的常规操作，只设置配对法兰的出料属性为<code>Not to be reported</code>，这一步不可省略。点击如下窗口的<code>run</code>按钮，选择刚才新建的过滤器，软件即开始自动设置垫片及紧固件不出料。耗时或长或短，视待处理的管子数量，请耐心等待！</p></li><li><p>建议上述操作在最后出图出料前一次性完成，软件操作完成后一定要人工检查下单线图出料设置是否正确。本说明仅是建议性操作指南，具体还要咨询信息中心。</p></li></ol><h3 id="报表功能">报表功能</h3><p>常规Excel格式报表都可以通过<code>Run Report</code>功能（菜单项：【Tools】→【RunReport】）导出，不必专门切换至<code>Drawings And Reports</code>模块。但是该功能导出的报表不能保存到服务器端，这意味每次导出都得重新设置一遍。另外，本机应预先安装Excel软件，并满足以下条件：</p><ol type="1"><li>32位版本Excel</li><li>启用Excel宏功能</li></ol><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/EXCEL%25E5%25AE%258F%25E8%25AE%25BE%25E7%25BD%25AE.png" /></p><h3 id="单线分图">单线分图</h3><p>在需要分图的位置插入控制点</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E5%2588%2586%25E5%259B%25BE.gif"alt="分图" /><figcaption aria-hidden="true">分图</figcaption></figure><h3 id="单线信息">单线信息</h3><p>由于子层级属性默认为继承方式，建议在顶层<code>Drawings By Query Manager</code>属性中统一设置单线图信息。</p><ul><li><p>坐标系统在<code>Style</code>标签页下设置</p></li><li><p>图框信息在<code>Custom</code>标签页下设置</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E5%258D%2595%25E7%25BA%25BF%25E5%259B%25BE%25E4%25BF%25A1%25E6%2581%25AF.png" /></p></li></ul><h3 id="平面图">平面图</h3><p>首先选择图框和图纸名称</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/202201032107694.png" /></p><p>再设置坐标和比例</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/202201032108739.png" /></p><h2 id="故障排除">故障排除</h2><h3 id="todolist">TODOList</h3><ol type="1"><li><p>管段流向冲突</p><p>提示run流向冲突，错误位置定位在设备管口，解决方法是设管口<strong>FlowDirection</strong>属性的值为<strong>undefined</strong>。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%25B5%2581%25E5%2590%2591%25E5%2586%25B2%25E7%25AA%2581.png"alt="流向冲突" /><figcaption aria-hidden="true">流向冲突</figcaption></figure></li></ol><h3 id="权限不一致">权限不一致</h3><p>权限不一致会带来很多问题，典型问题包括：多个feature无法一起移动，多个对象无法统一设置属性。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%259D%2583%25E9%2599%2590%25E4%25B8%258D%25E4%25B8%2580%25E8%2587%25B4%25E6%2597%25A0%25E6%25B3%2595%25E7%25A7%25BB%25E5%258A%25A8.gif"alt="权限不一致无法移动" /><figcaption aria-hidden="true">权限不一致无法移动</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%259D%2583%25E9%2599%2590%25E4%25B8%258D%25E4%25B8%2580%25E8%2587%25B4%25E6%2597%25A0%25E6%25B3%2595%25E7%25A7%25BB%25E5%258A%25A8%25E5%2590%258C%25E6%2584%258F%25E8%25AE%25BE%25E7%25BD%25AE%25E5%25B1%259E%25E6%2580%25A7.png"alt="权限不一致无法移动同意设置属性" /><figcaptionaria-hidden="true">权限不一致无法移动同意设置属性</figcaption></figure><h3 id="无法重设原点">无法重设原点</h3><p>现象是无法点中想要的位置，原因是视图显示方式错误</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%2597%25A0%25E6%25B3%2595%25E6%2594%25BE%25E7%25BD%25AE%25E4%25B8%25B4%25E6%2597%25B6%25E5%258E%259F%25E7%2582%25B9.gif" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>善用佳软</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoCAD 学习笔记</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/AutoCAD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="优化设置">优化设置</h2><h3 id="关闭信息中心ftpsites">关闭信息中心、FTPSites</h3><p>将注册表<code>HKEY_CURRENT_USER\SOFTWARE\Autodesk\AutoCAD\R18.2\ACAD-A001:804\InfoCenter</code>项下键<code>InfoCenterOn</code>键的值改为1，如此界面右上角信息中心就会消失；</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/CAD%25E4%25BF%25A1%25E6%2581%25AF%25E4%25B8%25AD%25E5%25BF%2583.png" /></p><p>删除注册表<code>HKEY_CURRENT_USER\SOFTWARE\Autodesk\AutoCAD\R18.2\ACAD-A001:804\FileNavExtensions</code>项下的<code>ACPROJECT</code>和<code>FTPSites</code>键值对。</p><h2 id="清理图层">清理图层</h2><p>将多个图层合并成到一个图层，成功合并后自动删除原图层。</p><p><img src="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E5%2590%2588%25E5%25B9%25B6%25E5%259B%25BE%25E5%25B1%2582.gif" alt="合并图层" style="zoom:67%;" /></p><h2 id="清理图纸">清理图纸</h2><p>常规方法为<code>PU</code>大法或者网上介绍的另存<code>DXF</code>后再存回<code>DWG</code>；对于图层还可采用<code>LAYDEL</code>强制删除或<code>LAYMRG</code>合并到0层。但碰到顽固对象时，上述方法要么无法清理，要么存在丢失图元的风险。AutoCAD2020及以上版本强化了清理功能，新增支持查看对象关联关系，现在可通过处理关联对象的方法间接清理顽固对象，不失为一剂<strong>治标治本</strong>的良药。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%25B8%2585%25E7%2590%2586%25E5%258A%25A0%25E5%25BC%25BA%25E7%2589%2588.png"alt="清理加强版" /><figcaption aria-hidden="true">清理加强版</figcaption></figure><h2 id="动态块">动态块</h2><p>双击参数可以快速调出动作</p><h3 id="缩放">缩放</h3><p>可根据需要选择缩放动作的基准类型：依赖（参数的起点或终点）、独立（x、y坐标确定的具体点）。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%E7%BC%A9%E6%94%BE.gif" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>善用佳软</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AUP 学习笔记</title>
    <link href="/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/AUP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/%E7%B3%8A%E5%8F%A3%E7%94%9F%E8%AE%A1/AUP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="模块">模块</h2><h3 id="母管模块">母管模块</h3><p><code>FixImbalanceFlow</code>属性（设计阶段设为true）：</p><ul><li><p>true：用于设计阶段，输入=输出</p></li><li><p>false：用于实际操作工况，输入≠输出 ### 多级汽机模块</p></li></ul><ol type="1"><li><p>属性设置</p><p><code>EffMethod</code>属性选择<code>Constant</code>，即级组效率为常数；抽、排汽压力和温度通常设为<code>Fixed</code>，而将<code>StageData</code>属性页中的机组效率设为<code>Free</code>；为避免温度给定值非法，可先将效率固定、温度放开，给定效率后算出温度约值。</p></li></ol><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E5%25A4%259A%25E7%25BA%25A7%25E6%25B1%25BD%25E8%25BD%25AE%25E6%259C%25BA.png" /></p><ol start="2" type="1"><li><p>流量平均</p><p>当从多台汽轮机抽汽且抽汽量存在固定比例时，应将对应汽轮机模块抽汽量设为<code>Free</code>，再书写公式补充所缺约束，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">CONSTRAINTS<br>  <span class="hljs-comment">// ST1、ST2各自1抽汽量相等</span><br>  ST1.<span class="hljs-built_in">SteamOut</span>(<span class="hljs-string">&quot;Extr1&quot;</span>).F = ST2.<span class="hljs-built_in">SteamOut</span>(<span class="hljs-string">&quot;Extr1&quot;</span>).F;<br>END<br></code></pre></td></tr></table></figure><p>上述代码中，变量可直接从属性页面拖入，避免输错。代码完成后，必须编译检查错误。</p></li></ol><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589%25E5%2585%25AC%25E5%25BC%258F.png"alt="自定义公式" /><figcaption aria-hidden="true">自定义公式</figcaption></figure><h3 id="除氧器模块">除氧器模块</h3><p>除氧器排气量约为每吨进水的1‰~3‰，软件默认计算方法如下，需要自行修正。</p><figure><imgsrc="https://gitee.com/romango/picbed/raw/master/picgo/image-20210520223728603.png"alt="排气率公式" /><figcaption aria-hidden="true">排气率公式</figcaption></figure><p>除氧器模块<code>DeaeratorMode</code>属性设为<code>FixedVentFlow</code>，即排气量给定；再将<code>BlowSteam("BlowSteam1").F</code>属性设为<code>Free</code>，此时会提示缺少一个约束，通过下列公式来补充：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">CONSTRAINTS<br>  <span class="hljs-comment">// 排气量 = 进水总量 * 排气率</span><br>  DEAERATOR.BlowSteam(<span class="hljs-string">&quot;BlowSteam1&quot;</span>).F = DEAERATOR.Fwin * <span class="hljs-number">0.002</span>;<br>END   <br></code></pre></td></tr></table></figure></p><h3 id="高加模块">高加模块</h3><p>如果高加无过冷段，出口凝液按饱和水考虑，应将<code>Thwout</code>设为Free；<code>VFhwout</code>设为Fixed，同时赋为0。</p><blockquote><p>对于ASPEN软件，干度为0默认为饱和水，干度为1默认为饱和汽</p></blockquote><p>闪蒸方法必须根据给定的参数类型作出相应调整，典型设置如下：</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E9%25AB%2598%25E5%258A%25A0%25E9%2597%25AA%25E8%2592%25B8%25E6%25A8%25A1%25E5%25BC%258F.png" /></p><h2 id="调试">调试</h2><p>为便于排错，应视情况将输出结果报错级别设为<strong>High</strong>或以上。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/%25E6%258A%25A5%25E9%2594%2599%25E7%25BA%25A7%25E5%2588%25AB.png"alt="报错级别" /><figcaption aria-hidden="true">报错级别</figcaption></figure><h2 id="错误">错误</h2><h3 id="物性数据加载失败">物性数据加载失败</h3><p>如果碰到物性数据库加载失败的情况，可按下图步骤处理。</p><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/Aspen%20Property%20Error.png" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>善用佳软</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本站文章写作规范</title>
    <link href="/%E6%9D%82%E8%B4%A7%E9%93%BA/%E6%9C%AC%E7%AB%99%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/"/>
    <url>/%E6%9D%82%E8%B4%A7%E9%93%BA/%E6%9C%AC%E7%AB%99%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>参照阮一峰大神的<ahref="https://github.com/ruanyf/document-style-guide">《中文技术文档的写作规范》</a>一文，结合个人写作习惯，制定了本站文章的写作规范，具体如下。</p><h2 id="标题">标题</h2><h3 id="层级">层级</h3><p>文章按篇、章、节、段的架构，对应标题可分为四级。</p><ul><li>一级标题：文章的标题</li><li>二级标题：大标题</li><li>三级标题：小标题</li><li>四级标题：三级标题下的小标题</li></ul><h3 id="原则">原则</h3><ul><li><p>取消一级标题</p><p>为了使用 hexo自动生成文章信息，每篇文章的顶部都已采用YAML专门标记了文章的标题、分类等，因此正文中不再出现一级标题。</p></li><li><p>慎重使用四级标题</p><p>除非特别长的文章，正常使用二级、三级标题即可满足需求。若有需要，应优先采用有序列表划分后续内容。</p></li><li><p>杜绝单独的某级标题</p></li></ul><h2 id="行文">行文</h2><h3 id="句子">句子</h3><p>为了方便阅读和识别，句子应遵循下列原则：</p><ul><li><p>英文单词前后各留一个半角空格</p><blockquote><p>很多人用过的第一个 ssh 客户端是 putty 软件。</p></blockquote></li><li><p>将长句子拆分成短句子</p></li></ul><h3 id="写作风格">写作风格</h3><p>技术类文章一般陈述的是观点和事实，尽量少体现作者的态度和感情，因此行文风格应直接、简单、精炼。</p><ul><li><p>使用主动句式，不使用被动句式</p><blockquote><p>不好：此软件被删除后</p><p>好：删除此软件后</p></blockquote></li><li><p>使用肯定句式，不使用否定句式</p><blockquote><p>不好：确认没有用户在线</p><p>好：确认所有用户已退出</p></blockquote></li><li><p>名词前不要使用过多的形容词。</p><blockquote><p>不好：这是一个阳光明媚且从未如此快乐过的难忘的午后。</p><p>不好：这是一个阳光明媚且从未如此快乐过的午后，这个午后真难忘！</p></blockquote></li></ul><h2 id="段落">段落</h2><ul><li>段落不需要首行缩进</li><li>一个段落应该只有一个主旨</li><li>段落的第一句话尽量体现本段落的主旨</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>探秘注册表 HKCR 根键</title>
    <link href="/%E6%9D%82%E8%B4%A7%E9%93%BA/%E6%8E%A2%E7%A7%98%E6%B3%A8%E5%86%8C%E8%A1%A8HKCR%E6%A0%B9%E9%94%AE/"/>
    <url>/%E6%9D%82%E8%B4%A7%E9%93%BA/%E6%8E%A2%E7%A7%98%E6%B3%A8%E5%86%8C%E8%A1%A8HKCR%E6%A0%B9%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>无论是计算机老鸟还是小白，多少都接触过点注册表，这里俨然就是 Windows操作系统的藏宝库。注册表由单词<code>Registry</code>直译而来，不过笔者认为译作<strong>配置信息数据库</strong>更加贴切。注册表是一种集中存储方式，linux系统采用配置文件存储配置信息，比如<code>bash.rc</code>、<code>my.cnf</code>等等，这种方式是松散的。</p><p>注册表包含五个根键，根键、子健、键值对的概念这里不再累述。排在第一个的根键为<code>HKEY_CLASSES_ROOT</code>，它是<code>HKEY_LOCAL_MACHINE\Software\Classes</code>子健和<code>HKEY_CURRENT_USER\Software\Classes</code>子健的合并视图，主要存储了文件类型、右键菜单和COM组件等信息。展开该根键后，出现一大堆后缀名和GUID 序列，下面将谈谈这些内容的用途。</p><h2 id="打开方式">打开方式</h2><h3 id="剖析注册表">剖析注册表</h3><p>双击一个文本文件后，为什么张三电脑上打开的是记事本程序，而李四的电脑上确是sublime？想要直接弄清楚注册表中的端倪，有点难度。不妨换个思路，将刚才的文本文件重命名为<code>test.abcd</code>，操作系统现在不知道该如何打开这个文件了，文件图标也变成了白色。使用<ahref="http://www.torchsoft.com/download/RegistryWorkshop.exe">RegistryWorkshop</a>工具给当前注册表拍个快照，然后双击打开<code>test.abcd</code>，选择<strong>始终用</strong>记事本打开，接着对比当前注册表和刚生成的快照。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210928224718742.png"alt="image-20210928224718742" /><figcaption aria-hidden="true">image-20210928224718742</figcaption></figure><p>对比结果显示，新增了<code>HKEY_CLASSES_ROOT\.abcd</code>和<code>HKEY_CLASSES_ROOT\abcd_auto_file</code>两个子项；<code>.abcd</code>子项默认键值对描述了该后缀名对应的文件类型<code>abcd_auto_file</code>；而文件类型子项才真正记录了打开、编辑该类型文件的程序。您可以依葫芦画瓢，给任何已知、未知的程序设置默认打开方式，这也是很多病毒的惯用伎俩。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210928232620565.png"alt="image-20210928232620565" /><figcaption aria-hidden="true">image-20210928232620565</figcaption></figure><h3 id="shellexecute-函数">ShellExecute 函数</h3><p>ShellExecute 的功能是对一个指定的文件执行某操作，函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HINSTANCE <span class="hljs-title">ShellExecuteA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HWND   hwnd, <span class="hljs-comment">// 父窗口句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpOperation, <span class="hljs-comment">// 指定操作：open、edit、print...</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpFile, <span class="hljs-comment">// 待操作的文件或程序</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpParameters, <span class="hljs-comment">// 操作参数，如果打开的是文件，该参数设为NULL</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR lpDirectory, <span class="hljs-comment">// 操作的工作目录</span></span></span><br><span class="hljs-params"><span class="hljs-function">  INT    nShowCmd <span class="hljs-comment">// 窗口显示方式</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，lpFile待操作文件的默认程序通过查询以上注册表项获得，lpOperation指定的具体操作与注册表 shell 项下的子项名称对应。</p><p>做个小试验，先将<code>HKEY_CLASSES_ROOT\txtfile\shell\print\command</code>默认键值改为calc.exe，然后编写一个非常简单的C++命令行程序，代码如下。在生成目录下新建test.txt文本文件，运行程序后不出意外将弹出计算器。当然，在文件上右键打印也会弹出计算器，ShellExecute函数其实就是实现了诸如打开、编辑和打印等文件交互式操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 调用系统默认程序打印文本文件</span><br>    <span class="hljs-built_in">ShellExecute</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;print&quot;</span>, <span class="hljs-string">L&quot;test.txt&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="右键菜单">右键菜单</h2><p>注册表项<code>shell</code>和<code>shellex</code>都与右键菜单相关联。<code>shell</code>子项对应普通右键菜单，通常用于选择某个程序打开文件；<code>shellex</code>对应级联菜单，功能相对复杂，一般只是记录了对某个COM 组件的引用。</p><p>按作用位置不同，右键菜单至少分文件右键菜单、文件夹右键菜单、文件夹空白处右处键菜单三类，下面将逐一介绍。</p><p>// TODO</p><h3 id="文件右键菜单">文件右键菜单</h3><h3 id="文件夹右键菜单">文件夹右键菜单</h3><h3 id="文件夹空白右键菜单">文件夹空白右键菜单</h3><h2 id="com-组件">COM 组件</h2>]]></content>
    
    
    
    <tags>
      
      <tag>注册表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用注册表项</title>
    <link href="/%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%B8%B8%E7%94%A8%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9/"/>
    <url>/%E6%9D%82%E8%B4%A7%E9%93%BA/%E5%B8%B8%E7%94%A8%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="autocad">AutoCAD</h2><h3 id="版本代号">版本代号</h3><table><thead><tr class="header"><th style="text-align: left;">版本号</th><th style="text-align: left;">版本名</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">R15.0</td><td style="text-align: left;">AutoCAD2002</td></tr><tr class="even"><td style="text-align: left;">R16.0</td><td style="text-align: left;">AutoCAD2004</td></tr><tr class="odd"><td style="text-align: left;">R16.1</td><td style="text-align: left;">AutoCAD2005</td></tr><tr class="even"><td style="text-align: left;">R16.1</td><td style="text-align: left;">AutoCAD2006</td></tr><tr class="odd"><td style="text-align: left;">R17.0</td><td style="text-align: left;">AutoCAD2007</td></tr><tr class="even"><td style="text-align: left;">R17.1</td><td style="text-align: left;">AutoCAD2008</td></tr><tr class="odd"><td style="text-align: left;">R17.2</td><td style="text-align: left;">AutoCAD2009</td></tr><tr class="even"><td style="text-align: left;">R18.0</td><td style="text-align: left;">AutoCAD2010</td></tr><tr class="odd"><td style="text-align: left;">R18.1</td><td style="text-align: left;">AutoCAD2011</td></tr><tr class="even"><td style="text-align: left;">R18.2</td><td style="text-align: left;">AutoCAD2012</td></tr><tr class="odd"><td style="text-align: left;">R19.0</td><td style="text-align: left;">AutoCAD2013</td></tr><tr class="even"><td style="text-align: left;">R19.1</td><td style="text-align: left;">AutoCAD2014</td></tr><tr class="odd"><td style="text-align: left;">R20.0</td><td style="text-align: left;">AutoCAD2015</td></tr><tr class="even"><td style="text-align: left;">R20.1</td><td style="text-align: left;">AutoCAD2016</td></tr><tr class="odd"><td style="text-align: left;">R21.0</td><td style="text-align: left;">AutoCAD2017</td></tr><tr class="even"><td style="text-align: left;">R22.0</td><td style="text-align: left;">AutoCAD2018</td></tr><tr class="odd"><td style="text-align: left;">R23.0</td><td style="text-align: left;">AutoCAD2019</td></tr><tr class="even"><td style="text-align: left;">R23.1</td><td style="text-align: left;">AutoCAD2020</td></tr></tbody></table><h3 id="产品代号">产品代号</h3><ul><li>8001 AutoCAD2010</li></ul><p>针对不同行业，CAD有多个版本：机械版、建筑版、电气版、LT版等，<ahref="https://www.cadforum.cz/en/product-codes-registry-of-autodesk-cad-applications-tip6922">这里有详细介绍。</a></p><h3 id="语言代号">语言代号</h3><ul><li>409 英文版</li><li>804 简体中文版</li></ul><p><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/CAD%25E6%25B3%25A8%25E5%2586%258C%25E8%25A1%25A8%25E8%25AF%25AD%25E8%25A8%2580%25E4%25BB%25A3%25E5%258F%25B7.png" /></p><h3 id="dll插件加载设置">DLL插件加载设置</h3><blockquote><p>HKEY_LOCAL_MACHINE:804<br /></p></blockquote><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/CAD%25E5%258A%25A0%25E8%25BD%25BD%25E6%25B3%25A8%25E5%2586%258C%25E8%25A1%25A8%25E9%25A1%25B9.png"alt="CAD加载注册表项" /><figcaption aria-hidden="true">CAD加载注册表项</figcaption></figure><ul><li><p><code>LOADCTRLS</code>：控制程序随CAD加载的方式，<code>0x02</code>代表随CAD启动一起加载，详细说明如下：</p><ul><li>0x01：Load the application upon detection of proxy object.</li></ul><blockquote><p>当检测到代理对象时加载程序</p></blockquote><ul><li>0x02：Load the application upon AutoCAD startup.</li></ul><blockquote><p>随CAD启动一起加载程序</p></blockquote><ul><li>0x04：Load the application upon invocation of a command.</li></ul><blockquote><p>以命令方式手动加载程序</p></blockquote><ul><li>0x08：Load the application upon request by the user or anotherapplication.</li></ul><blockquote><p>当用户或别的程序主动请求时加载程序</p></blockquote><ul><li>0x10：Do not load the application.</li></ul><blockquote><p>从不加载程序</p></blockquote><ul><li>0x20：Load the application transparently.</li></ul><p>　　　&gt; 透明加载程序</p></li><li><p><code>LOADER</code>：加载程序路径；</p></li><li><p><code>MANAGED</code>：加载程序类型，<code>0x01</code>代表托管程序。</p></li></ul><h2 id="软件安装信息">软件安装信息</h2><blockquote><p>HKEY_LOCAL_MACHINE</p></blockquote><h2 id="类型打开方式">类型打开方式</h2><blockquote><p>HKEY_CURRENT_USER</p></blockquote><p>其中<code>MRUList</code>明确了打开程序的显示次序</p><h2 id="右键菜单">右键菜单</h2><h3 id="资源管理器空白处">资源管理器空白处</h3><blockquote><p>HKEY_CLASSES_ROOT<br /></p><p>HKEY_CURRENT_USER</p></blockquote><h3 id="文件夹">文件夹</h3><blockquote><p>HKEY_CLASSES_ROOT</p><p>HKEY_CURRENT_USER</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>注册表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩转树莓派</title>
    <link href="/Linux/%E7%8E%A9%E8%BD%AC%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <url>/Linux/%E7%8E%A9%E8%BD%AC%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="系统安装">系统安装</h2><p>使用树莓派官方<ahref="https://www.raspberrypi.org/software/">Raspberry PiImager</a>工具安装系统非常简单。下载安装该软件后将SD卡（建议容量在32GB以上）插入读卡器，再来到我的电脑查看SD卡盘符。运行软件，先选择操作系统再选择SD卡（注意盘符是否对应），最后点击<strong>WRITE</strong>按钮自动下载安装。</p><p>由于国内网络环境问题，从官网下载镜像非常慢，建议用IDM等下载工具将<ahref="https://www.raspberrypi.org/software/operating-systems/">镜像文件</a>单独下载下来。第一步操作系统选择自定义操作系统，然后找到下载、解压好的<strong>img</strong>文件。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210912151200974.png"alt="image-20210912151200974" /><figcaption aria-hidden="true">image-20210912151200974</figcaption></figure><p>系统安装完成后可能需要设置无线网络、开启SSH服务等等。在点击<strong>Write</strong>按钮之前，按下<strong>Ctrl+Shift+X</strong>快捷键进行相关设置。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20210912151834329.png"alt="image-20210912151834329" /><figcaption aria-hidden="true">image-20210912151834329</figcaption></figure><h2 id="系统配置">系统配置</h2><h3 id="无线网络ssh">无线网络&amp;SSH</h3><p>如果上一步忘记设置无线网络和ssh，刷完系统后再弄也不迟。我的电脑中打开<code>boot</code>分区（其它分区不会出现），在该分区下新建名为<code>ssh</code>的文件，注意无后缀名。接着再新建配置文件<code>wpa_supplicant.conf</code>，内容如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">country=CN<br>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev<br>update_config=1<br><br>network=&#123;<br>ssid=<span class="hljs-string">&quot;无线网络名称&quot;</span><br>psk=<span class="hljs-string">&quot;无线网络密码&quot;</span><br>key_mgmt=WPA-PSK<br>priority=1<br>&#125;<br></code></pre></td></tr></table></figure><p>从读卡器中拔出SD卡，插入树莓派插槽，上电启动。打开路由器web管理页面查找树莓派ip地址，找到后直接登录ssh，用户名和密码为<code>pi/raspberry</code>。but，以上设置重启后将失效，因此登录后的第一件事就是使用<code>raspi-config</code>工具永久配置无线网络和ssh。必须以root权限执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo raspi-config<br></code></pre></td></tr></table></figure><h3 id="扩展分区空间">扩展分区空间</h3><p>树莓派系统大都安装在<code>/dev/root</code>分区下，但是默认分配给该分区的空间不够，导致后续无法正常安装软件、升级系统。<code>raspi-config</code>是树莓派命令行配置工具，选择该工具的第6项<strong>advancedoptions</strong>，再选择第1项<strong>ExpandFilesystem</strong>即可将未分配空间全部分配给root分区。</p><h3 id="更新软件源">更新软件源</h3><p>使用官方软件源安装软件非常缓慢，建议替换成清华源。</p><ul><li>编辑<code>/etc/apt/sources.list</code>文件，删除原文件所有内容，用以下内容取代：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi<br>deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi<br></code></pre></td></tr></table></figure><ul><li>编辑<code>/etc/apt/sources.list.d/raspi.list</code>文件，删除原文件所有内容，用以下内容取代：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui<br></code></pre></td></tr></table></figure><p>注意：网址末尾的<code>raspbian</code>重复两次是必须的。因为raspbian的仓库中除了APT软件源还包含其他代码。APT软件源不在仓库的根目录，而在<code>raspbian/</code>子目录下。编辑镜像站后，请使用<code>sudo apt-get update</code>命令，更新软件源列表，同时检查您的编辑是否正确。</p>]]></content>
    
    
    
    <tags>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>免输密码登陆SSH</title>
    <link href="/Linux/%E5%85%8D%E8%BE%93%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86SSH/"/>
    <url>/Linux/%E5%85%8D%E8%BE%93%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86SSH/</url>
    
    <content type="html"><![CDATA[<p>SSH是一种加密的网络传输协议，主要用途是远程登录系统，并提供一个交互式的虚拟终端或者直接远程执行命令。SSH还能扮演类似 SSL的角色，通过在网络中创建安全隧道，实现对客户端与服务端之间的数据加密。</p><p><a href="https://www.openssh.com/">OpenSSH</a> 是 SSH的开源实现，Windows 10 1803及后续版本都默认启用了OpenSSH，相关命令行工具存储于<code>C:\Windows\System32\OpenSSH</code>目录。工具可分为三类，简介如下：</p><ol type="1"><li><p>远程操作类</p><ul><li>ssh—OpenSSH 终端连接工具</li><li>scp—文件远程拷贝工具</li><li>sftp—OpenSSH 版 FTP</li></ul></li><li><p>密钥管理类</p><ul><li>ssh-add—将私钥添加到 ssh-agent 的代理缓存</li><li>ssh-keygen—生成、管理和转换密钥</li><li>ssh-keyscan—获取远程主机的 OpenSSH 公钥</li></ul></li><li><p>服务类</p><ul><li><p>sshd—OpenSSH 服务守护进程</p></li><li><p>ssh-agent—OpenSSH 私钥管理工具</p></li></ul></li></ol><p><strong>以下部分操作只适用于 Windows 系统登录 Linux 系统 ssh的场景！！！</strong></p><h2 id="创建密钥">创建密钥</h2><p>ssh密钥登录无需输入密码，更加方便且杜绝了暴力破解的风险。命令行中使用ssh-keygen 工具生成公钥/私钥对，一路回车使用缺省参数即可，Windows中生成的密钥默认保存到<code>C:\Users\[用户名]\.ssh</code>目录。生成的私钥文件是<code>id_rsa</code>，公钥文件是<code>id_rsa.pub</code>，pub即public，公开的、公用的意思。</p><h2 id="部署公钥">部署公钥</h2><p>在 .ssh目录下打开命令行，然后执行下列组合命令将刚生成的公钥文件上传到服务器登录用户的家目录。完成上述操作后，重新登录ssh 就无需输入密码了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">C:\Users\apple\.ssh&gt; <span class="hljs-built_in">type</span> id_rsa.pub | ssh dog@192.168.0.5 <span class="hljs-string">&quot;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys&quot;</span><br></code></pre></td></tr></table></figure><h2 id="其它设置">其它设置</h2><h3 id="免用户名登录">免用户名登录</h3><p>如果想进一步发扬程序员的三大美德，登录时连用户名都省掉，岂不更美哉？</p><p>首先在服务端新建一个与客户端同名的账户<code>useradd -m -s /bin/bash apple &amp;&amp; passwd apple</code>，然后再将其它账户的<code>.ssh</code>文件夹拷贝到新账户的家目录<code>cp -r /home/dog/.ssh /home/apple</code>。出于安全考虑，建议重新生成秘钥，这里只是演示下过程。上述操作用root 账户完成，拷贝过来的文件夹的所有者自然也是root，还需将所有者变更为新账户<code>chown -hR apple /home/apple/.ssh</code>。好了，现在可以直接用主机地址登录了<code>ssh 192.168.0.5</code>。</p><h3 id="putty自动登录">putty自动登录</h3><p>虽然中文版 putty 出现过严重的后门事件，且 Windows Terminal用起来也很舒服，但是putty仍有相当部分的拥趸。使用以上生成并部署完的密钥对，只需两步即可实现putty 免密码登录。</p><ol type="1"><li><p>转换公钥</p><p>OpenSSH 与 putty 的密钥格式不同，使用 puttygen工具将 ssh-keygen生成的私钥转成 putty格式。点击<code>Load</code>按钮，选择私钥文件<code>id_rsa</code>，然后再保存成新的私钥文件。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20211009222032353.png"alt="image-20211009222032353" /><figcaption aria-hidden="true">image-20211009222032353</figcaption></figure></li><li><p>加载公钥</p><p>putty 设置窗口的 Auth 标签页中选择转换好的 ppk私钥文件，再填写默认登录账户、主机地址等信息，最后将当前设置保存成一个会话，下次双击会话名即可自动登录。</p><figure><imgsrc="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/image-20211009222400149.png"alt="image-20211009222400149" /><figcaption aria-hidden="true">image-20211009222400149</figcaption></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
