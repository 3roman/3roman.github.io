

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <!-- {/* 自定义的字体 */} -->
  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="3roman">
  <meta name="keywords" content="">
  
    <meta name="description" content="Stylet 是一款非常优秀的 MVVM 框架，配套 wiki 写的也很棒。为了让更多的人熟悉这款框架，同时也给自己一个全面学习 Stylet 的机会，笔者决定将其 wiki 译成中文。限于外语水平和专业知识有限，难免出现不到和纰漏之处，望读者海涵。 简介 Stylet是一款小巧又强大的 MVVM 框架，它的诞生受到了Caliburn.Micro的启发。开发本框架的意图是尽量降低 MV">
<meta property="og:type" content="article">
<meta property="og:title" content="Stylet框架非官方中文文档">
<meta property="og:url" content="https://3roman.github.io/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/Stylet%E6%A1%86%E6%9E%B6%E9%9D%9E%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="昼锦堂小记">
<meta property="og:description" content="Stylet 是一款非常优秀的 MVVM 框架，配套 wiki 写的也很棒。为了让更多的人熟悉这款框架，同时也给自己一个全面学习 Stylet 的机会，笔者决定将其 wiki 译成中文。限于外语水平和专业知识有限，难免出现不到和纰漏之处，望读者海涵。 简介 Stylet是一款小巧又强大的 MVVM 框架，它的诞生受到了Caliburn.Micro的启发。开发本框架的意图是尽量降低 MV">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/mvvm.png">
<meta property="article:published_time" content="2022-12-27T12:11:42.106Z">
<meta property="article:modified_time" content="2023-01-02T09:35:10.000Z">
<meta property="article:author" content="3roman">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="译文">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="MVVM">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/3roman/PicBed/master/hexo/mvvm.png">
  
  
  
  <title>Stylet框架非官方中文文档 - 昼锦堂小记</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"3roman.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>昼锦堂小记</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://raw.githubusercontent.com/3roman/PicBed/master/hexo/valley.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Stylet框架非官方中文文档"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-27 20:11" pubdate>
          2022年12月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          354 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Stylet框架非官方中文文档</h1>
            
            
              <div class="markdown-body">
                
                <p>Stylet 是一款非常优秀的 MVVM 框架，配套 wiki
写的也很棒。为了让更多的人熟悉这款框架，同时也给自己一个全面学习 Stylet
的机会，笔者决定将其 wiki
译成中文。限于外语水平和专业知识有限，难免出现不到和纰漏之处，望读者海涵。</p>
<h1 id="简介">简介</h1>
<p>Stylet是一款小巧又强大的 MVVM 框架，它的诞生受到了<a
target="_blank" rel="noopener" href="http://caliburnmicro.com/">Caliburn.Micro</a>的启发。开发本框架的意图是尽量降低
MVVM 的复杂性和神秘性，让菜鸟也能快速上手。</p>
<p>Stylet 的部分功能是 Caliburn.Micro 不具备的，比如：IoC 容器、简单的
ViewModel 验证，兼容 MVVM 的消息框（译者注：方便单元测试）。</p>
<p>Stylet 项目源码经过全面的单元测试，LOC
指标优秀，非常适合一些由于使用和验证 SOUP
导致开销很大的项目。得益于模块化的设计，本框架提供功能可按需引入。</p>
<blockquote>
<p>Stylet is a minimal, but powerful, MVVM framework inspired by <a
target="_blank" rel="noopener" href="http://caliburnmicro.com/">Caliburn.Micro</a>. Its intention is to
cut down on the complexity and magic even further, to allow people
(coworkers) unfamiliar with any MVVM framework to get up to speed more
quickly.</p>
<p>It also provides features not available in Caliburn.Micro, including
its own IoC container, easy ViewModel validation, and even an
MVVM-compatible MessageBox.</p>
<p>The low LOC count and very comprehensive test suite makes it an
attractive option for projects where using and validating/verifying SOUP
comes with a high overhead, which its modular toolkit-inspired
architecture means it's easy to use just the bits you like, or replace
the bits you don't.</p>
<p>A brief feature list is shown below. Follow the links on the right to
learn more.</p>
</blockquote>
<h2 id="viewmodel-优先模式">ViewModel 优先模式</h2>
<p>经典 MVVM 架构通常使用View优先的模式，该模式中由 View 隐式实例化
ViewModel，ViewModel 一般不被显式实例化。Stylet 反其道而行之，先实例化
ViewModel 再用 ViewModel 附加 View，形成了独具一格的ViewModel
优先模式。这样做最明显的好处是方便组织 ViewModel。</p>
<blockquote>
<p>The classic MVVM structure, where a view knows how to instantiate its
ViewModel, and ViewModels typically don't communicate directly, is known
as View-first. However, reversing this pattern - instantiating the
ViewModels yourself and having the Views automatically attached -
provides many advantages, allowing you to compose your ViewModels in a
way which should feel very familiar. This ViewModel-first approach is
the only one supported by Stylet.</p>
</blockquote>
<h2 id="动作">动作</h2>
<p>WPF 的 ICommand
接口很强大但也很笨重，譬如按钮点击动作用属性来实现而不是用方法，也不怎么符合直觉。
通过前端 XAML
动作绑定：<code>&lt;Button Command="&#123;s:Action DoSomething&#125;"/&gt;</code>，按钮被点击时将调用
ViewModel 中定义好的
<code>DoSomething()</code>方法。另外，还可创建一个名为
<code>CanDoSomething</code>
的监视属性用于判断该方法是否可被执行。事件也可绑定动作，比如为<code>MouseEnter</code>事件绑定动作：<code>&lt;Button MouseEnter="&#123;s:Action DoSomethingElse&#125;"/&gt;</code>。</p>
<blockquote>
<p>The ICommand interface used by WPF is powerful, but clunky when used
in an MVVM architecture. It doesn't seem right that actions to be taken
by your ViewModel in response to things like button clicks should be
represented as properties, rather than methods. A simple
<code>&lt;Button Command="&#123;s:Action DoSomething&#125;"/&gt;</code> will cause
<code>DoSomething()</code> on your ViewModel to be called every time the
button is clicked. Additionally, if you have a bool property called
<code>CanDoSomething</code>, that will be observed and used to tell
whether the button should be enabled or disabled.</p>
<p>Actions also work with events, allowing you to do things like
<code>&lt;Button MouseEnter="&#123;s:Action DoSomethingElse&#125;"/&gt;</code>.</p>
</blockquote>
<h2 id="页面和页面管理器">页面和页面管理器</h2>
<p>Screen 是 ViewModel 的基类，其本身实现了很多功能：事件通知、ViewModel
校验、生命周期管理（何时显示、隐藏、关闭窗口及确定窗口能否被关闭）。</p>
<blockquote>
<p>The Screen class provides many things which make it an attractive
base class for your ViewModels: PropertyChanged notifications,
validation, and the ability to be notified when it's
shown/hidden/closed, and the ability to control if and when it can be
closed.</p>
</blockquote>
<h2 id="事件总线">事件总线</h2>
<p>类似于 Caliburn.Micro
的事件总线，订阅者直接从总线上获取某事件而无需了解该事件发布者的信息。事件总线有很多应用场景，比如
ViewModel 间传递消息。</p>
<blockquote>
<p>Stylet's Event Aggregator is very similar to Caliburn.Micro's, and
allows subscribers to receive messages from publishes without either
having knowledge of, or retaining, the other. This is particularly
useful for messaging between ViewModels, although it has plenty of other
uses.</p>
</blockquote>
<h2 id="窗口管理器">窗口管理器</h2>
<p>窗口具体实现了 Stylet 的 ViewModel 优先模式，还实现了兼容 MVVM
的消息框。</p>
<blockquote>
<p>With a ViewModel-first approach, you display windows and dialogs by
referencing the ViewModel to display, and the View gets attached
automatically. The WindowManager allows this to be done with ease.</p>
<p>An MVVM-compatible MessageBox implementation is also provided, so you
don't have to roll your own.</p>
</blockquote>
<h2 id="校验">校验</h2>
<p>在传统 MVVM 架构下，校验 ViewModel
需要大量的模板文件，而且相关资源都是松散的。Stylet
有一个专门用于校验的框架，该框架还支持自定义校验库（比如： <a
target="_blank" rel="noopener" href="https://fluentvalidation.codeplex.com/">FluentValidation</a>）。</p>
<blockquote>
<p>Validation in MVVM is traditionally a bit of a pain: it requires a
fair amount of boilerplate in each ViewModel that requires validation,
and resources on how to do this well are sparse.</p>
<p>Stylet comes with a framework for taking your favourite validation
library (e.g. <a
target="_blank" rel="noopener" href="https://fluentvalidation.codeplex.com/">FluentValidation</a>) and
handles running validations and reporting the results to the View.</p>
</blockquote>
<h2 id="styletioc-容器">StyletIoC 容器</h2>
<p>Stylet 提供了一个强大、快速、轻量且易于使用的 IoC 容器。</p>
<blockquote>
<p>Stylet comes with its own lightweight and extremely fast (but still
powerful) IoC container, although it's easy to use another one if you'd
prefer.</p>
</blockquote>
<h2 id="mit-许可">MIT 许可</h2>
<p>Stylet 使用 MIT 许可，该许可证允许您自行修改 Stylet
并将其用于商业用途，无归属者（唯一的限制是您必须包含本许可的副本）。
若有需要，我们愿意根据具体情况重新许可。</p>
<blockquote>
<p>Stylet is distributed under the MIT license, which allows you to
modify Stylet, and include it in commercial projects, without
attributation (the only restriction being that you must include a copy
of the license). I'm open to re-licensing it on a case-by-case basis if
you require this.</p>
</blockquote>
<h1 id="快速上手">快速上手</h1>
<p>想要上手试一下吗？那么请往下看吧！下面将创建一个简单的脚手架项目。</p>
<p><em><strong>注意</strong>：本项目的 git
仓库包含示例代码，可自行下载学习。</em></p>
<blockquote>
<p>Want to get up and running as quickly as possible? This is the right
place!</p>
<p><em>NOTE: If you're looking for example applications, download the
source code and look in the Samples folder.</em></p>
<p>The following instructions will set up a minimal skeleton
project.</p>
</blockquote>
<h2 id="自动安装">自动安装</h2>
<h3 id="net-framework">.NET Framework</h3>
<p><em><strong>注意</strong>：VS2013 及之前的版本不支持自动安装 Nuget
包，若有需要请手动安装。</em></p>
<p>如果您刚接触 Stylet，最简单的上手步骤如下：</p>
<ol type="1">
<li>打开Visual Studio，创建一个 WPF 项目；</li>
<li>通过 NuGet 包管理器（右键项目 -&gt;管理 Nuget
包）安装<code>Stylet.Start</code>。</li>
<li>项目创建成功后，可删除 <code>Stylet.Start</code> 包。</li>
</ol>
<blockquote>
<p><strong>Note</strong>: This will <strong>not</strong> work if your
project uses <strong>PackageReference</strong> for NuGet packages or if
you are using VS2013 or earlier. Follow the "Manual Option" section
below instead.</p>
<p>If you're new to Stylet (and you're running VS2015 or later), this is
the easiest way to get started.</p>
<ol type="1">
<li>Open Visual Studio, and create a new <code>WPF Application</code>
project.</li>
<li>Open NuGet (right-click your project -&gt; Manage NuGet Packages),
and install the <code>Stylet.Start</code> package.</li>
</ol>
<p>This will give you a working skeleton project.</p>
<p>When it has finished installing, uninstall Stylet.Start.</p>
<p>Happy coding!</p>
</blockquote>
<h3 id="net-core">.NET Core</h3>
<p>建议通过 <code>dotnet new</code>命令使用 Stylet 模板创建 .NET Core
脚手架项目。</p>
<p>在项目目录打开命令行，输入命令安装 Stylet 模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pow">dotnet new -i Stylet.Templates<br></code></pre></td></tr></table></figure>
<p>根据新安装的模板创建项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pow">dotnet new stylet -o MyStyletProject<br></code></pre></td></tr></table></figure>
<blockquote>
<p>For .NET Core projects, the quickest way to get started is by using
<code>dotnet new</code> with Stylet's template.</p>
<p>Open a command window where you want to create your new project, and
install the Stylet templates using:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">dotnet <span class="hljs-keyword">new</span> <span class="hljs-type"></span>-i Stylet.Templates<br></code></pre></td></tr></table></figure>
<p>Then create a new project with:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">dotnet <span class="hljs-keyword">new</span> <span class="hljs-type">stylet</span> -o MyStyletProject<br></code></pre></td></tr></table></figure>
<p>(changing <code>MyStyletProject</code> as appropriate).</p>
</blockquote>
<h2 id="手动安装">手动安装</h2>
<p>如果您想手动创建项目，步骤如下：</p>
<ol type="1">
<li>打开 Visual Studio，创建一个 WPF 项目；</li>
<li>通过 NuGet 包管理器（右键项目 -&gt;管理 Nuget
包）安装<code>Stylet</code>包。</li>
</ol>
<p>删除<code>MainWindow.xaml</code>和<code>MainWindow.xaml.cs/vb</code>这些以后用不到的文件。接着右键项目，新增一个名为<code>RootView</code>的
WPF 窗口，前端示例代码如下：</p>
<blockquote>
<p>If you don't want to use the <code>Stylet.Start</code> package and
would prefer to create your own skeleton project, follow the
instructions in this section.</p>
<ol type="1">
<li>Open Visual Studio, and create a new <code>WPF Application</code>
project.</li>
<li>Open NuGet (right-click your project -&gt; Manage NuGet Packages),
and install the <code>Stylet</code> package.</li>
</ol>
<p>First off, delete <code>MainWindow.xaml</code> and
<code>MainWindow.xaml.cs/vb</code>. You won't be needing them.</p>
<p>Next, you'll need a root View and a ViewModel. The View has to be a
<code>Window</code>, but there are no other restrictions.</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;Stylet.Samples.Hello.RootView&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">Height</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">Width</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextBlock</span>&gt;</span>Hello, World<span class="hljs-tag">&lt;/<span class="hljs-name">TextBlock</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>新建一个名为<code>RootViewModel</code>的 ViewModel 类。</p>
<blockquote>
<p>The ViewModel can be any old class (for now - you might want it to be
a <a
target="_blank" rel="noopener" href="https://github.com/canton7/Stylet/wiki/Screens-and-Conductors">Screen
or Conductor</a>).</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RootViewModel</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>引导器类的基本职责是实例化主窗口的 ViewModel，诸如 IoC
容器等其它功能详见后续章节。</p>
<blockquote>
<p>Next, you'll need a bootstrapper. For now, you don't need anything
special - just something to identify your root ViewModel. Later, you'll
be able to configure your IoC container here, as well as other
application-level stuff.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bootstrapper</span> : <span class="hljs-title">Bootstrapper</span>&lt;<span class="hljs-title">RootViewModel</span>&gt;<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>删除<code>App.xaml</code>中的<code>StartUri</code>特性并引入 Stylet
命名空间后，通过该命名空间下的<code>ApplicationLoader</code>元素以加载资源的方式实例化引导器类，示例代码如下：</p>
<blockquote>
<p>Finally, this needs to be referenced as a resource in your
<code>App.xaml</code>. You'll need to remove the <code>StartUri</code>
attribute, and add <code>xmlns</code> entries for Stylet and your own
application. Finally, you'll need to add Stylet's
<code>ApplicationLoader</code> to the resources, and identify the
bootstrapper you created above.</p>
<p>It should look something like this:</p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>x:Class</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs <Application">             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;<br>             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;<br>             xmlns:s=&quot;https://github.com/canton7/Stylet&quot;<br>             xmlns:local=&quot;clr-namespace:Stylet.Samples.Hello&quot;&gt;<br>    &lt;Application.Resources&gt;<br>       &lt;s:ApplicationLoader&gt;<br>            &lt;s:ApplicationLoader.Bootstrapper&gt;<br>                &lt;local:Bootstrapper/&gt;<br>            &lt;/s:ApplicationLoader.Bootstrapper&gt;<br>        &lt;/s:ApplicationLoader&gt;<br>    &lt;/Application.Resources&gt;<br>&lt;/Application&gt;<br></code></pre></td></tr></table></figure>
<p>好了，可以运行程序了！</p>
<blockquote>
<p>That's it! Run that, and you should get a window with 'Hello World'
in it.</p>
</blockquote>
<h2 id="应用程序装载器">应用程序装载器</h2>
<p>上述<code>&lt;s:ApplicationLoader&gt;</code>元素用于加载 Stylet
内置的资源，此类继承自资源字典类 ResourceDictionary ，用法如下：</p>
<blockquote>
<p>It's worth noting that <code>&lt;s:ApplicationLoader&gt;</code> above
is a ResourceDictionary subclass. This allows it to load in Stylet's
built-in resources (see <a
target="_blank" rel="noopener" href="https://github.com/canton7/Stylet/wiki/Screens-and-Conductors">Screens
and Conductors</a>). You can choose not to load Stylet's resources like
this:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span> <span class="hljs-attr">LoadStyletResources</span>=<span class="hljs-string">&quot;False&quot;</span>&gt;</span><br>   ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p><code>&lt;s:ApplicationLoader&gt;</code>元素也可用来创建不属于Stylet
的应用程序级资源或资源字典，用法如下：</p>
<blockquote>
<p>If you want to add your own Resources / ResourceDictionaries to the
Application, the simplest way is like this:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">local:Bootstrapper</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Style</span> <span class="hljs-attr">x:Key</span>=<span class="hljs-string">&quot;MyResourceKey&quot;</span>&gt;</span><br>            ...<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Style</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.MergedDictionaries</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span> <span class="hljs-attr">Source</span>=<span class="hljs-string">&quot;MyResourceDictionary.xaml&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.MergedDictionaries</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>以上代码也写成如下习惯形式：</p>
<blockquote>
<p>If this makes you uncomfortable for some reason, you can also do
this:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary.MergedDictionaries</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">local:Bootstrapper</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span> <span class="hljs-attr">Source</span>=<span class="hljs-string">&quot;MyResourceDictionary.xaml&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ResourceDictionary.MergedDictionaries</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Style</span> <span class="hljs-attr">x:Key</span>=<span class="hljs-string">&quot;MyResourceKey&quot;</span>&gt;</span><br>            ...<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Style</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ResourceDictionary</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h1 id="引导器">引导器</h1>
<p>引导器负责引导应用程序，可完成多项任务，其中两项基本任务如下：</p>
<ol type="1">
<li>配置 IoC 容器</li>
<li>通过窗口管理器实例化根 ViewModel</li>
</ol>
<p>引导器类 BootStrapper 有两种父类：</p>
<ol type="1">
<li><p>BootstrapperBase<TRootViewModel></p>
<p>使用自定义的 IoC 容器</p></li>
<li><p>Bootstrapper<TRootViewModel></p>
<p>使用默认的 IoC 容器，示例代码如下：</p></li>
</ol>
<blockquote>
<p>The bootstrapper is responsible for bootstrapping your application.
It configures the IoC container, creates a new instance of your root
ViewModel and displays it using the <code>WindowManager</code>. It also
provides various other functions, described below.</p>
<p>The bootstrapper comes in two flavours:
<code>BootstrapperBase&lt;TRootViewModel&gt;</code>, which requires you
to configure the IoC container yourself, and
<code>Bootstrapper&lt;TRootViewModel&gt;</code>, which uses Stylet's
built-in IoC container, StyletIoC.</p>
<p>Example bootstrapper, using StyletIoC:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">Bootstrapper</span> : <span class="hljs-title">Bootstrapper</span>&lt;<span class="hljs-title">MyRootViewModel</span>&gt;<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnStart</span>()</span><br>   &#123;<br>      <span class="hljs-comment">// This is called just after the application is started, but before the IoC container is set up.</span><br>      <span class="hljs-comment">// Set up things like logging, etc</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConfigureIoC</span>(<span class="hljs-params">IStyletIoCBuilder builder</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// Bind your own types. Concrete types are automatically self-bound.</span><br>      builder.Bind&lt;IMyInterface&gt;().To&lt;MyType&gt;();<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>()</span><br>   &#123;<br>      <span class="hljs-comment">// This is called after Stylet has created the IoC container, so this.Container exists, but before the</span><br>      <span class="hljs-comment">// Root ViewModel is launched.</span><br>      <span class="hljs-comment">// Configure your services, etc, in here</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnLaunch</span>()</span><br>   &#123;<br>      <span class="hljs-comment">// This is called just after the root ViewModel has been launched</span><br>      <span class="hljs-comment">// Something like a version check that displays a dialog might be launched from here</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnExit</span>(<span class="hljs-params">ExitEventArgs e</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// Called on Application.Exit</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnUnhandledException</span>(<span class="hljs-params">DispatcherUnhandledExceptionEventArgs e</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// Called on Application.DispatcherUnhandledException</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="自定义-ioc-容器">自定义 IoC 容器</h2>
<p>使用自定义 IoC 容器很简单，官方 git 仓库也提供了多个 IoC
容器供您选择。这些容器都经过了全面的单元测试。</p>
<p>由于管理多个 IoC 容器很麻烦，同时为了减少依赖，
本框架的发布包只内置一个 IoC 容器。若您需要使用其它容器，可从官方 git
仓库下载后手动添加引用。使用方法见上一章，示例代码如下：</p>
<blockquote>
<p>Using another IoC container with Stylet is easy. I've included
bootstrappers for a number of popular IoC containers in the <a
target="_blank" rel="noopener" href="https://github.com/canton7/Stylet/tree/master/Bootstrappers">Bootstrappers
project</a>. These are all unit-tested but not battle-tested: feel free
to customize them.</p>
<p>Note that the Stylet nuget package / dll don't include these, as it
would add unnecessary dependencies. Similarly, I don't publish IoC
container-specific packages, as that's a waste of effort.</p>
<p>Copy the bootstrapper you want from the above link into your project
somewhere. Then subclass it, as you would normally subclass
<code>Bootstrapper&lt;TRootViewModel&gt;</code>, documented above. Then
add your subclass to your App.xaml.cs, as documented in <a
target="_blank" rel="noopener" href="https://github.com/canton7/Stylet/wiki/Quick-Start">Quick
Start</a>, e.g.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bootstrapper</span> : <span class="hljs-title">AutofacBootstrapper</span>&lt;<span class="hljs-title">ShellViewModel</span>&gt;<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Application</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;Stylet.Samples.Hello.App&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:local</span>=<span class="hljs-string">&quot;clr-namespace:Stylet.Samples.Hello&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">local:Bootstrapper</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Application</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<h2 id="添加资源字典">添加资源字典</h2>
<p>由于<code>s:ApplicationLoader</code>本身就是资源字典，如果再想添加其它资源字典，就必须与<code>s:ApplicationLoader</code>一起嵌套在合并资源字典<code>MergedDictionaries</code>中，示例代码如下：</p>
<blockquote>
<p>s:ApplicationLoader is itself a ResourceDictionary. If you need to
add your own resource dictionary to App.xaml, you will have to nest
s:ApplicationLoader inside your ResourceDictionary as a
MergedDictionary, like this:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Application.Resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary.MergedDictionaries</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">local:Bootstrapper</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader.Bootstrapper</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">s:ApplicationLoader</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ResourceDictionary</span> <span class="hljs-attr">Source</span>=<span class="hljs-string">&quot;YourDictionary.xaml&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ResourceDictionary.MergedDictionaries</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ResourceDictionary</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Application.Resources</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h1 id="viewmodel-优先">ViewModel 优先</h1>
<p>ViewModel 优先是 Stylet
框架的一大特点，其相对于传统的View优先更显自然。</p>
<blockquote>
<p>The ViewModel-first approach is one that's crucial to Stylet's
architecture, but unintuitive if you learnt MVVM in the traditional
View-first manner.</p>
<p>Hopefully this article will make everything clear.</p>
</blockquote>
<h2 id="view优先">View优先</h2>
<p>让我们先了解一下什么是 View优先。该模式下视图必须了解 ViewModel
的详细情况，但反过来 ViewModel 可以不知 View
的信息。将两者联系到一起的常用方法是：在 View 的后台代码中实例化
ViewModel ，并赋给 View 的<code>DataContent</code>属性。</p>
<blockquote>
<p>Let's start by defining the View-first approach, and what exactly I
mean by that. MVVM states that the ViewModel should know nothing about
the View, but that View should be aware of the ViewModel. The obvious
way to attach a View and ViewModel, then, is have the View construct its
ViewModel in its codebehind - something like this:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> : <span class="hljs-title">Window</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyView</span>()</span><br>   &#123;<br>      InitializeComponent();<br> <br>      <span class="hljs-keyword">this</span>.DataContext = <span class="hljs-keyword">new</span> MyViewModel();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>目前看起来都还不错！但当 View 创建了其它
View，并需按层次关系组合这些被创建的 View
时，危机来到了。一个很典型场景是窗口 View 创建了标题栏 View 和工作区
View。</p>
<blockquote>
<p>This is fine. Views can create and own other views, meaning that you
can compose your views into a hierarchy. All well and good.</p>
<p>The crunch comes when you've composed a couple of views, say
something like this, where a shell contains a top bar and a frame,
inside which any page can be shown:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- This is a window which contains a top bar and another page --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.ShellView&quot;</span> <span class="hljs-attr">....</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">my:TopBarView</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Frame</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;navigationFrame&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>三者都有各自的 ViewModel 。当标题栏 View
的某些字段变化了，比如标题改变了，窗口的 ViewModel
可以得知上述变化，但标题栏 ViewModel
却不知道。常用做法是在窗口标题栏的前端代码中，将窗口标题绑定到窗口本身的某个依赖属性上，示例代码如下：</p>
<blockquote>
<p>where <code>TopBarView</code> has its own ViewModel,
<code>TopBarViewModel</code>. Fine.</p>
<p>Now say that <code>TopBarView</code> has a field containing some data
you want to update, for example the title of the current page. Now, the
<code>ShellViewModel</code> knows this (it's decided what the current
page is, after all), but the <code>TopBarViewModel</code> doesn't (how
would it? It doesn't really know about anything). The temptation is to
expose a dependency property on the <code>TopBarView</code> and bind it
into the <code>ShellViewModel</code>, like so:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.ShellView&quot;</span> <span class="hljs-attr">....</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;rootObject&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">my:TopBarView</span> <span class="hljs-attr">CurrentPageTitle</span>=<span class="hljs-string">&quot;&#123;Binding CurrentPageTitle, ElementName=rootObject&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Frame</span> <span class="hljs-attr">x:Name</span>=<span class="hljs-string">&quot;navigationFrame&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>后续标题栏的其它属性或者工作区的属性也许也要如此操作一番，简直太麻烦了。</p>
<p>另一个主要问题发生在显示窗口和对话框时，此问题也是传统 MVVM
模型中的一个痛点。在 ViewModel 中实例化并显示相应的 View
不便于单元测试，更好一点的选择是在主视图的后台代码中实例化并显示某个子视图，后续通过某种方式将创建的子视图与其子视图模型结合起来。</p>
<p><code>Frame</code>元素的内容需先实例化一个 View ，该由窗口的
ViewModel 还是 View 实例化这个 View 呢？</p>
<p>总之，View优先弊端很多。</p>
<blockquote>
<p>but that's just nasty. You've now got one-and-a-bit views bound to
the <code>ShellViewModel</code>.</p>
<p>Another major concern is displaying windows and dialogs. In
traditional MVVM, this is a bit of a pain. One option is to instantiate
and display the View (using <code>Show()</code> or
<code>ShowDialog()</code>) from inside the ViewModel (which makes it, or
at least that bit of it, untestable). The better option is to
instantiate the View you want to display in the codebehind of your View,
and show it from there. This means you need to establish ways of telling
to View to display this dialog, and a way of getting the results of the
dialog back to the ViewModel.</p>
<p>Indeed, setting the content for the <code>Frame</code> above requires
instantiating a View to put in it. This has the same dilemma - either
the ViewModel instantiates it (making it untestable), or the View does
(leading to communication pain).</p>
<p>Either way, this approach has some nastiness.</p>
</blockquote>
<h2 id="viewmodel-优先-1">ViewModel 优先</h2>
<p>该模式下， ViewModel 不由 View 来实例化， ViewModel
也无需知道与其对应 View
的存在。一个第三方服务将通过命名约定的方式匹配相关联的 View 和 ViewModel
（比如根据 MainView 去搜寻 MainViewModel
），匹配成功后继续由该服务实例化 ViewModel ，然后将其赋给对应 View 的
<code>DataContext</code>属性。详见后续章节。</p>
<blockquote>
<p>The ViewModel-first approach accepts that a ViewModel shouldn't know
anything about its View, but does not accept that the View should be
responsible for constructing the ViewModel either. Instead, a third
service is responsible for locating the correct View for a given
ViewModel, and setting up its DataContext correctly.</p>
<p>The default implementation uses naming conventions to locate the
correct View for a given ViewModel, replacing 'ViewModel' with 'View' in
its name. That's explained in more detail in <a
target="_blank" rel="noopener" href="https://github.com/canton7/Stylet/wiki/The-ViewManager">The
ViewManager</a>.</p>
<p><strong>This allows ViewModels to be created by other ViewModels.
Which allows ViewModels to know about, and own, other ViewModels. Which
allows you to compose your ViewModels properly.</strong></p>
<p>There's another part of this trick, which is best explained by
example:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShellViewModel</span><br>&#123;<br>   <span class="hljs-keyword">public</span> TopBarViewModel TopBar &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-comment">// Stuff to instantiate and assign TopBarViewModel</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.ShellView&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span> <span class="hljs-attr">.....</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ContentControl</span> <span class="hljs-attr">s:View.Model</span>=<span class="hljs-string">&quot;&#123;Binding TopBar&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-comment">&lt;!-- ... --&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>附加属性<code>View.Model</code>将会实例化其绑定 ViewModel
的实例（本例中是<code>TopBarViewModel</code>的实例）并作为ContentControl元素的内容，然后即可定位到正确的
View（本例中是 <code>TopBarView</code>）。</p>
<p>诀窍在于<code>TopBarView</code>可以根据命名约定找到对应的<code>TopBarViewModel</code>，<code>TopBarViewModel</code>也可以被<code>ShellViewModel</code>知会。问题解决了！</p>
<blockquote>
<p>The <code>View.Model</code> attached property will fetch the
ViewModel it's bound to (in this case it's an instance of
<code>TopBarViewModel</code>), and locate the correct view
(<code>TopBarView</code>). It will instantiate an instance, and set it
as the content of that <code>ContentControl</code>.</p>
<p>The upshot is that the <code>TopBarView</code> can get the name of
the current page from its <code>TopBarViewModel</code>, and the
<code>TopBarViewModel</code> can be told this by the
<code>ShellViewModel</code>. Problem solved!</p>
<p>The <code>ContentControl</code> trick also works well for
navigation:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Window</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.ShellView&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span> <span class="hljs-attr">.....</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">StackPanel</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ContentControl</span> <span class="hljs-attr">s:View.Model</span>=<span class="hljs-string">&quot;&#123;Binding TopBar&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ContentControl</span> <span class="hljs-attr">s:View.Model</span>=<span class="hljs-string">&quot;&#123;Binding CurrentPage&#125;&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">StackPanel</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Window</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>当多页面窗口应用程序切换页面时，由主窗口的 ViewModel 实例化页面的
ViewModel ，并将该实例赋值给主窗口 ViewModel
的的<code>CurrentPage</code>属性。主窗口的 ViewModel
不必知道如何得到页面的
View。窗口管理器会以大致相同的方式处理对话框应用程序和窗口应用程序，在获得某个
ViewModel 实例后将由其显示对应的窗口 View 或对话框 View。</p>
<blockquote>
<p>The <code>ShellViewModel</code> will then navigate to a new page by
instantiating a new instance of that page's <code>ViewModel</code>, and
assigning it to the property <code>CurrentPage</code>. Note how the
<code>ShellViewModel</code> no longer needs to know anything about
views. <em>It hasn't had to instantiate a single view</em>. This is a
very important, useful, and powerful point.</p>
<p>Dialogs and Windows are handled in much the same way by <a
target="_blank" rel="noopener" href="https://github.com/canton7/Stylet/wiki/The-WindowManager">The
WindowManager</a>. This takes a given ViewModel instance, and displays
its View as a dialog or window.</p>
</blockquote>
<h2 id="删除后台代码">删除后台代码</h2>
<p>在 ViewModel
优先模式下，通过动作、转换器、附加属性、附加行为几乎可以实现所有功能，View
的后台代码也就没有存在的必要了。强烈建议您删除 View
的后台代码文件，<code>InitializeComponent</code>方法会由 Stylet
替您调用。</p>
<p><em><strong>注意</strong>：VB.NET中不建议删除后台代码。</em></p>
<blockquote>
<p>With this approach in place, there's nothing you actually need to do
in the codebehind. You can of course do so, but there's very little you
can't solve with <a
target="_blank" rel="noopener" href="https://github.com/canton7/Stylet/wiki/Actions">Actions</a> (for
handling events), Converters, Attached Properties, and (most
importantly) Attached Behaviors.</p>
<p>Stylet lets you delete the codebehind entirely (it will call
<code>InitializeComponent</code> for you), and you are strongly
encouraged to do so. Delete the codebehind!</p>
<p><em><strong>Note</strong>: If you're using VB.NET, sometimes your
XAML namespaces will stop working if you delete the codebehind. If this
is the case, simply recreate the codebehind with the matching filename,
give it the correct namespace and class and then leave the remainder
blank. For example, <code>MyView.xaml.vb</code> :</em></p>
</blockquote>
<h1 id="动作-1">动作</h1>
<p>点击按钮后调用 ViewModel 定义的方法，动作适用于诸如此场景。</p>
<blockquote>
<p>You have a button, and you want to click it and execute a method on
your ViewModel? Actions cover this use-case.</p>
</blockquote>
<h2 id="动作和方法">动作和方法</h2>
<p>WPF 中命令绑定步骤为：ViewModel
实现<code>ICommand</code>接口后将按钮的 Command 特性绑定到 ViewModel
的某个属性。尽管看起来有点混乱，这种机制其实也不错，至少 ViewModel
无需了解 View且View
的后台代码也可删除。但最好还是直接调用方法而不是通过某个属型间接调用。Stylet
引入了动作来解决这个问题，示例代码如下：</p>
<blockquote>
<p>In 'traditional' WPF, you'd create a property on your ViewModel which
implements the <a
target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/system.windows.input.icommand(v=vs.110).aspx">ICommand</a>
interface, and bind your button's Command attribute to it. This works
fairly well (the ViewModel knows nothing about the View, and code-behind
is not required), but it's a bit messy - you really want to be calling a
method on your ViewModel, not executing a method on some property.</p>
<p>Stylet solves this by introducing Actions. Look at this:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span> : <span class="hljs-title">Screen</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span><br>   &#123;<br>      Debug.WriteLine(<span class="hljs-string">&quot;DoSomething called&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.View&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action DoSomething&#125;&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>上例中点击按钮后将直接调用<code>DoSomething</code>方法，多么简单！CommandParameter
特性还可用来给方法传递一个参数，示例代码如下：</p>
<blockquote>
<p>As you might have guessed, clicking the button called the DoSomething
method on the ViewModel to be called.</p>
<p>It's that simple.</p>
<p>If your method accepts a single argument, the value of the button's
CommandParameter property will be passed. For example:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span> : <span class="hljs-title">Screen</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> argument</span>)</span><br>   &#123;<br>      Debug.WriteLine(String.Format(<span class="hljs-string">&quot;Argument is &#123;0&#125;&quot;</span>, argument));<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.View&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action DoSomething&#125;&quot;</span> <span class="hljs-attr">CommandParameter</span>=<span class="hljs-string">&quot;Hello&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>注意：动作也适用于任何 ICommand 类型的属性，比如 KeyBinding
属性。</p>
<blockquote>
<p>Note that Actions also work on any ICommand property, on anything
(e.g. a <a
target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/system.windows.input.keybinding(v=vs.110).aspx">KeyBinding</a>).</p>
</blockquote>
<h2 id="守卫属性">守卫属性</h2>
<p>1111</p>
<blockquote>
<p>You can also control whether you button is enabled just as easily,
using <em>Guard Properties</em>. A guard property for a given method is
a boolean property which has the name "Can<method name>", so if your
method is called "DoSomething", the corresponding guard property is
called "CanDoSomething".</p>
<p>Stylet will check whether a guard property exists, and if so, will
disable the button if it returns false, or enable it if it returns true.
It will also watch for PropertyChanged notifications for that property,
so you can change whether the button is enabled.</p>
<p>For example:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModel</span> : <span class="hljs-title">Screen</span><br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> _canDoSomething;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> CanDoSomething<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._canDoSomething; &#125;<br>      <span class="hljs-keyword">set</span> &#123; <span class="hljs-keyword">this</span>.SetAndNotify(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">this</span>._canDoSomething, <span class="hljs-keyword">value</span>); &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span><br>   &#123;<br>      Debug.WriteLine(<span class="hljs-string">&quot;DoSomething called&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="事件">事件</h2>
<p>Stylet
也支持事件绑定，语法同命令绑定，但是事件绑定不涉及守卫属性的概念。</p>
<blockquote>
<p>But what about if you want to call a ViewModel method when an event
occurs? Actions have that covered as well. The syntax is exactly the
same, although there's no concept of a guard property here.</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserControl</span> <span class="hljs-attr">x:Class</span>=<span class="hljs-string">&quot;MyNamespace.View&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:x</span>=<span class="hljs-string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">xmlns:s</span>=<span class="hljs-string">&quot;https://github.com/canton7/Stylet&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;&#123;s:Action DoSomething&#125;&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">UserControl</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>绑定事件的方法可以没有形参，也可以有一个或两个形参，方法的签名可能如下：</p>
<blockquote>
<p>The method which is called must have zero, one, or two parameters.
The possible signatures are:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HasNoArguments</span>()</span> &#123; &#125;<br> <br><span class="hljs-comment">// This can accept EventArgs, or a subclass of EventArgs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HasOneSingleArgument</span>(<span class="hljs-params">EventArgs e</span>)</span> &#123; &#125;<br> <br><span class="hljs-comment">// Again, a subclass of EventArgs is OK</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">HasTwoArguments</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span> &#123; &#125;<br></code></pre></td></tr></table></figure>
<h2 id="方法返回值">方法返回值</h2>
<p>动作通常不关心方法的返回类型和返回值，但返回 Task 是个例外。</p>
<blockquote>
<p>Actions don't care about the return type of the method, and the
returned value is discarded.</p>
<p>The exception to this is if a <code>Task</code> is returned (e.g. if
the method being invoked is <code>async</code>). In this case, the
<code>Task</code> will be awaited in an <code>async void</code> method.
This means that if the method returns a <code>Task</code> which ends up
containing an exception, this exception is rethrown and will bubble up
to the Dispatcher, where it will terminate your application (unless you
handle it, with e.g.
<code>BootstrapperBase.OnUnhandledException</code>). The effect is the
same as if the method being invoked was <code>async void</code>, but
means it's easier to unit-test <code>async</code> ViewModel methods.</p>
</blockquote>
<h2 id="动作目标">动作目标</h2>
<blockquote>
<p>So far I've been telling a little white lie. I've been saying that
the Action is invoked on the ViewModel, but that isn't strictly true.
Let's go into a bit more detail.</p>
<p>Stylet defines an inherited attached property called
View.ActionTarget. When a View is bound to its ViewModel, the
View.ActionTarget on the root element in the View is bound to the
ViewModel, and it's then inherited by each element in the View. When you
invoke an action, it's invoked on the View.ActionTarget.</p>
<p>This means that, by default, actions are invoked on the ViewModel
regardless of the current DataContext, which is probably what you
want.</p>
<p>This is a very important point, and one that's worth stressing. The
DataContext will probably change at multiple points throughout the
visual tree. However, the View.ActionTarget will stay the same (unless
you manually change it). This means the actions will always be handled
by your ViewModel, and not by whatever object is being bound to, which
is almost always what you want.</p>
<p>You can of course alter the View.ActionTarget for individual
elements, for example:</p>
</blockquote>
<h2 id="静态方法">静态方法</h2>
<p>动作也可调用静态方法</p>
<blockquote>
<p>Actions can also invoke static methods, if the target is a
<code>Type</code> object (use <code>&#123;x:Type ...&#125;</code> in XAML for
this). You can set this using both <code>View.ActionTarget</code> and
Action's <code>Target</code> property.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CommonButtonTarget</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span> &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action DoSomething, Target=&#123;x:Type my:CommonButtonTarget&#125;&#125;&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="动作和样式">动作和样式</h2>
<blockquote>
<p>Actions will not work from style setters. The classes required to do
this in WPF are all internal, which means there is no way to fix the
issue. You will need to use old-fashioned Commands in this (rare) case,
unfortunately.</p>
</blockquote>
<h2 id="上下文菜单和弹出式菜单陷阱">上下文菜单和弹出式菜单陷阱</h2>
<p>111</p>
<blockquote>
<p>View.ActionTarget is of course an attached property, which is
configured to be inherited by the children of whatever element it is set
on. Like any attached property, and indeed the DataContext, there are
certain boundaries it is not inherited across, such as:</p>
</blockquote>
<ul>
<li>Using a ContextMenu</li>
<li>Using a Popup</li>
<li>Using a Frame</li>
</ul>
<p>In these cases, Stylet will do the best it can to find a suitable
ActionTarget (it may, for example, find the the ActionTarget associated
with the root element in the current XAML file), but this may not be
exactly what you expect (e.g. it may ignore a
<code>s:View.ActionTarget="&#123;Binding ...&#125;"</code> line you have somewhere
in the middle of your page), or it may (in rare circumstances) fail to
find an ActionTarget at all.</p>
<p>In this case, please set <code>s:View.ActionTarget</code> to a
suitable value. You may struggle to get a reference to anything outside
of a ContextMenu from inside of one: I suggest the <a
target="_blank" rel="noopener" href="http://www.thomaslevesque.com/2011/03/21/wpf-how-to-bind-to-data-when-the-datacontext-is-not-inherited/">BindingProxy</a>
technique.</p>
<h2 id="附加行为">附加行为</h2>
<p>有两种可能会导致动作停止：
<code>View.ActionTarget</code>为空或者<code>View.ActionTarget</code>
中指定方法不存在。上述情况的默认处理如下：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">View.ActionTarget为空</th>
<th style="text-align: center;">View.ActionTarget中指定方法不存在</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>命令</td>
<td style="text-align: center;">禁用控件</td>
<td style="text-align: center;">点击控件时抛出异常</td>
</tr>
<tr class="even">
<td>事件</td>
<td style="text-align: center;">启用控件</td>
<td style="text-align: center;">事件被引发时抛出异常</td>
</tr>
</tbody>
</table>
<blockquote>
<p>There are two cases which will stop an action from working properly:
if the <code>View.ActionTarget</code> is null, or if the specified
method on the <code>View.ActionTarget</code> doesn't exist. The default
behaviour in each of these cases is as follows:</p>
<table>

<thead>
<tr class="header">
<th></th>
<th>View.ActionTarget == null</th>
<th>No method on View.ActionTarget</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Commands</td>
<td>Disable the control</td>
<td>Throw an exception when the control is clicked</td>
</tr>
<tr class="even">
<td>Events</td>
<td>Enable the control</td>
<td>Throw an exception when the event is raised</td>
</tr>
</tbody>
</table>
<p>The justification for this is that if the
<code>View.ActionTarget</code> is null, you must have set it yourself,
so you probably know what you're doing. However, if the specified method
doesn't exist on the <code>View.ActionTarget</code>, that's probably a
mistake, and you deserve to know.</p>
<p>Of course, this behaviour is configurable.</p>
<p>To control the behaviour when <code>View.ActionTarget</code> is null,
set the <code>NullTarget</code> property on the <code>Action</code>
markup extension so either <code>Enable</code>, <code>Disable</code>, or
<code>Throw</code>. (Note that <code>Disable</code> is invalid when the
Action is linked to an event, as we have no power to disable
anything).</p>
<p>For example:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action MyMethod, NullTarget=Enable&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;&#123;s:Action MyMethod, NullTarget=Throw&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>11</p>
<blockquote>
<p>Similarly, you can set the <code>ActionNotFound</code> property to
the same values:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Command</span>=<span class="hljs-string">&quot;&#123;s:Action MyMethod, ActionNotFound=Disable&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">Click</span>=<span class="hljs-string">&quot;&#123;s:Action MyMethod, ActionNotFound=Enable&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<h1 id="窗口管理器-1">窗口管理器</h1>
<p>采用传统View优先的方法，要显示一个新的窗口或对话框应首先创建视图的实例，再调用实例方法<code>.Show()</code>或<code>.ShowDialog()</code>。采用ViewModel
优先的方法时无法与视图直接交互，因此上述步骤行不通。窗口管理器正是为了解决这个问题，通过调用<code>IWindowManager.ShowWindow(someViewModel)</code>方法可定位并实例化对应的
View，再将其绑定到 ViewModel，最后显示它。示例代码如下：</p>
<blockquote>
<p>In a traditional View-first approach, if you want to display a new
window or dialog, you create a new instance of the View, then call
<code>.Show()</code> or <code>.ShowDialog()</code>.</p>
<p>In a ViewModel-first approach, you can't interact directly with the
views, so you can't do this. The WindowManager solves this problem -
calling <code>IWindowManager.ShowWindow(someViewModel)</code> will take
that ViewModel, find its view, instantiate it, bind it to that
ViewModel, and display it.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeViewModel</span><br>&#123;<br>   <span class="hljs-keyword">private</span> IWindowManager windowManager;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SomeViewModel</span>(<span class="hljs-params">IWindowManager windowManager</span>)</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.windowManager = windowManager;<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowAWindow</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">var</span> viewModel = <span class="hljs-keyword">new</span> OtherViewModel();<br>      <span class="hljs-keyword">this</span>.windowManager.ShowWindow(viewModel);<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowADialog</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">var</span> viewModel = <span class="hljs-keyword">new</span> OtherViewModel();<br>      <span class="hljs-built_in">bool</span>? result = <span class="hljs-keyword">this</span>.windowManager.ShowDialog(viewModel);<br>      <span class="hljs-comment">// result holds the return value of Window.ShowDialog()</span><br>      <span class="hljs-keyword">if</span> (result.GetValueOrDefault(<span class="hljs-literal">true</span>))<br>      &#123;<br>         <span class="hljs-comment">// DialogResult was set to true</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>多么简单有效！另外，通过构造注入的方式得到<code>IWindowManager</code>的实例而不是在
ViewModel 中显式构造该实例使得单元测试方便很多。在 ViewModel 中调用父类
<code>Screen</code> 的
<code>RequestCLose</code>方法可关闭窗口或对话框。</p>
<blockquote>
<p>Nice and easy! In addition, the introduction of the IWindowManager
(rather than calling methods directly on the ViewModel) makes testing a
lot easier.</p>
<p>To close a window or dialog from its ViewModel, use
<code>Screen.RequestClose</code>, like this:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelDisplayedAsWindow</span><br>&#123;<br>   <span class="hljs-comment">// Called by pressing the &#x27;close&#x27; button</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Close</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.RequestClose();<br>   &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title">ViewModelDisplayedAsDialog</span><br>&#123;<br>   <span class="hljs-comment">// Called by pressing the &#x27;OK&#x27; button</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CloseWithSuccess</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.RequestClose(<span class="hljs-literal">true</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="消息框">消息框</h1>
<p>11</p>
<blockquote>
<p>As we all know, WPF comes with its own MessageBox implementation -
<code>System.Windows.MessageBox</code>. And that's fine, except that you
can't call it from your ViewModel (well, you <em>can</em>, but it makes
your ViewModel untestable). The usual workaround suggested online is
"write your own".</p>
<p>Well, Stylet comes with its own MessageBox clone, which looks and
behaves almost identically to the WPF one (including appearance,
buttons, icons, auto-sizing, sounds, alignment, etc).</p>
</blockquote>
<h2 id="用法">用法</h2>
<p>11</p>
<blockquote>
<p>To use, simply call the <code>ShowMessageBox</code> method on
<code>IWindowManager</code>, like this:</p>
<p>The MessageBox accepts all of the same options as as the WPF
MessageBox, plus a few more.</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">public</span> MyViewModel<br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IWindowManager windowManager;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyViewModel</span>(<span class="hljs-params">IWindowManager windowManager</span>)</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.windowManager = windowManager;<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ShowMessagebox</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">var</span> result = <span class="hljs-keyword">this</span>.windowManager.ShowMessageBox(<span class="hljs-string">&quot;Hello&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="定制消息框">定制消息框</h2>
<p>111</p>
<blockquote>
<p>Stylet's MessageBox is implemented as a ViewModel,
<code>MessageBoxViewModel</code>, and its corresponding View,
<code>MessageBoxView</code>. The ViewModel implements an interface,
<code>IMessageBoxViewModel</code>, and the <code>ShowMessageBox()</code>
method uses this interface to retrieve an instance of the ViewModel.</p>
<p>Therefore, you can provide you own custom implementation of
<code>MessageBoxViewModel</code> and <code>MessageBoxView</code> by
writing a ViewModel which implements <code>IMessageBoxViewModel</code>,
and registering it with your IoC container. This will then be used by
<code>ShowMessageBox()</code>.</p>
<p>If you just want to tweak the behaviour of the existing
<code>MessageBoxViewModel</code>, you can. The following options are
available:</p>
</blockquote>
<h3 id="自定义按钮内容">自定义按钮内容</h3>
<p>111</p>
<blockquote>
<p>You can edit the button text for any of the buttons on a
per-application basis by modifying
<code>MessageBoxViewModel.ButtonLabels</code>, which is a dictionary
holding the text to display for each button. If you just want to edit
the text for a particular MessageBox, <code>ShowMessageBox</code> will
accept a dictionary allowing you to do just that:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c#">MessageBoxViewModel.ButtonLabels[MessageBoxResult.No] = <span class="hljs-string">&quot;No, thanks&quot;</span>;<br> <br><span class="hljs-keyword">this</span>.windowManager.ShowMessageBox(<span class="hljs-string">&quot;Do you want breakfast?&quot;</span>, <br>                                   buttons: MessageBoxButton.YesNo, <br>                                   buttonLabels: <span class="hljs-keyword">new</span> Dictionary&lt;MessageBoxResult, <span class="hljs-built_in">string</span>&gt;()<br>        &#123;<br>            &#123; MessageBoxResult.Yes, <span class="hljs-string">&quot;Yes please!&quot;</span> &#125;,<br>        &#125;);<br> <br><span class="hljs-comment">// Will display a MessageBox with the buttons &quot;Yes please!&quot; and &quot;No, thanks&quot;</span><br></code></pre></td></tr></table></figure>
<h1 id="事件总线-1">事件总线</h1>
<p>事件总线是一个基于发布者/订阅者模型的事件管理器，其特征是去中心化和弱绑定。</p>
<blockquote>
<p>The EventAggregator is a decentralised, weakly-binding,
publish/subscribe-based event manager.</p>
</blockquote>
<h2 id="发布者与订阅者">发布者与订阅者</h2>
<h3 id="订阅者">订阅者</h3>
<p>111</p>
<blockquote>
<p>subscribers interesting in a particular event can tell the
IEventAggregator of their interest, and will be notified whenever a
publisher publishes that particular event to the IEventAggregator.</p>
<p>Events are classes - do whatever you want with them. For example:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEvent</span><br>&#123; <br>  <span class="hljs-comment">// Do something </span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>11</p>
<blockquote>
<p>Subscribers must implement <code>IHandle&lt;T&gt;</code>, where
<code>T</code> is the event type they are interested in receiving (they
can of course implement multiple <code>IHandle&lt;T&gt;</code>'s for
multiple <code>T</code>'s). They must then get hold of an instance of
the IEventAggregator, and subscribe themselves, for example:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">Subscriber</span> : <span class="hljs-title">IHandle</span>&lt;<span class="hljs-title">MyEvent</span>&gt;, <span class="hljs-title">IHandle</span>&lt;<span class="hljs-title">MyOtherEvent</span>&gt;<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Subscriber</span>(<span class="hljs-params">IEventAggregator eventAggregator</span>)</span><br>   &#123;<br>      eventAggregator.Subscribe(<span class="hljs-keyword">this</span>);<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">MyEvent message</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// ...</span><br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">MyOtherEvent message</span>)</span><br>   &#123;<br>      <span class="hljs-comment">// ...</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>111</p>
<blockquote>
<p>For VB.NET users, the <code>Sub New()</code> passing the
eventAggregator by reference will probably fail across namespaces, and
can be irritating to have to define with each new subscriber. Thus, it
may be easier to define your eventAggregator in a global module, then
subscribe directly to it instead of passing its reference along to each
new ViewModel you call.</p>
</blockquote>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Module</span> <span class="hljs-keyword">Global</span><br>  <span class="hljs-keyword">Public</span> eventAggregator <span class="hljs-keyword">as</span> IEventAggregator<br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Module</span><br><br><span class="hljs-keyword">Class</span> Subscriber : <span class="hljs-keyword">Implements</span> IHandle(<span class="hljs-keyword">Of</span> MyEvent)<br><br>  <span class="hljs-keyword">Public</span> <span class="hljs-keyword">Sub</span> <span class="hljs-built_in">New</span>()<br>  <span class="hljs-keyword">Global</span>.eventAggregator.Subscribe(<span class="hljs-keyword">Me</span>)<br>  <span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br>  <br>  <span class="hljs-comment">&#x27;Public Sub Handle...</span><br><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Class</span><br><br></code></pre></td></tr></table></figure>
<p>11</p>
<blockquote>
<p>Make sure to keep the namespace for the <em>module</em> blank, so
that it can be used throughout the program.</p>
</blockquote>
<h3 id="发布者">发布者</h3>
<p>11</p>
<blockquote>
<p>Publishers must also get an instance of the IEventAggregator, but
they don't need to subscribe themselves - they only need to call
IEventAggregator.Publish every time they want to publish an event, for
example:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><br><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span><br>&#123;<br>   <span class="hljs-keyword">private</span> IEventAggregator eventAggregator;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Publisher</span>(<span class="hljs-params">IEventAggregator eventAggregator</span>)</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.eventAggregator = eventAggregator;<br>   &#125;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PublishEvent</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.eventAggregator.Publish(<span class="hljs-keyword">new</span> MyEvent());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>11</p>
<blockquote>
<p>Again, for VB.NET users, if you've set up the global module then you
don't need to pass the eventAggregator to the Publisher. You can just
publish directly to the global eventAggregator;</p>
</blockquote>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Class</span> Publisher<br><br>  <span class="hljs-keyword">Public</span> <span class="hljs-keyword">Sub</span> PublishEvent()<br>  <span class="hljs-keyword">Global</span>.eventAggregator.Publish(<span class="hljs-built_in">New</span> MyEvent())<br>  <span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br>  <br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Class</span><br></code></pre></td></tr></table></figure>
<h2 id="取订和弱绑定">取订和弱绑定</h2>
<p>11</p>
<blockquote>
<p>Because the IEventAggregator is weakly binding, subscribers don't
need to unsubscribe themselves - the IEventAggregator won't retain them.
It is however possible for a subscriber to unsubscribe itself if it
wants - call</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">IEventAggregator.Unsubscribe(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure>
<h3 id="同步发布和异步发布">同步发布和异步发布</h3>
<p>111</p>
<blockquote>
<p>The default <code>IEventAggregator.Publish</code> method publishes
the event synchronously. You can also call
<code>PublishOnUIThread</code> to dispatch asynchronously to the UI
thread, or <code>PublishWithDispatcher</code> and pass any action you
want to act as the dispatcher (this can be useful if writing your own
methods on IEventAggregator).</p>
</blockquote>
<h2 id="频道">频道</h2>
<h1 id="属性通知类">属性通知类</h1>
<p>PropertyChangedBase 提供了用于引发通知的方法，被用作那些要实现
INotifyPropertyChanged 接口的类型的基类。</p>
<blockquote>
<p>PropertyChangedBase is base class for types implementing
INotifyPropertyChanged, and provides methods for raising PropertyChanged
notifications.</p>
</blockquote>
<h2 id="引发通知">引发通知</h2>
<p>目的不同，引发通知的方法也不一样，最常用的方法是属性被赋值时引发通知。使用<code>PropertyChangedBase</code>自带的工具方法<code>SetAndNotify</code>，当字段被赋新值时，赋值操作才实际发生，并引发<code>PropertyChanged</code>事件通知，示例代码如下：</p>
<blockquote>
<p>There are a number of ways to raise PropertyChanged notifications,
depending on what exactly you want to do.</p>
<p>The most common case is having a property raise a notification each
time it's assigned to. PropertyChangedBase provides a nice utility
method to help: SetAndNotify. It takes, by reference, a field, and a
value to assign to the field. If the field's value != the value, the
assignment happens, and a PropertyChanged notification is raised. For
example:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _name;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name; &#125;<br>      <span class="hljs-keyword">set</span> &#123; SetAndNotify(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">this</span>._name, <span class="hljs-keyword">value</span>); &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>绑定属性前台代码如下：</p>
<blockquote>
<p>To connect to the object you have to put in the view:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextBox</span> <span class="hljs-attr">Text</span>=<span class="hljs-string">&quot;&#123;Binding Name, UpdateSourceTrigger=PropertyChanged&#125;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<p>由于C#版本不同，在当前属性中引发其它属性通知的方法也不同。C#
6.0及以上版本推荐使用
<code>nameof()</code>方法，该方法非常简单并可在编译期进行安全检查；C#
6.0以下版本使用 lambda
表达式，可能相对慢一点，也可在编译期进行安全检查。如果有需要，甚至可采用原始字符串的方式。具体可结合以下代码来理解：</p>
<blockquote>
<p>If you want to raise a PropertyChanged notification for a property
other than the current one, there are a few ways of achieving that, too
(depending on whether you're using C#6, or below). The preferred C# 6
way is to use <code>nameof()</code>, as that is very cheap and provides
compile-time safety. If you're using C# 5 or below, you can use an
expression: this is slower, but also gives compile-time safety. If you
<em>really</em> want, you can use a raw string as well. See below:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _firstName;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _firstName; &#125;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span><br>      &#123;<br>         SetAndNotify(<span class="hljs-keyword">ref</span> _firstName, <span class="hljs-keyword">value</span>);<br><br>         <span class="hljs-comment">// Preferred if you&#x27;re using C# 6, as it provides compile-time safety</span><br>         <span class="hljs-keyword">this</span>.NotifyOfPropertyChange(<span class="hljs-keyword">nameof</span>(<span class="hljs-keyword">this</span>.FullName));         <br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _lastName;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _lastName; &#125;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span><br>      &#123;<br>         SetAndNotify(<span class="hljs-keyword">ref</span> _lastName, <span class="hljs-keyword">value</span>);<br><br>         <span class="hljs-comment">// Preferred for C# 5 and below, as it provides compile-time safety</span><br>         <span class="hljs-keyword">this</span>.NotifyOfPropertyChange(() =&gt; <span class="hljs-keyword">this</span>.FullName);<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> FirstName + <span class="hljs-string">&quot; &quot;</span> + LastName; &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关联通知其它属性的代码集中放到构造函数里，比如：</p>
<blockquote>
<p>You can also wire things together in the constructor, like this:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> _firstName, _lastName;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.Bind(s =&gt; s.FirstName, (o, e) =&gt; NotifyOfPropertyChange(<span class="hljs-keyword">nameof</span>(FullName)));<br>      <span class="hljs-keyword">this</span>.Bind(s =&gt; s.LastName, (o, e) =&gt; NotifyOfPropertyChange(<span class="hljs-keyword">nameof</span>(FullName)));<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _firstName; &#125;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span> &#123; SetAndNotify(<span class="hljs-keyword">ref</span> _firstName, <span class="hljs-keyword">value</span>); &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _lastName; &#125;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span> &#123; SetAndNotify(<span class="hljs-keyword">ref</span> _lastName, <span class="hljs-keyword">value</span>); &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName<br>   &#123;<br>      <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> FirstName + <span class="hljs-string">&quot; &quot;</span> + LastName; &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="分配事件">分配事件</h2>
<p>默认情况下，<code>PropertyChanged</code>事件先在当前线程被引发，再由
WPF 具体负责分配到 UI 线程。当然，直接在 UI
线程中引发事件也没问题，<code>PropertyChangedBase</code>有一个名为<code>PropertyChangedDispatcher</code>的属性，该属性有一个名为<code>Execute.DefaultPropertyChangedDispatcher</code>的默认委托，将委托值设为<code>Execute.OnUIThread</code>即可。改变<code>PropertyChangedBase</code>所有子类的事件引发方式应重写<code>Configure</code>函数，示例代码如下：</p>
<blockquote>
<p>By default, PropertyChanged events are raised on the current thread
(and WPF takes care of dispatching them to the UI thread). If you do
want to change this, however, you can! PropertyChangedBase has a
property called PropertyChangedDispatcher, which has an
<code>Action&lt;Action&gt;</code>, and defaults to
Execute.DefaultPropertyChangedDispatcher (which you can assign) (which
has the value <code>a =&gt; a()</code>).</p>
<p>If you want to change this to execute on the UI thread, you can do
the following.</p>
<p>To change for all instances of PropertyChangedBase:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Bootstrapper</span> : <span class="hljs-title">Bootstrapper</span>&lt;<span class="hljs-title">MyRootViewModel</span>&gt;<br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Configure</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">base</span>.Configure();<br>      Execute.DefaultPropertyChangedDispatcher = Execute.OnUIThread;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>针对单独子类的示例代码如下：</p>
<blockquote>
<p>To change for just once instance of PropertyChangedBase:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>   &#123;<br>      <span class="hljs-keyword">this</span>.PropertyChangedDispatcher = Execute.OnUIThread;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="propertychanged.fody包">PropertyChanged.Fody包</h2>
<p><a
target="_blank" rel="noopener" href="https://github.com/Fody/PropertyChanged">PropertyChanged.Fody</a>是一个非常神奇的
nuget
包，它能在编译期自动将用于引发<code>PropertyChanged</code>通知的代码注入到相关属性中，这样就使得代码整体很简洁。同时能够自行识别哪些属性需要引发通知，示例代码如下：</p>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://github.com/Fody/PropertyChanged">PropertyChanged.Fody</a>
is a fantastic package, which injects code at compile-time to
automatically raise PropertyChanged notifications for your properties,
allowing you to write very concise code. It will also figure out
dependencies between your properties and raise notifications
appropriately for example:</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">PropertyChangedBase</span><br>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FirstName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> FullName &#123; <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> String.Format(<span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, <span class="hljs-keyword">this</span>.FirstName, <span class="hljs-keyword">this</span>.LastName); &#125; &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SomeMethod</span>()</span><br>   &#123;<br>      <span class="hljs-comment">// PropertyChanged notifications are automatically raised for both FirstName and FullName</span><br>      <span class="hljs-keyword">this</span>.FirstName = <span class="hljs-string">&quot;Fred&quot;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p><code>PropertyChangedBase</code>也注意与<code>Fody.PropertyChanged</code>的集成，实际采用<code>PropertyChangedDispatcher</code>引发通知。因此，<code>Screen</code>、
<code>ValidatingModelBase</code>或<code>PropertyChangedBase</code>的子类使用
<code>Fody.PropertyChanged</code>无需任何特别代码。</p>
<blockquote>
<p>PropertyChangedBase also takes care to integrate with
<code>Fody.PropertyChanged</code>. Notifications raised by
<code>Fody.PropertyChanged</code> are raised using the
<code>PropertyChangedDispatcher</code>.</p>
<p>Therefore you do not need to do anything special in order to use
<code>Fody.PropertyChanged</code> with any subclass of
<code>Screen</code>, <code>ValidatingModelBase</code>, or
<code>PropertyChangedBase</code>.</p>
</blockquote>
<h1 id="可绑定集合">可绑定集合</h1>
<h2 id="概述">概述</h2>
<p><code>BindableCollection&lt;T&gt;</code>集合类是<code>ObservableCollection</code>的子类，其实例一般用作
ItemsControl 族控件的数据源（增、减元素时 View
可以得到通知）。该集合类还新增了两个很有用的特性：</p>
<ul>
<li>新增方法<code>AddRange</code>, <code>RemoveRange</code> 和
<code>Refresh</code></li>
<li>线程安全</li>
</ul>
<blockquote>
<p><code>BindableCollection&lt;T&gt;</code> is a subclass of <a
target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/ms668604(v=vs.110).aspx"><code>ObservableCollection</code></a>.
It's the class to use if you have a collection of something in your
ViewModel, and want to use it as the <code>ItemsSource</code> / etc for
something in your View (and have the View be notified whenever an item
is added to / removed from that collection).</p>
<p>However, it adds a couple of useful extra features:</p>
<ul>
<li>New <code>AddRange</code>, <code>RemoveRange</code>, and
<code>Refresh</code> methods</li>
<li>Is thread-safe</li>
</ul>
</blockquote>
<h2 id="新方法">新方法</h2>
<p><code>ObservableCollection&lt;T&gt;</code>集合增加元素时需手动迭代每个元素并多次调用<code>collection.Add(element)</code>方法，如此就会引发大量新增元素事件。通过新增的方法<code>AddRange</code>
和<code>RemoveRange</code>，可以一次性批量增、减元素，同时只引发一次事件。</p>
<p><code>Refresh</code>
方法不会改变集合，它只是触发<code>PropertyChanged</code>
和<code>CollectionChanged</code> 事件，通知 UI
其绑定的集合发生了变化，请 UI
元素重载数据。尽管该方法很有用，但大多数场合都用不到。</p>
<blockquote>
<p><code>ObservableCollection&lt;T&gt;</code> is missing a couple of
very useful methods: <code>AddRange</code> and <code>RemoveRange</code>.
These do pretty much what you'd expect, allowing you to add a remove a
range of elements at once, without having to manually iterate over each
element and calling <code>collection.Add(element)</code> on each (while
raising lots of events for each element added). <code>AddRange</code>
and <code>RemoveRange</code> will raise one set of events per range
added/removed only.</p>
<p><code>Refresh</code> is a convenience. It does not modify the
collection in any way, but does cause the <code>PropertyChanged</code>
and <code>CollectionChanged</code> events to be fired, indicating to any
UI elements that the collection has been modified and that they should
reload their data. It's not often needed, but when it is it's
<em>really</em> needed.</p>
</blockquote>
<h2 id="线程安全">线程安全</h2>
<p>线程安全的实现方法是将集合元素的增加、删除、清空、重置等操作分配到的
UI 线程，具体分配工作由
<code>Execute.OnUIThreadSync</code>方法完成，也就是说：</p>
<ul>
<li>这些都是同步操作，即方法在动作完成后才返回；</li>
<li><code>PropertyChanged</code>和
<code>CollectionChanged</code>事件总是由 UI 线程引发；</li>
<li>？？？</li>
</ul>
<p>属性相关的操作总是在 UI 线程中完成，因此事件也由 UI
线程引发。基于此，<code>BindableCollection&lt;T&gt;</code>移除了
<code>PropertyChangedDispatcher</code>、<code>CollectionChangedDispatcher</code>属性，在<code>PropertyChangedBase</code>
中这些属性仍存在。</p>
<blockquote>
<p>Thread safety is achieved by dispatching all actions (adds, removes,
clear, reset, etc) to the UI thread. The dispatch uses
<code>Execute.OnUIThreadSync</code>, which means that:</p>
<ul>
<li>These operations are synchronous: the method being called won't
return until the action has been completed.</li>
<li>They're free if you're already on the UI Thread - the operation will
be carried out synchronously in this case.</li>
<li>All <code>PropertyChanged</code> and <code>CollectionChanged</code>
events are always raised on the UI thread.</li>
</ul>
<p>That last point means that there is no
<code>PropertyChangedDispatcher</code> property on
<code>BindableCollection&lt;T&gt;</code>, as there is with
<code>PropertyChangedBase</code> - the event is always raised on the UI
thread, since the operation the property relates to is always performed
on the UI thread. Similarly, there's no
<code>CollectionChangedDispatcher</code> concept.</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%BC%96%E7%A8%8B/">#编程</a>
      
        <a href="/tags/%E8%AF%91%E6%96%87/">#译文</a>
      
        <a href="/tags/C/">#C#</a>
      
        <a href="/tags/MVVM/">#MVVM</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Stylet框架非官方中文文档</div>
      <div>https://3roman.github.io/遨游码海/CSharp/Stylet框架非官方中文文档/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>3roman</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年12月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/" title="托管代码简介">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">托管代码简介</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/%E9%81%A8%E6%B8%B8%E7%A0%81%E6%B5%B7/CSharp/Dapper%E6%A1%86%E6%9E%B6%E9%9D%9E%E5%AE%98%E6%96%B9%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/" title="Dapper框架非官方中文文档">
                        <span class="hidden-mobile">Dapper框架非官方中文文档</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
